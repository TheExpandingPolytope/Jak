/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: layout, type, uniform_names, anim_lengths */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"layout\", function() { return layout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"type\", function() { return type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniform_names\", function() { return uniform_names; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"anim_lengths\", function() { return anim_lengths; });\nconst layout = {\n    \"POSITION\" : 0,\n    \"NORMAL\" : 1,\n    \"TEXCOORD_0\" : 2,\n    \"COLOR_0\": 3,\n    \"TANGENT\": 4,\n};\n\nconst type = {\n    \"VEC2\" : 2,\n    \"VEC3\" : 3,\n    \"VEC4\" : 4,\n    \"SCALAR\" : 1,\n}\n\nconst uniform_names = {\n    \"view\" : \"view\",\n    \"perspective\" : \"perspective\",\n    \"env_map\" : \"env_map\",\n    'diffuse_map' : 'diffuse_map',\n    'prefilter_map' : 'prefilter_map',\n    'brdflut_map' : 'brdflut_map',\n}\n\nconst anim_lengths = {\n    \"translation\" : 3,\n    \"rotation\" : 4,\n    \"scale\" : 3,\n    \"matrix\" : 16\n}\n\n//# sourceURL=webpack:///./src/config.js?");

/***/ }),

/***/ "./src/gltf_loader.js":
/*!****************************!*\
  !*** ./src/gltf_loader.js ***!
  \****************************/
/*! exports provided: download, load, env_map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"download\", function() { return download; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return load; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"env_map\", function() { return env_map; });\n/* harmony import */ var _includes_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./includes/index.js */ \"./src/includes/index.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n/* harmony import */ var _includes_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./includes/common.js */ \"./src/includes/common.js\");\n\n\n\nvar HDRImage  = __webpack_require__(/*! ./includes/hdrpng.js */ \"./src/includes/hdrpng.js\");\n \nvar url = \"\";\nvar path = \"\";\n\nvar vertex_shader_src_default = `\nlayout( location = 0 ) in vec3 position;\n\nuniform mat4 perspective;\nuniform mat4 view;\nuniform mat4 model;\n\nvoid main(){\n    gl_Position = perspective*view*model*vec4(position, 1.0);\n}\n`;\nvar fragment_shader_src_default = `\n    precision mediump float;\n    out vec4 color;\n    void main(){\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n`;\n\nvar vertex_shader_src = `\nlayout( location = 0 ) in vec3 position;\nlayout( location = 1 ) in vec3 normal;\nlayout( location = 2 ) in vec2 texcoords;\n\nuniform mat4 perspective;\nuniform mat4 view;\nuniform mat4 model;\n\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_texcoords;\n\nvoid main(){\n    gl_Position = perspective*view*model*vec4(position, 1.0);\n    v_position = (view*model*vec4(position, 1.0)).xyz;\n    v_normal = mat3(transpose(inverse(view*model))) * normal;\n    v_texcoords = texcoords;\n}\n`;\n\n\nvar fragment_shader_src = `\n#define NUM_LIGHTS 1\nprecision mediump float;\n\nin vec3 v_position;\nin vec3 v_normal;\nin vec2 v_texcoords;\n\nuniform sampler2D emissiveTexture;\nvec3 emissive;\n\nuniform sampler2D normalTexture;\n\nvec3 normal;\n\nuniform sampler2D occlusionTexture;\nfloat occlusion;\n\nuniform sampler2D baseColorTexture;\nvec4 base_color;\n\nuniform sampler2D metallicRoughnessTexture;\nfloat roughness;\nfloat metallic;\n\nuniform samplerCube env_map;\nuniform samplerCube diffuse_map;\nuniform samplerCube prefilter_map;\nuniform sampler2D brdflut_map;\n\n//light variables\nvec3 light_positions[1];\nvec3 light_colors[1];\n\nconst float PI = 3.14159265359;\n\n//set lights functions\nvoid set_lights(){\n  light_positions[0] = vec3(5);\n  light_colors[0] = vec3(10);\n}\n\n//length function \n/*float length(vec3 operand){\n  return sqrt((operand.x*operand.x)+(operand.y*operand.y)+(operand.z*operand.z));\n}*/\nout vec4 color;\n\n//pbr functions\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 getNormal(){\n  vec3 pos_dx = dFdx(v_position);\n  vec3 pos_dy = dFdy(v_position);\n  vec3 tex_dx = dFdx(vec3(v_texcoords, 0.0));\n  vec3 tex_dy = dFdy(vec3(v_texcoords, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n  vec3 ng = v_normal;\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n\n  #ifdef NORMALTEXTURE\n  vec3 n = texture(normalTexture, v_texcoords).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(1, 1, 1.0)));\n  #else\nvec3 n = tbn[2].xyz;\n#endif\n\n  return n;\n}\n \nvoid main() {\n  //set lights\n  set_lights();\n\n  //set material info\n  #ifdef BASECOLORTEXTURE\n  base_color = texture(baseColorTexture, v_texcoords);\n  #endif\n\n  normal = getNormal();\n\n  #ifdef METALLICROUGHNESSTEXTURE\n  metallic = texture(metallicRoughnessTexture, v_texcoords).b;\n  roughness = texture(metallicRoughnessTexture, v_texcoords).g;\n  #endif\n\n  #ifdef OCCLUSIONTEXTURE\n  occlusion = texture(occlusionTexture, v_texcoords).r;\n  #endif\n\n  #ifdef EMISSIVETEXTURE\n  emissive = texture(emissiveTexture, v_texcoords).rgb;\n  #endif\n\n  //set geometry info\n  vec3 n = normalize(normal);\n  vec3 v = normalize(-v_position);\n  vec3 R = -normalize(reflect(v, n));   \n\n\n  //calculate surface reflectivity for fresnel schlick\n  vec3 f0 = vec3(0.04);\n  f0 = mix(f0, base_color.rgb, metallic);\n\n  //init radiance\n  vec3 Lo = vec3(0.0);\n  for(int i = 0; i < NUM_LIGHTS; ++i){\n\n    //calculate light vector\n    vec3 l = normalize(light_positions[i] - v_position);\n\n    //calculate halfway vector\n    vec3 h = normalize(l+v);\n\n    float distance    = length(light_positions[i] - v_position);\n    float attenuation = 1.0 / (distance * distance);\n    vec3 radiance     = light_colors[i] * attenuation;        \n    \n    // cook-torrance brdf\n    float NDF = DistributionGGX(n, h, roughness);        \n    float G   = GeometrySmith(n, v, l, roughness);      \n    vec3 F    = fresnelSchlickRoughness(max(dot(n, v), 0.0), f0, roughness);;       \n    \n      \n    \n    //calculate specular component\n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, l), 0.0) + 0.001;\n    vec3 specular     = numerator / denominator;  \n    \n    //calulate diffuse\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\t\n\n    // integrate to outgoing radiance Lo\n    float NdotL = max(dot(n, l), 0.0);                \n    Lo += (kD * base_color.rgb / PI + specular) * radiance * NdotL;\n  }\n\n  vec3 F = fresnelSchlickRoughness(max(dot(n, v), 0.0), f0, roughness);\n\n  //diffuse ibl\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - metallic;\t  \n  vec3 irradiance = texture(diffuse_map, n).rgb;\n  vec3 diffuse    = irradiance * base_color.rgb;\n\n  //calculate speculare ibl\n  const float MAX_REFLECTION_LOD = 40.0;\n  vec3 prefilteredColor = texture(prefilter_map, R,  roughness).rgb;   \n  vec2 envBRDF  = texture(brdflut_map, vec2(max(dot(n, v), 0.0), roughness)).rg;\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n  vec3 ambient    = (kD * diffuse + (specular)) ; \n  \n  vec3 c = ambient + Lo;\n\n  #ifdef OCCLUSIONTEXTURE\n  c *= occlusion;\n  #endif\n\n  #ifdef EMISSIVETEXTURE\n  c+=emissive;\n  #endif\n\n  //c = c / (c + vec3(1.0));\n  c = pow(c, vec3(1.0/1.8));\n\n  //set color \n  color = vec4(c, 1);\n\n}\n`;\n\nMath.clamp=function(min,val,max){ return Math.min(Math.max(min, val), max)};\n\nclass perspective_camera {\n    constructor(fovy, aspect, near, far){\n        //set perspective parameters\n        this.fovy = fovy;\n        this.aspect = aspect;\n        this.near = near;\n        this.far = far;\n\n        //set perspective matrix\n        this.perspective_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(this.perspective_matrix, this.fovy, this.aspect, this.near, this.far);\n\n        //set eye\n        this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 1);\n        //set target\n        this.target =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 0);\n        //set up vector\n        this.up =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 1, 0);\n        //set view matrix\n        this.view_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\n    }\n    set_perspective_uniform(gl, location){\n        gl.uniformMatrix4fv(location, false, this.perspective_matrix);\n    }\n    set_view_uniform(gl, location){\n        gl.uniformMatrix4fv(location, false, this.view_matrix);\n    }\n    set_orbit_controls(gl, max, min){\n        //initialize control variables\n        this.mousedown = false;\n        this.temp_mouse_x = 0;\n        this.temp_mouse_y = 0;\n        this.distance = 7*Math.sqrt((max[0]*max[0])+(max[1]*max[1])+(max[2]*max[2]));\n        console.log(this.distance);\n\n        //set camera far to twice the distance\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(this.perspective_matrix, this.fovy, this.aspect, this.near, this.distance*10);\n        this.angle1 = 0;\n        this.angle2 = 0;\n        this.gain = 10;\n        this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(this.distance, 0, 0);\n        this.target = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues((max[0]+min[0])/2,(max[1]+min[1])/2,(max[2]+min[2])/2);\n        //this.eye = vec3.fromValues(1, 0, 0);\n        //this.target = vec3.fromValues(0, 0, 0);\n\n        //compute view matrix\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\n        \n\n        //set listeners\n        gl.canvas.addEventListener('mousedown', (event)=>{\n            //set mouse down to true\n            this.mousedown = true;\n            //record position of mouse\n            this.temp_mouse_x = event.clientX;\n            this.temp_mouse_y = event.clientY;\n            this.temp_angle_1 = this.angle1;\n            this.temp_angle_2 = this.angle2;\n        });\n\n        gl.canvas.addEventListener('mouseup',(event)=>{\n            this.mousedown = false;\n        });\n\n        gl.canvas.addEventListener('mousemove', (event)=>{\n            if(this.mousedown){\n                //set mouse coordinates\n                var mouse_x = event.clientX,\n                mouse_y = event.clientY;\n                //set angles\n                var dx = this.gain * (mouse_x - this.temp_mouse_x)/window.innerWidth,\n                dy = this.gain * (mouse_y - this.temp_mouse_y)/window.innerHeight;\n                this.angle1 = this.temp_angle_1 + dx;\n                this.angle2 = Math.clamp( -Math.PI/2,this.temp_angle_2 + dy, Math.PI/2);\n                //compute eye\n                var t = this.distance * Math.cos(this.angle2),\n                y = this.distance * Math.sin(this.angle2) + this.target[1],\n                x = t * Math.cos(this.angle1) + this.target[0],\n                z = t * Math.sin(this.angle1) + this.target[2];\n                this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(x, y, z);\n                //compute view matrix\n                _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\n            }\n        });\n        gl.canvas.addEventListener('wheel', (event) =>{\n            event.preventDefault();\n            //caltulate mouse scroll\n            var delta = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].dist(this.eye, this.target)*.1;\n            if (event.deltaY < 0) {\n                this.distance -= delta;\n              }\n              if (event.deltaY > 0) {\n                this.distance += delta;\n              }\n              //compute eye\n              var t = this.distance * Math.cos(this.angle2),\n              y = this.distance * Math.sin(this.angle2) + this.target[1],\n              x = t * Math.cos(this.angle1) + this.target[0],\n              z = t * Math.sin(this.angle1) + this.target[2];\n              this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(x, y, z);\n              //compute view matrix\n              _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\n        });\n\n        gl.canvas.addEventListener('contextmenu', (event)=>{\n            event.preventDefault();\n        });\n    }\n}\n\n\nfunction load(gl, filepath){\n    url = \"\";\n    path = \"\";\n    return download(filepath, \"text\")\n    .then(function(request){\n        url = request.responseURL;\n        path = url.slice(0, url.lastIndexOf(\"/\")+1);\n        return JSON.parse(request.responseText);\n    })\n    .then(function(gltf){\n        return process_scene(gl, gltf);\n    });\n}\n\nfunction download(filepath, response_type)\n{\n    //check if \n    if(filepath.search(\"data:\") == -1){\n        filepath = path+filepath;\n    }\n\n    var xhr = new XMLHttpRequest();  \n    return new Promise(function(resolve,reject){\n        xhr.onreadystatechange = ()=>{\n            if(xhr.readyState !== 4) return false;\n            if(xhr.readyState==4 && xhr.status==200){\n                resolve(xhr);\n            }else{\n                reject({\n                    status:xhr.status,\n                    statusText:xhr.statusText,\n                });\n            }\n        }\n        xhr.open('GET',filepath);\n        if(response_type) xhr.responseType = response_type;\n        xhr.send();\n    });\n}\n\nfunction download_image(filepath)\n{\n    //check if \n    if(filepath.search(\"data:\") == -1){\n        filepath = path+filepath;\n    }\n\n    return new Promise((resolve, reject) => {\n        //set image\n        let image = new Image();\n\n        //resolve image on load\n        image.onload = function(){\n            resolve(image);\n        }\n\n        //reject image on error\n        image.onerror =  function() {\n          reject(new Error(`Failed to load image's URL: ${filepath}`));\n        };\n\n        //load image\n        image.src = filepath;\n    });\n}\n\n\nfunction timestamp() {\n    return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();\n}\n\nfunction process_scene(gl, gltf, scene_number)\n{\n    //set camera controls parameters\n    gltf._max = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 0);\n    gltf._min = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 0);\n\n    //set all loads array\n    gltf._loads = [];\n\n    //set renders array\n    gltf._renders = [];\n\n    //set animations array\n    gltf._animations = [];\n    \n    //set scene number\n    if(scene_number==undefined) \n        scene_number=0;\n\n    //set nodes\n    var nodes = gltf.scenes[scene_number].nodes;\n\n    //check to see if there are any nodes in the scene\n    if(nodes.length==0) \n        return false;\n\n    //create default fallback material\n    set_default_material(gl, gltf);\n\n    //process nodes \n    for(var i=0; i < nodes.length; i++)\n        process_node(gl,gltf,nodes[i]);\n\n    //process animations\n    if(gltf.animations)\n        for(var i=0; i < gltf.animations.length; i++)\n            process_animation(gl, gltf, gltf.animations[i]);\n\n\n    //load environment\n    env_map(gl, gltf);\n\n    //set camera\n    gltf._camera = new perspective_camera(0.2, gl.canvas.width/gl.canvas.height, 0.1, 100);\n\n    //set animation function\n    gltf._animate =  gltf.animations && gltf._animations ? function(time){\n        //by default use the first animation\n        gltf._animations[0](time);\n    } : ()=>{};\n    var now, dt, last = timestamp()/1000;\n\n    //set render function\n    gltf._render = function(){\n        //animate\n        now = timestamp()/1000; \n        dt = (last - now);\n        //console.log(dt);\n        gltf._animate( dt );\n\n        //render\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.enable(gl.DEPTH_TEST);\n        gltf._renders.forEach((func)=>{\n            func();\n        });\n\n        //set last time\n        last = now;\n\n        //loop\n        requestAnimationFrame(gltf._render);\n    }\n\n    //return promise once everything is loaded\n    return Promise.all(gltf._loads).then(()=>{\n\n        //set orbital controls \n        gltf._camera.set_orbit_controls(gl, gltf._max, gltf._min);\n\n        //return/ resolve gltf object\n        return gltf;\n    });\n    \n}\n\n\n//load accessor data\nfunction process_anim_accessor(gl, gltf, accessor_num, sampler, is_input, animation){\n    //set accessor\n    var accessor = gltf.accessors[accessor_num];\n\n    //process accessor, bufferView, and buffer ( load buffer data )\n    //set buffer view\n    var bufferView = gltf.bufferViews[accessor.bufferView];\n    \n    //set buffer\n    var buffer = gltf.buffers[bufferView.buffer];\n\n    //load buffer data if not set\n    if(!buffer._onload){\n        //set onload to a promise\n        buffer._onload = download(buffer.uri, 'arraybuffer');\n        //add to all loads\n        gltf._loads.push(buffer._onload);\n    }\n    \n    //set data\n    buffer._onload.then((data)=>\n    {\n        //set array buffer positions\n        var byte_offset = bufferView.byteOffset;\n        var length = bufferView.byteLength;\n        if(accessor.byteOffset) \n        {\n            byte_offset += accessor.byteOffset;\n            length -= accessor.byteOffset;\n        }\n\n\n        //load data to array\n        console.log(length);\n        var value = new Float32Array(data.response, byte_offset,accessor.count*_config_js__WEBPACK_IMPORTED_MODULE_1__[\"type\"][accessor.type]);\n        console.log(value);\n        if(is_input){\n            sampler._inputs = value;\n            //find greatest and smallest input value\n            sampler._max_input = -100000;\n            sampler._min_input = 100000;\n            sampler._inputs.forEach((input)=>{\n                if(input > sampler._max_input){\n                    sampler._max_input = input;\n                }\n                if(input <sampler._min_input){\n                    sampler._min_input = input;\n                }\n            });\n            //set global animation min and max times\n            if(sampler._min_input < animation._min_time){\n                animation._min_time = sampler._min_input;\n            }\n            if(sampler._max_input > animation._max_time){\n                animation._max_time = sampler._max_input;\n            }\n\n        }\n        else\n            sampler._outputs = value;\n    });\n}\n\n//update node matrix model and its children\nfunction update_node_model(gltf, node, parent) \n{\n    set_node_matrix(node, parent);\n    if(node.children)\n        for(var i = 0; i < node.children.length; i++)\n            update_node_model(gltf,gltf.nodes[node.children[i]], node);\n}\n\nfunction process_anim_sampler(gl, gltf, sampler, animation)\n{\n    console.log(\"processing sampler\");\n    //set input data\n    process_anim_accessor(gl, gltf, sampler.input, sampler, true, animation);\n\n    //set output data\n    process_anim_accessor(gl, gltf, sampler.output, sampler, false, animation);\n}\n\n//append an animation function to root\nfunction process_animation(gl, gltf, animation) \n{\n    //define our animation name if not defined\n    animation.name = animation.name ? animation.name : \"unnamed_anim\";\n\n    //set our min and max times\n    animation._min_time = 100000;\n    animation._max_time = -100000;\n    //process samplers\n    if(animation.samplers)\n        for(var i = 0; i < animation.samplers.length; i++)\n            process_anim_sampler(gl, gltf, animation.samplers[i],animation);\n\n    //\n    var time = 0;\n    //create animation function\n    animation._animate = function( t ) {\n\n        time = time + Math.abs(t);\n        if( time > animation._max_time)\n            time = animation._min_time;\n\n        animation.channels.forEach( (channel) =>{\n\n            var node = gltf.nodes[channel.target.node];\n            var path = node[channel.target.path];\n            var sampler = animation.samplers[channel.sampler];\n            \n            \n            \n            if(time < sampler._min_input || time > sampler._max_input)\n                return;\n\n            var closest_distance_less = 100000;\n            var closest_distance_great = 100000;\n            var t1=0 ,t2=0;\n            var between = [undefined, undefined];\n            if(sampler._inputs)\n            sampler._inputs.forEach( (input, index) =>{\n                var current_distance =  time - input;\n                    \n                if( current_distance > 0){\n                    if(Math.abs(current_distance)< closest_distance_less){\n                        t1 = input;\n                        between[0] = index;\n                        closest_distance_less = Math.abs(current_distance);\n                    }\n                    //then less than\n                    \n                }else{\n                    //greater than\n                    if(Math.abs(current_distance)< closest_distance_great){\n                        t2 = input;\n                        between[1] = index;\n                        closest_distance_great = Math.abs(current_distance);\n                    }\n                    \n                }\n            });\n\n            //set interpolated value\n            //if(between[0] == undefined || between[1] == undefined)\n              //  return;\n            //console.log(between);\n            //console.log(  channel.target.path + \":\" + t1 + \" \" + time + \" \" + t2 );\n            var dt = t2-t1;\n            var dt2 = time - t1;\n            var dproportion = dt2/dt;\n\n            var val = [];\n            var val1 = [];\n            var val2 = [];\n            var dvar;\n            for(var i=0; i < _config_js__WEBPACK_IMPORTED_MODULE_1__[\"anim_lengths\"][channel.target.path]; i++){\n                val1.push(sampler._outputs[(between[0]*_config_js__WEBPACK_IMPORTED_MODULE_1__[\"anim_lengths\"][channel.target.path])+i]);\n                val2.push(sampler._outputs[(between[1]*_config_js__WEBPACK_IMPORTED_MODULE_1__[\"anim_lengths\"][channel.target.path])+i]);\n                dvar = val2[i]-val1[i];\n                val.push(val1[i]+dproportion*dvar);\n            }\n            node[channel.target.path] = val;\n            //console.log(node._model);\n            //update model\n            console.log(  channel.target.path + \":\" + val);\n            update_node_model(gltf, node);\n\n        });\n\n    }\n    gltf._animations.push(animation._animate);\n\n}\n\n//set final node matrix\nfunction set_node_matrix(node, parent)\n{\n    //set model matrix data\n    var m_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].identity(m_matrix);\n\n    //if have matrix\n    if(node.matrix){\n        m_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].clone(node.matrix);\n    }\n    else{\n        //set translation of matrix\n        if(!node.translation) {\n            node.translation = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0,0,0);\n        };\n\n        //set rotation of matrix\n        if(!node.rotation){\n            node.rotation = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].create();\n            _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].identity(node.rotation);\n        }\n\n        //set scale of matrix\n        if(!node.scale){\n            node.scale = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].create();\n            node.scale = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(1,1,1);\n        }\n\n        //set matrix from rotation translation and scale\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].fromRotationTranslationScale(m_matrix, _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].fromValues(...node.rotation), node.translation, node.scale);\n    }\n\n    //set node model\n    node._model = ( parent != undefined ) ? _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].multiply(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), parent._model, m_matrix) : m_matrix;\n}\n\n\n//process node, set matrix\nfunction process_node(gl, gltf, node_num, parent_num)\n{\n    //set node\n    var node = gltf.nodes[node_num];\n\n    //set parent\n    var parent = ( parent_num != undefined ) ?  gltf.nodes[parent_num] : undefined;\n    \n    //set model matrix\n    set_node_matrix(node, parent);\n\n    //process mesh if have\n    if(node.mesh >= 0)\n        process_mesh(gl, gltf, node.mesh, node);\n\n    \n    //process children nodes\n    if(node.children)\n        for(var i = 0; i < node.children.length; i++)\n            process_node(gl, gltf, node.children[i], node);\n\n}\n\n\n//process mesh, set primitive vao's\nfunction process_mesh(gl, gltf, mesh_num, node)\n{\n    //initialize variables\n    var mesh = gltf.meshes[mesh_num];\n\n    //process primitives in mesh\n    if(mesh.primitives)\n    for(var i = 0; i < mesh.primitives.length; i++){\n\n        //prepare primitive rendering function constants\n        var accessor, material;\n\n        //set primitives\n        var primitive = mesh.primitives[i];\n\n        //create vao\n        primitive._vao = gl.createVertexArray();\n        gl.bindVertexArray(primitive._vao);\n        \n        //process attributes in primitive\n        if(primitive.attributes)\n            for(const key in primitive.attributes) \n                process_accessor(gl, gltf, primitive.attributes[key], key, primitive._vao); \n\n\n        //process indices\n        if(primitive.indices >= 0){\n            process_accessor(gl, gltf, primitive.indices,undefined, primitive._vao);\n            accessor = gltf.accessors[primitive.indices];\n        }\n        else\n            //no index buffer\n            console.log(\"This mesh does not have an index buffer\");\n\n        gl.bindVertexArray(null);\n\n        //process material\n        if(primitive.material >= 0){\n            process_material(gl, gltf, primitive.material);\n            material = gltf.materials[primitive.material]\n        }\n        else\n            //set primitive.material to default\n            material = gltf._default_material;\n        \n                \n        //set primitive rendering function \n        primitive._render = function(){\n            \n            //\n            //gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            //bind vao\n            gl.bindVertexArray(primitive._vao);\n\n            //bind element array buffer\n            //gl.bindBuffer(bufferView.target, accessor._buffer);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, accessor._buffer);\n\n            //use shader\n            gl.useProgram(material._shader_program);\n\n            //set uniforms\n            var perspective_loc = gl.getUniformLocation(material._shader_program, \"perspective\");\n            var view_loc = gl.getUniformLocation(material._shader_program, \"view\");\n            gl.uniformMatrix4fv(perspective_loc, gl.FALSE, gltf._camera.perspective_matrix);\n            gl.uniformMatrix4fv(view_loc, gl.FALSE, gltf._camera.view_matrix);\n\n            var model_loc = gl.getUniformLocation(material._shader_program, 'model');\n\n            //set model uniform\n            gl.uniformMatrix4fv(model_loc, gl.FALSE, node._model);\n            //console.log(node._model);\n            //load material\n            var index = 0;\n\n            //Do not load textures or environment map if the material is the default one\n            if(!material._is_defualt){\n                material._textures.forEach((element)=>{\n                    var uniform_loc = material._uniform_locs[element.name];\n                    //add texture\n                    var texture = gltf.textures[element.index];\n                    gl.activeTexture(gl.TEXTURE0 + index);\n                    gl.bindTexture(gl.TEXTURE_2D, texture._buffer);\n                    gl.uniform1i(uniform_loc, index);\n                    index++;\n                });\n    \n                var diffuse_loc = gl.getUniformLocation(material._shader_program, \"diffuse_map\");\n                var prefilter_loc = gl.getUniformLocation(material._shader_program, \"prefilter_map\");\n                var brdflut_loc = gl.getUniformLocation(material._shader_program, \"brdflut_map\");\n    \n                //set environment uniforms\n                gltf._environment.set_diffuse_uniform(gl, index, diffuse_loc);\n                gltf._environment.set_prefilter_uniform(gl, ++index, prefilter_loc);\n                gltf._environment.set_brdflut_uniform(gl, ++index, brdflut_loc);\n            }\n            \n            \n\n            //draw\n            //gl.drawElements(primitive.mode, accessor.count, accessor.componentType, 0);\n            gl.drawElements(gl.TRIANGLES, accessor.count, accessor.componentType, 0);\n\n        }\n\n        gltf._renders.push(primitive._render);\n\n    }\n    \n}\n\n//processes accessors and buffer data\nfunction process_accessor(gl, gltf, accessor_num, key, vao){ \n    //set accessor\n    var accessor = gltf.accessors[accessor_num];\n\n    //create buffer\n    accessor._buffer = gl.createBuffer();\n\n\n    //process accessor, bufferView, and buffer ( load buffer data )\n    //set buffer view\n    var bufferView = gltf.bufferViews[accessor.bufferView];\n    \n    //set buffer\n    var buffer = gltf.buffers[bufferView.buffer];\n\n    //load buffer data if not set\n    if(!buffer._onload){\n        //set onload to a promise\n        buffer._onload = download(buffer.uri, 'arraybuffer');\n\n        //add to all loads\n        gltf._loads.push(buffer._onload);\n    }\n\n    //set buffer data\n    buffer._onload.then((data)=>\n    {\n        //set array buffer positions\n        var byte_offset = bufferView.byteOffset;\n        var length = bufferView.byteLength;\n        if(accessor.byteOffset) \n        {\n            byte_offset += accessor.byteOffset;\n            length -= accessor.byteOffset;\n        }\n        \n        //bind vao\n        gl.bindVertexArray(vao);\n\n        if(key != undefined)\n        { \n            //load data to array\n            var array = new Float32Array(data.response, byte_offset,length/Float32Array.BYTES_PER_ELEMENT);\n            \n            //set buffer data\n            /*gl.bindBuffer(bufferView.target, accessor._buffer);\n            gl.bufferData(bufferView.target, array, gl.STATIC_DRAW);*/\n            gl.bindBuffer(gl.ARRAY_BUFFER, accessor._buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n\n            //set vertex attrib pointer\n            gl.enableVertexAttribArray(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"][key]);\n            gl.vertexAttribPointer(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"][key], _config_js__WEBPACK_IMPORTED_MODULE_1__[\"type\"][accessor.type], accessor.componentType, false, 0, 0);\n\n            //gl.bindBuffer(bufferView.target, null);\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n            //if accessor is position, set min and maximum value\n            if(key == \"POSITION\"){\n                gltf._min[0] = gltf._min[0] > accessor.min[0] ? accessor.min[0] : gltf._min[0];\n                gltf._min[1] = gltf._min[1] > accessor.min[1] ? accessor.min[1] : gltf._min[1];\n                gltf._min[2] = gltf._min[2] > accessor.min[2] ? accessor.min[2] : gltf._min[2];\n                gltf._max[0] = gltf._max[0] < accessor.max[0] ? accessor.max[0] : gltf._max[0];\n                gltf._max[1] = gltf._max[1] < accessor.max[1] ? accessor.max[1] : gltf._max[1];\n                gltf._max[2] = gltf._max[2] < accessor.max[2] ? accessor.max[2] : gltf._max[2];\n            }\n            \n\n        }else\n        {\n            //load data to array\n            var array = new Uint16Array(data.response, byte_offset, length/Uint16Array.BYTES_PER_ELEMENT);\n            \n            //create and set buffer data\n            accessor._buffer = gl.createBuffer();\n            /*gl.bindBuffer(bufferView.target, accessor._buffer);\n            gl.bufferData(bufferView.target, array, gl.STATIC_DRAW);*/\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, accessor._buffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);\n\n            //gl.bindBuffer(bufferView.target, null);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        }\n\n        //unbind vao\n        //gl.bindVertexArray(null);\n    });\n\n}\n\n//build and return gltf shader program\nfunction shader_program(gl, params, vs_src, fs_src){\n    //set params text\n    var param_text = '#version 300 es \\n';\n    if(params != undefined)\n    for(var i = 0; i < params.length; i++){\n        var key = params[i].toUpperCase();\n        param_text += '#define '+key+'\\n';\n    }\n\n    //create and compile vertex shader\n    var vs = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vs, param_text + vs_src);\n    gl.compileShader(vs);\n    //IF DEBUG\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\n        //console.log(gl.getShaderInfoLog(vs));\n        gl.deleteShader(vs);\n        return false;\n    }\n\n    //create and compile fragment shader\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fs, param_text + fs_src);\n    //console.log(param_text + fragment_shader_src);\n    gl.compileShader(fs);\n    //IF DEBUG\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\n        console.log(gl.getShaderInfoLog(fs));\n        gl.deleteShader(fs);\n        return false;\n    }\n\n    //link program\n    var prog = gl.createProgram();\n    gl.attachShader(prog, vs);\n    gl.attachShader(prog, fs);\n    gl.linkProgram(prog);\n    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){\n        console.log(gl.getProgramInfoLog(prog));\n        gl.deleteProgram(prog);\n        return false;\n    }\n\n    return prog;\n    \n}\n//create default material\nfunction set_default_material(gl, gltf){\n    //compile program\n    //set default material\n    var material = gltf._default_material = {}\n\n    //set to default\n    material._is_defualt = true;\n\n    //set program\n    material._shader_program = shader_program(gl, [], vertex_shader_src_default, fragment_shader_src_default)\n\n}\n//process textures and compile shader program\nfunction process_material(gl, gltf, material_num) {\n    //set material\n    var material = gltf.materials[material_num];\n\n    //set shader params\n    material._shader_params = [];\n\n    //set textures\n    material._textures = [];\n    \n    //traverse material object\n    for(const key in material) {\n        \n        if(key != \"_shader_params\" && key != \"name\" && key != \"_textures\" && key != \"_uniform_locs\")\n        //check if a texture\n        if(key.includes('Texture')){\n            material._shader_params.push(key)\n            material._textures.push({\"index\":material[key].index, \"name\": key});\n            process_texture(gl, gltf, material[key].index);\n        }\n        //check if a factor\n        else if(key.includes('Factor')){\n            material._shader_params.push(key)\n        } \n        //then must be another material\n        else{\n            var _material = material[key];\n            for(const _key in _material) \n            {\n                console.log(_key);\n                //check if a texture\n                if(_key.includes('Texture')){\n                    //add shader param\n                    material._shader_params.push(_key);\n                    material._textures.push({\"index\":_material[_key].index, \"name\": _key});\n                    process_texture(gl, gltf, _material[_key].index);\n                }\n                //check if a factor\n                else if(_key.includes('Factor')){\n                    //add shader param\n                    material._shader_params.push(_key);\n                }\n            }\n        }\n    }\n\n    //create and set shader program\n    material._shader_program = shader_program(gl, material._shader_params, vertex_shader_src, fragment_shader_src);\n\n    //set uniform locations\n\n    material._uniform_locs = {};\n    material._shader_params.forEach((key)=>{\n        material._uniform_locs[key] = gl.getUniformLocation(material._shader_program, key);\n    });\n}\n\nfunction process_texture(gl, gltf, texture_num){\n    //set texture\n    var texture = gltf.textures[texture_num];\n\n    //create texture\n    texture._buffer = gl.createTexture();\n\n    //set image\n    var _image = gltf.images[texture.source];\n\n    //set sampler\n    var sampler = texture.sampler||gltf.samplers ? gltf.samplers[texture.sampler] : undefined;\n\n    //load image data\n    if(!_image._onload){\n        //set onload to a promise\n        _image._onload = download_image(_image.uri).then((image)=>{\n            //bind buffer\n            gl.bindTexture(gl.TEXTURE_2D, texture._buffer);\n    \n            //set sampler data\n            if(sampler){\n            if(sampler.wrapS){\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, sampler.wrapS);\n            }\n            if(sampler.wrapT){\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, sampler.wrapT);\n            }\n            if(sampler.minFilter){\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, sampler.minFilter);\n            }\n            if(sampler.magFilter){\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, sampler.magFilter);\n            }\n            }else{\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            }\n    \n            //set data\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\n            gl.generateMipmap(gl.TEXTURE_2D);\n            \n            gl.bindTexture(gl.TEXTURE_2D, null);\n\n            return _image.uri;\n        });;\n\n        //add to all load\n        gltf._loads.push(_image._onload);\n    }\n\n    //set texture buffer data\n\n}\n\n\n/*\n//loads buffer data and sets vertex attrib pointer\nfunction set_buffer(gl, array_data, gl_buffer_id, layout_name,attrib_type, data_type){\n    //set buffer data\n    gl.bindBuffer(gl.ARRAY_BUFFER,gl_buffer_id);\n    gl.bufferData(gl.ARRAY_BUFFER, array_data, gl.STATIC_DRAW);\n\n    //set vertex attrib pointer\n    gl.enableVertexAttribArray(layout[layout_name]);\n    gl.vertexAttribPointer(layout[layout_name], attrib_sizes[attrib_type], data_type, false, 0, 0);\n}\n\n//loads element array buffer\nfunction set_indices_buffer(gl, array_data, gl_buffer_id){\n    //set buffer data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl_buffer_id);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array_data, gl.STATIC_DRAW);\n}\n*/\n\n\n\n\n\n// ENVIRONMENT MAP LOAD\n\n// ENVIRONMENT MAP LOAD\n\n// ENVIRONMENT MAP LOAD\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) == 0;\n}\nfunction load_image(url, on_load){\n    var image = new Image();\n    image.onload = on_load;\n    image.src = url;\n    return image;\n}\n//loads environmental map and returns a renderable\nfunction env_map(gl, gltf){\n    //enable seamless cube maps\n    //SET CUBE MAP VERTEX DATA\n    const vertex_data = new Float32Array([\n        -1.0,  1.0, -1.0,\n            -1.0, -1.0, -1.0,\n            1.0, -1.0, -1.0,\n            1.0, -1.0, -1.0,\n            1.0,  1.0, -1.0,\n            -1.0,  1.0, -1.0,\n\n            -1.0, -1.0,  1.0,\n            -1.0, -1.0, -1.0,\n            -1.0,  1.0, -1.0,\n            -1.0,  1.0, -1.0,\n            -1.0,  1.0,  1.0,\n            -1.0, -1.0,  1.0,\n\n            1.0, -1.0, -1.0,\n            1.0, -1.0,  1.0,\n            1.0,  1.0,  1.0,\n            1.0,  1.0,  1.0,\n            1.0,  1.0, -1.0,\n            1.0, -1.0, -1.0,\n\n            -1.0, -1.0,  1.0,\n            -1.0,  1.0,  1.0,\n            1.0,  1.0,  1.0,\n            1.0,  1.0,  1.0,\n            1.0, -1.0,  1.0,\n            -1.0, -1.0,  1.0,\n\n            -1.0,  1.0, -1.0,\n            1.0,  1.0, -1.0,\n            1.0,  1.0,  1.0,\n            1.0,  1.0,  1.0,\n            -1.0,  1.0,  1.0,\n            -1.0,  1.0, -1.0,\n\n            -1.0, -1.0, -1.0,\n            -1.0, -1.0,  1.0,\n            1.0, -1.0, -1.0,\n            1.0, -1.0, -1.0,\n            -1.0, -1.0,  1.0,\n            1.0, -1.0,  1.0]);\n    const vao = gl.createVertexArray();\n    const buffer = gl.createBuffer();\n    gl.bindVertexArray(vao);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']);\n    gl.vertexAttribPointer(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION'], 3, gl.FLOAT, gl.FALSE, 0, 0);\n    gl.bindVertexArray(null);\n\n    //shaders\n    const VERTEX_ATTRIB_POSITION = 0;\n    var vs_src = `#version 300 es\n    layout( location = `+VERTEX_ATTRIB_POSITION+` ) in vec3 position;\n\n    uniform mat4 perspective;\n    uniform mat4 view;\n\n    out vec3 v_normal;\n\n    \n    void main(){\n        vec4 pos = perspective*view*vec4(position*vec3(100), 1.0);\n        gl_Position = pos.xyzw;\n        v_normal = position;\n    }\n    `;\n    var fs_src = `#version 300 es\n    precision mediump float;\n \n    in vec3 v_normal;\n    out vec4 color;\n     \n    uniform samplerCube env_map;\n    uniform samplerCube diffuse_map;\n    uniform samplerCube prefilter_map;\n    uniform sampler2D brdflut_map;\n     \n    void main() {\n       color = texture(env_map, v_normal);\n    }\n    `;\n    var vs = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vs,vs_src);\n    gl.compileShader(vs);\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n        console.log(gl.getShaderInfoLog(vs));\n        gl.deleteShader(vs);\n    }\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fs,fs_src);\n    gl.compileShader(fs);\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n        console.log(gl.getShaderInfoLog(fs));\n        gl.deleteShader(fs);\n    }\n    var program = gl.createProgram();\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\n        console.log(gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n    }\n\n    //SET CUBE MAP IMAGE DATA\n    var diffuse;\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);\n    /*const faces = [\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, src: 'assets/env_map/environment_right_0.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, src: 'assets/env_map/environment_left_0.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, src: 'assets/env_map/environment_top_0.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, src: 'assets/env_map/environment_bottom_0.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, src: 'assets/env_map/environment_front_0.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, src: 'assets/env_map/environment_back_0.jpg' },\n    ];*/\n\n    /*const faces = [\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, src: 'assets/env_map/px.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, src: 'assets/env_map/nx.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, src: 'assets/env_map/py.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, src: 'assets/env_map/ny.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, src: 'assets/env_map/pz.jpg' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, src: 'assets/env_map/nz.jpg' },\n    ];*/\n\n    const faces = [\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, src: 'assets/env_map/px.hdr' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, src: 'assets/env_map/nx.hdr' },\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, src: 'assets/env_map/py.hdr' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, src: 'assets/env_map/ny.hdr' },\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, src: 'assets/env_map/pz.hdr' },\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, src: 'assets/env_map/nz.hdr' },\n    ];\n\n    var images = [];\n    var env_map_obj = {\n        onload: null,\n        vao: vao,\n        vert_buffer: buffer,\n        texture: texture,\n        diffuse: diffuse,\n        program: program,\n        texture_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['env_map']),\n        diffuse_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['diffuse_map']), // only if want to view diffuse in cube map\n        prefilter_loc: gl.getUniformLocation(program, 'prefilter_map'),\n        brdflut_loc: gl.getUniformLocation(program, 'brdflut_map'),\n        perspective_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['perspective']),\n        view_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['view']),\n        render: function(gl, camera){\n            gl.bindVertexArray(this.vao);\n            gl.useProgram(this.program);\n\n            //bind environment map\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP,this.texture);\n            gl.uniform1i(this.texture_loc, 0);\n\n            //bind diffuse map ONLY IF WANT TO VIEW DIFFUSE IINSTEAD OF ENV MAP\n            /*gl.activeTexture(gl.TEXTURE1);\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.diffuse);\n            gl.uniform1i(this.diffuse_loc, 1);\n\n            //bind prefilter map ONLY IF WANT TO VIEW PREFILTER INSTEAD\n            gl.activeTexture(gl.TEXTURE2);\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.prefilter);\n            gl.uniform1i(this.prefilter_loc, 2);\n\n            //bind brdflut map\n            gl.activeTexture(gl.TEXTURE3);\n            gl.bindTexture(gl.TEXTURE_2D, this.brdflut);\n            gl.uniform1i(this.brdflut_loc, 3);*/\n\n            //set camera data\n            camera.set_perspective_uniform(gl, this.perspective_loc);\n            camera.set_view_uniform(gl, this.view_loc);\n\n            //draw cube map\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\n            gl.bindVertexArray(null);\n        },\n        set_texture_uniform: function(gl, active_texture_index, texture_uniform_location){\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);\n            gl.uniform1i(texture_uniform_location, active_texture_index);\n        },\n        set_diffuse_uniform: function(gl, active_texture_index, texture_uniform_location){\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.diffuse);\n            gl.uniform1i(texture_uniform_location, active_texture_index);\n        },\n        set_prefilter_uniform: function(gl, active_texture_index, texture_uniform_location){\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.prefilter);\n            gl.uniform1i(texture_uniform_location, active_texture_index);\n        },\n        set_brdflut_uniform: function(gl, active_texture_index, texture_uniform_location){\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\n            gl.bindTexture(gl.TEXTURE_2D, this.brdflut);\n            gl.uniform1i(texture_uniform_location, active_texture_index);\n        },\n    } \n    var onload_promise = new Promise((resolve)=>{\n        faces.forEach((face)=>{\n            const {target , src} = face;\n            //var image = new Image();\n            var image = new HDRImage();\n            image.onload = function(){ \n                //document.body.append(image);\n                images.push({'image':image, 'target':target});\n                //if all images are loaded load environmental map\n                if(images.length >= faces.length){\n                    //set texture data\n                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);\n                    for(var i=0; i<images.length; i++){\n                        gl.texImage2D(\n                            images[i].target,\n                            0,\n                            gl.RGBA,\n                            gl.RGBA,\n                            gl.UNSIGNED_BYTE,\n                            images[i].image\n                        );       \n                    }\n                    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);\n\n                    //generate indirect ibl\n                    env_map_obj.diffuse = irradiance_gen(gl, texture, vao);\n                    env_map_obj.prefilter = prefilter_gen(gl, texture, vao);\n                    env_map_obj.brdflut = brdflut_gen(gl, env_map);\n                    resolve(images);\n                }\n            }\n            image.src = src;\n        });\n    });   \n\n\n    env_map_obj.onload = onload_promise;\n    gltf._loads.push(env_map_obj.onload);\n    gltf._environment = env_map_obj;\n}\n\n//generate irradiance map from environment cube map WebglTexture\nfunction irradiance_gen(gl, env_map_texture, cube_vao) {\n    //set shaders\n    var vs_src = `#version 300 es\n    layout( location = `+_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']+` ) in vec3 position;\n\n    uniform mat4 perspective;\n    uniform mat4 view;\n\n    out vec3 v_normal;\n\n    \n    void main(){\n        vec4 pos = perspective*view*vec4(position, 1.0);\n        gl_Position = pos.xyzw;\n        v_normal = position;\n    }`;\n    var fs_src = `#version 300 es\n    precision mediump float;\n \n    in vec3 v_normal;\n    out vec4 color;\n    \n    const float PI = 3.14159265359;\n     \n    uniform samplerCube env_map;\n     \n    void main() {\n        vec3 normal = normalize(v_normal);\n\n        vec3 irradiance = vec3(0.0);\n\n        vec3 up    = vec3(0.0, 1.0, 0.0);\n        vec3 right = cross(up, normal);\n        up         = cross(normal, right);\n\n        float sampleDelta = 0.025;\n        float nrSamples = 0.0; \n        for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\n        {\n            for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\n            {\n                // spherical to cartesian (in tangent space)\n                vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n                // tangent space to world\n                vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \n\n                irradiance += texture(env_map, sampleVec).rgb * cos(theta) * sin(theta);\n                nrSamples++;\n            }\n        }\n        irradiance = PI * irradiance * (1.0 / float(nrSamples));\n        \n        color = vec4(irradiance, 1.0);\n    }\n    `;\n\n    //create convolution shader program\n    var vs = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vs, vs_src);\n    gl.compileShader(vs);\n    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\n        console.log(gl.getShaderInfoLog(vs));\n        gl.deleteShader(vs);\n    }\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fs, fs_src);\n    gl.compileShader(fs);\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\n        console.log(gl.getShaderInfoLog(fs));\n        gl.deleteShader(fs);\n    }\n    var program = gl.createProgram();\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\n        console.log(gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n    }\n\n    //set program locations\n    var texture_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['env_map']);\n    var perspective_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['perspective']);\n    var view_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['view']);\n\n    //initialize irradiance cube map data\n    var irradiance_cube_map_texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, irradiance_cube_map_texture);\n    for(var i = 0; i < 6; i++){\n        gl.texImage2D(\n            gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,0, gl.RGBA, 1, 1, 0, gl.RGBA,\n              gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255,0, 255, 0, 255,0, 0, 255, 255])\n            );    \n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n    //init render and framebuffer\n    var fbo  = gl.createFramebuffer();\n    var rbo = gl.createRenderbuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    \n    //set perspective and view data\n    var projection = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(),Object(_includes_common_js__WEBPACK_IMPORTED_MODULE_2__[\"toRadian\"])(90), 1.0, 0.1, 10.0);\n    var view = [\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(-1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0,  1.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0, -1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0, -1.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0,  1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0, -1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0))\n         ];\n\n    //generate irradiance map texture\n    gl.bindVertexArray(cube_vao); //bind cube vertex data\n    gl.useProgram(program);\n\n    //bind environment cube map\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP,env_map_texture);\n    gl.uniform1i(texture_loc, 0);\n\n    //set perspective uniform\n    gl.uniformMatrix4fv(perspective_loc, gl.FALSE, projection); \n    \n    gl.viewport(0, 0, 32, 32);\n    for(var i = 0; i < 6; i++){\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        //render cubemap to texture\n        gl.uniformMatrix4fv(view_loc, gl.FALSE, view[i]);//set view uniform\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, \n                                gl.COLOR_ATTACHMENT0, \n                                gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n                                irradiance_cube_map_texture, \n                                0);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(fbo);\n    return irradiance_cube_map_texture;\n}\n\nfunction prefilter_gen(gl, env_map, cube_vao){\n    //initialize prefilter map\n    var prefilter_map = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, prefilter_map);\n    for(var i = 0; i < 6; i++){\n        gl.texImage2D(\n            gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,0, gl.RGBA, 128, 128, 0, gl.RGBA,\n            gl.UNSIGNED_BYTE, null\n        );      \n    }\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n\n    //initialize prefilter shader program\n    var vs_src = `#version 300 es\n    layout( location = `+_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']+` ) in vec3 position;\n\n    uniform mat4 perspective;\n    uniform mat4 view;\n\n    out vec3 v_normal;\n    \n    void main(){\n        vec4 pos = perspective*view*vec4(position, 1.0);\n        gl_Position = pos.xyzw;\n        v_normal = position;\n    }`;\n    var fs_src = `#version 300 es\n    precision mediump float;\n    \n    const float PI = 3.14159265359;\n\n    in vec3 v_normal;\n    out vec4 color;\n\n    float VanDerCorpus(uint n, uint base)\n    {\n        float invBase = 1.0 / float(base);\n        float denom   = 1.0;\n        float result  = 0.0;\n\n        for(uint i = 0u; i < 32u; ++i)\n        {\n            if(n > 0u)\n            {\n                denom   = mod(float(n), 2.0);\n                result += denom * invBase;\n                invBase = invBase / 2.0;\n                n       = uint(float(n) / 2.0);\n            }\n        }\n\n        return result;\n    }\n    vec2 Hammersley(uint i, uint N)\n    {\n        return vec2(float(i)/float(N), VanDerCorpus(i, 2u));\n    }\n\n    vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n    {\n        float a = roughness*roughness;\n        \n        float phi = 2.0 * PI * Xi.x;\n        float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        // from spherical coordinates to cartesian coordinates\n        vec3 H;\n        H.x = cos(phi) * sinTheta;\n        H.y = sin(phi) * sinTheta;\n        H.z = cosTheta;\n        \n        // from tangent-space vector to world-space sample vector\n        vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n        vec3 tangent   = normalize(cross(up, N));\n        vec3 bitangent = cross(N, tangent);\n        \n        vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n        return normalize(sampleVec);\n    }  \n\n     \n    uniform samplerCube env_map;\n    uniform float roughness;  \n\n    void main() {        \n        vec3 N = normalize(v_normal);    \n        vec3 R = N;\n        vec3 V = R;\n\n        const uint SAMPLE_COUNT = 1024u;\n        float totalWeight = 0.0;   \n        vec3 prefilteredColor = vec3(0.0);     \n        for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n        {\n            vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n            vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n            vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n            float NdotL = max(dot(N, L), 0.0);\n            if(NdotL > 0.0)\n            {\n                prefilteredColor += texture(env_map, L).rgb * NdotL;\n                totalWeight      += NdotL;\n            }\n        }\n        prefilteredColor = prefilteredColor / totalWeight;\n\n        color = vec4(prefilteredColor, 1.0);\n    }\n    `;\n    var vs = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vs, vs_src);\n    gl.compileShader(vs);\n    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\n        console.log(gl.getShaderInfoLog(vs));\n        gl.deleteShader(vs);\n    }\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fs, fs_src);\n    gl.compileShader(fs);\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\n        console.log(gl.getShaderInfoLog(fs));\n        gl.deleteShader(fs);\n    }\n    var program = gl.createProgram();\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\n        console.log(gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n    }\n\n    //set program locations\n    var env_map_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['env_map']);\n    var roughness_loc = gl.getUniformLocation(program, 'roughness');\n    var perspective_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['perspective']);\n    var view_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['view']);\n\n    //set camera view data\n    var views = [\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(-1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0,  1.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0, -1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0, -1.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0,  1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0, -1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0))\n    ];\n\n    //init frame buffer\n    var fbo = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n    //run prefilter\n    gl.bindVertexArray(cube_vao);\n    gl.useProgram(program);\n\n    //set envirnomental map texture\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP,env_map);\n    gl.uniform1i(env_map_loc, 0);\n\n    //set perspective\n    gl.uniformMatrix4fv(perspective_loc,gl.FALSE, _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(),Object(_includes_common_js__WEBPACK_IMPORTED_MODULE_2__[\"toRadian\"])(90), 1.0, 0.1, 10.0));\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    var mip_levels = 10;\n    for(var mip = 0; mip<mip_levels; ++mip){\n        //set viewport dimensions\n        var width = 128*Math.pow(0.5, mip);\n        var height = 128 * Math.pow(0.5, mip);\n        gl.viewport(0, 0, width, height);\n\n        //set roughness uniform\n        var roughness = mip/(mip_levels - 1);\n        gl.uniform1f(roughness_loc, roughness);\n\n        for(var i = 0; i<6; ++i){\n            //set view\n            gl.uniformMatrix4fv(view_loc, gl.FALSE, views[i]);\n\n            //render to texture\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,prefilter_map,mip);\n            gl.clear(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT);\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\n        }\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(fbo);\n\n    return prefilter_map;\n}\n\nfunction brdflut_gen(gl, env_map){\n\n    const vao = gl.createVertexArray();\n    /*const buffer = gl.createBuffer();\n    gl.bindVertexArray(vao);\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(layout['POSITION']);\n    gl.vertexAttribPointer(layout['POSITION'], 3, gl.FLOAT, gl.FALSE, 0, 0);\n*/\n    \n    //initialize program\n    var vs_src = `#version 300 es\n    layout( location = `+_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']+` ) in vec3 position;\n\n    out vec2 v_position;\n    \n    void main(){\n        float x = float(((uint(gl_VertexID) + 2u) / 3u)%2u); \n        float y = float(((uint(gl_VertexID) + 1u) / 3u)%2u); \n\n        gl_Position = vec4(-1.0f + x*2.0f, -1.0f+y*2.0f, 0.0f, 1.0f);\n        v_position = vec2(x, y);\n    }`;\n    var fs_src = `#version 300 es\n    precision mediump float;\n\n    in vec2 v_position;\n    out vec4 color;\n\n    const float PI = 3.14159265359;\n\n\n    float VanDerCorpus(uint n, uint base)\n    {\n        float invBase = 1.0 / float(base);\n        float denom   = 1.0;\n        float result  = 0.0;\n\n        for(uint i = 0u; i < 32u; ++i)\n        {\n            if(n > 0u)\n            {\n                denom   = mod(float(n), 2.0);\n                result += denom * invBase;\n                invBase = invBase / 2.0;\n                n       = uint(float(n) / 2.0);\n            }\n        }\n\n        return result;\n    }\n    vec2 Hammersley(uint i, uint N)\n    {\n        return vec2(float(i)/float(N), VanDerCorpus(i, 2u));\n    }\n\n    vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n    {\n        float a = roughness*roughness;\n        \n        float phi = 2.0 * PI * Xi.x;\n        float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        // from spherical coordinates to cartesian coordinates\n        vec3 H;\n        H.x = cos(phi) * sinTheta;\n        H.y = sin(phi) * sinTheta;\n        H.z = cosTheta;\n        \n        // from tangent-space vector to world-space sample vector\n        vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n        vec3 tangent   = normalize(cross(up, N));\n        vec3 bitangent = cross(N, tangent);\n        \n        vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n        return normalize(sampleVec);\n    }  \n\n    float GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float a = roughness;\n    float k = (a * a) / 2.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n} \n    vec2 IntegrateBRDF(float NdotV, float roughness)\n{\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n\n    const uint SAMPLE_COUNT = 1024u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0)\n        {\n            float G = GeometrySmith(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n// ----------------------------------------------------------------------------\nvoid main() \n{\n    vec2 integratedBRDF = IntegrateBRDF(v_position.x, v_position.y);\n    color = vec4(integratedBRDF, 0.0, 1.0);\n}`;\n    var vs = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vs, vs_src);\n    gl.compileShader(vs);\n    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\n        console.log(gl.getShaderInfoLog(vs));\n        gl.deleteShader(vs);\n    }\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fs, fs_src);\n    gl.compileShader(fs);\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\n        console.log(gl.getShaderInfoLog(fs));\n        gl.deleteShader(fs);\n    }\n    var program = gl.createProgram();\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\n        console.log(gl.getProgramInfoLog(program));\n        gl.deleteProgram(program);\n    }\n\n    var fbo = gl.createFramebuffer();\n    var rbo = gl.createRenderbuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    /*gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT24, 512, 512);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rbo);*/\n    \n    //initialize brdflut texture\n    var brdflut = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, brdflut);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 512, 512, 0, gl.RGB, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, brdflut, 0);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n    //render brdf lut to texture\n    gl.viewport(0, 0, 512, 512);\n\n    gl.bindVertexArray(vao);\n    gl.useProgram(program);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n\n\n    gl.bindVertexArray(null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    return brdflut;\n\n}\n\n\n\n//# sourceURL=webpack:///./src/gltf_loader.js?");

/***/ }),

/***/ "./src/includes/common.js":
/*!********************************!*\
  !*** ./src/includes/common.js ***!
  \********************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EPSILON\", function() { return EPSILON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ARRAY_TYPE\", function() { return ARRAY_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RANDOM\", function() { return RANDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setMatrixArrayType\", function() { return setMatrixArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRadian\", function() { return toRadian; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nconst EPSILON = 0.000001;\nlet ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\nconst RANDOM = Math.random;\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\n\nconst degree = Math.PI / 180;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nfunction toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\nif (!Math.hypot) Math.hypot = function() {\n  var y = 0, i = arguments.length;\n  while (i--) y += arguments[i] * arguments[i];\n  return Math.sqrt(y);\n};\n\n\n//# sourceURL=webpack:///./src/includes/common.js?");

/***/ }),

/***/ "./src/includes/hdrpng.js":
/*!********************************!*\
  !*** ./src/includes/hdrpng.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * hdrpng.js - support for Radiance .HDR and RGBE / RGB9_E5 images in PNG.\n * @author Enki\n * @desc load/save Radiance .HDR, RGBE in PNG and RGB9_E5 in PNG for HTML5, webGL, webGL2.\n */\n(function (name, context, definition) {\n  if ( true && module.exports) module.exports = definition();\n  else if (true) __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")(name, definition);\n  else {}\n}('HDRImage', this, function () {\n  /**\n   * HDRImage - wrapper that exposes default Image like interface for HDR imgaes. (till extending HTMLCanvasElement actually works ..)\n   * @returns {HDRImage} a html HDR image element\n   */\n  function HDRImage() {\n    var res = document.createElement('canvas'), HDRsrc='t',HDRexposure=1.0,HDRgamma=2.2,HDRdata=null,context,HDRD;\n    res.__defineGetter__('exposure',function(){return HDRexposure});\n    res.__defineSetter__('exposure',function(val){ HDRexposure=val; if (HDRdata) { rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data); context.putImageData(HDRD,0,0); }});\n    res.__defineGetter__('gamma',function(){return HDRgamma});\n    res.__defineSetter__('gamma',function(val){ HDRgamma=val; if (HDRdata) { rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data); context.putImageData(HDRD,0,0); }});\n    res.__defineGetter__('dataFloat',function(){ return rgbeToFloat(HDRdata); });\n    res.__defineGetter__('dataRGBE',function(){ return HDRdata; });\n    res.toHDRBlob = function(cb,m,q) {\n      // Array to image.. slightly more involved.  \n        function createShader(gl, source, type) {\n            var shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            return shader;\n        }\n        function createProgram(gl, vertexShaderSource, fragmentShaderSource) {\n            var program = gl.createProgram(),vs,fs;\n            gl.attachShader(program, vs=createShader(gl, vertexShaderSource, gl.VERTEX_SHADER));\n            gl.attachShader(program, fs=createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER));\n            gl.linkProgram(program); gl.deleteShader(vs); gl.deleteShader(fs);\n            return program;\n        };\n        var ar = (m && m.match(/rgb9_e5/i)) ? new Uint8Array( floatToRgb9_e5(rgbeToFloat(HDRdata)).buffer ) : new Uint8Array(HDRdata.buffer);\n        var vs2='precision highp float;\\nattribute vec3 position;\\nvarying vec2 tex;\\nvoid main() { tex = position.xy/2.0+0.5; gl_Position = vec4(position, 1.0); }';\n        var fs2='precision highp float;\\nprecision highp sampler2D;\\nuniform sampler2D tx;\\nvarying vec2 tex;\\nvoid main() { gl_FragColor = texture2D(tx,tex); }';\n        var x = this.width, y = this.height;\n        if (x*y*4 < ar.byteLength) return console.error('not big enough.');\n        var c = document.createElement('canvas');\n        c.width=x; c.height=y;\n        var gl = c.getContext('webgl',{antialias:false,alpha:true,premultipliedAlpha:false,preserveDrawingBuffer:true});\n\n        var texture = gl.createTexture();\n        gl.activeTexture(gl.TEXTURE0);  gl.bindTexture(gl.TEXTURE_2D, texture);  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, x, y, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(ar.buffer));\n\n        var program = createProgram(gl, vs2, fs2), uniformTexLocation = gl.getUniformLocation(program, 'tx');\n\n        var positions = new Float32Array([-1, -1, 0, 1, -1, 0, 1,  1, 0, 1,  1, 0, -1,  1, 0, -1, -1, 0 ]), vertexPosBuffer=gl.createBuffer();\n        gl.enableVertexAttribArray(0);\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);\n\n        gl.useProgram(program);\n        gl.uniform1i(uniformTexLocation, 0);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        \n        gl.deleteTexture(texture);\n        gl.deleteProgram(program);\n\n        if (cb) return c.toBlob(cb); \n    }\n    res.__defineGetter__('src',function(){return HDRsrc});\n    res.__defineSetter__('src',function(val){\n      HDRsrc=val;\n      context&&context.clearRect(0,0,this.width,this.height);\n      if (val.match(/\\.hdr$/i)) loadHDR(val,function(img,width,height){\n        HDRdata = img;\n        this.width  = this.style.width  = width;\n        this.height = this.style.height = height;\n        context = this.getContext('2d');\n        HDRD = context.getImageData(0,0,width,height);\n        rgbeToLDR(img,HDRexposure,HDRgamma,HDRD.data);\n        context.putImageData(HDRD,0,0);\n        this.onload&&this.onload(); \n      }.bind(res));\n      else if (val.match(/\\.rgb9_e5\\.png$/i)) {\n        var i = new Image();\n        i.src = val;\n        i.onload = function() {\n          var c = document.createElement('canvas'), x=this.width=this.style.width=c.width=i.width, y=this.height=this.style.height=c.height=i.height, gl=c.getContext('webgl');\n\n          var texture = gl.createTexture();\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);\n           \n          fb = gl.createFramebuffer();\n          gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n          gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n          var res = new Uint8Array(x*y*4);\n          gl.readPixels(0,0,x,y,gl.RGBA,gl.UNSIGNED_BYTE,res);\n\n          gl.deleteTexture(texture);\n          gl.deleteFramebuffer(fb);\n          \n          this.dataRAW = new Uint32Array(res.buffer);\n          HDRdata = floatToRgbe(rgb9_e5ToFloat(this.dataRAW));\n          context = this.getContext('2d');\n          HDRD = context.getImageData(0,0,x,y);\n          rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data);\n          context.putImageData(HDRD,0,0);\n          this.onload&&this.onload(); \n        }.bind(res);\n      } else if (val.match(/\\.hdr\\.png$|\\.rgbe\\.png/i)) {\n        var i = new Image();\n        i.src = val;\n        i.onload = function() {\n          var c = document.createElement('canvas'), x=this.width=this.style.width=c.width=i.width, y=this.height=this.style.height=c.height=i.height, gl=c.getContext('webgl');\n\n          var texture = gl.createTexture();\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);\n           \n          fb = gl.createFramebuffer();\n          gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n          gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n          var res = new Uint8Array(x*y*4);\n          gl.readPixels(0,0,x,y,gl.RGBA,gl.UNSIGNED_BYTE,res);\n\n          gl.deleteTexture(texture);\n          gl.deleteFramebuffer(fb);\n          \n          HDRdata = res;\n          context = this.getContext('2d');\n          HDRD = context.getImageData(0,0,x,y);\n          rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data);\n          context.putImageData(HDRD,0,0);\n          this.onload&&this.onload(); \n        }.bind(res);\n      }\n    });\n    return res;\n  }  \n  \n  function m(a,b) { for (var i in b) a[i]=b[i]; return a; };\n    \n  /** Load and parse a Radiance .HDR file. It completes with a 32bit RGBE buffer.\n    * @param {URL} url location of .HDR file to load.\n    * @param {function} completion completion callback.\n    * @returns {XMLHttpRequest} the XMLHttpRequest used to download the file.\n    */\n  function loadHDR( url, completion ) {\n    var req = m(new XMLHttpRequest(),{responseType:\"arraybuffer\"});\n    req.onerror = completion.bind(req,false);\n    req.onload  = function() {\n      if (this.status>=400) return this.onerror();\n      var header='',pos=0,d8=new Uint8Array(this.response),format;\n    // read header.  \n      while (!header.match(/\\n\\n[^\\n]+\\n/g)) header += String.fromCharCode(d8[pos++]);\n    // check format. \n      format = header.match(/FORMAT=(.*)$/m)[1];\n      if (format!='32-bit_rle_rgbe') return console.warn('unknown format : '+format),this.onerror();\n    // parse resolution\n      var rez=header.split(/\\n/).reverse()[1].split(' '), width=rez[3]*1, height=rez[1]*1;\n    // Create image.\n      var img=new Uint8Array(width*height*4),ipos=0;\n    // Read all scanlines\n      for (var j=0; j<height; j++) {\n        var rgbe=d8.slice(pos,pos+=4),scanline=[];\n        if ((rgbe[0]!=2)||(rgbe[1]!=2)||(rgbe[2]&0x80)) return console.warn('HDR parse error ..'),this.onerror();\n        if ((rgbe[2]<<8)+rgbe[3]!=width) return console.warn('HDR line mismatch ..'),this.onerror();\n        for (var i=0;i<4;i++) {\n            var ptr=i*width,ptr_end=(i+1)*width,buf,count;\n            while (ptr<ptr_end){\n                buf = d8.slice(pos,pos+=2);\n                if (buf[0] > 128) { count = buf[0]-128; while(count-- > 0) scanline[ptr++] = buf[1]; } \n                             else { count = buf[0]-1; scanline[ptr++]=buf[1]; while(count-->0) scanline[ptr++]=d8[pos++]; }\n            }\n        }\n        for (var i=0;i<width;i++) { img[ipos++]=scanline[i]; img[ipos++]=scanline[i+width]; img[ipos++]=scanline[i+2*width]; img[ipos++]=scanline[i+3*width]; }\n      }\n      completion&&completion(img,width,height);\n    }\n    req.open(\"GET\",url,true);\n    req.send(null);\n    return req;\n  }\n\n  /** Convert a float buffer to a RGB9_E5 buffer. (ref https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_shared_exponent.txt)\n    * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).\n    * @param {Uint32Array} [res] Optional output buffer with 32 bit RGB9_E5 per pixel.\n    * @returns {Uint32Array} A 32bit uint32 array in RGB9_E5\n    */\n  function floatToRgb9_e5(buffer,res) {\n    var r,g,b,v,maxColor,ExpShared,denom,s,l=(buffer.byteLength/12)|0, res=res||new Uint32Array(l);\n    for (var i=0;i<l;i++) {\n      r=Math.min(32768.0,buffer[i*3]); g=Math.min(32768.0,buffer[i*3+1]); b=Math.min(32768.0,buffer[i*3+2]);\n      maxColor = Math.max(Math.max(r,g),b);\n      ExpShared = Math.max(-16,Math.floor(Math.log2(maxColor))) + 16;\n      denom = Math.pow(2,ExpShared-24);\n      if (Math.floor(maxColor/denom+0.5) == 511) { denom *= 2; ExpShared += 1; }\n      res[i] = (Math.floor(r/denom+0.5)<<23)+(Math.floor(g/denom+0.5)<<14)+(Math.floor(b/denom+0.5)<<5)+ (ExpShared|0);\n    }\n    return res;\n  }\n\n  /** Convert an RGB9_E5 buffer to a Float buffer.\n    * @param {Uint32Array} Buffer in RGB9_E5 format. (Uint32 buffer).\n    * @param {Float32Array} [res] Optional float output buffer.\n    * @returns {Float32Array} A Float32Array.\n    */\n  function rgb9_e5ToFloat(buffer,res) {\n    var v,s,l=buffer.byteLength>>2, res=res||new Float32Array(l*3);\n    for (var i=0;i<l;i++) {\n      v = buffer[i]; s = Math.pow(2,(v&31)-24);\n      res[i*3]   =  (v>>>23)*s;\n      res[i*3+1] = ((v>>>14)&511)*s;\n      res[i*3+2] = ((v>>>5)&511)*s;\n    }\n    return res;\n  }\n\n  /** Convert a float buffer to a RGBE buffer.\n    * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).\n    * @param {Uint8Array} [res] Optional output buffer with 32 bit RGBE per pixel.\n    * @returns {Uint8Array} A 32bit uint8 array in RGBE\n    */\n  function floatToRgbe(buffer,res) {\n    var r,g,b,v,s,l=(buffer.byteLength/12)|0, res=res||new Uint8Array(l*4);\n    for (var i=0;i<l;i++) {\n      r = buffer[i*3]; g = buffer[i*3+1]; b = buffer[i*3+2];\n      v = Math.max(Math.max(r,g),b); e = Math.ceil(Math.log2(v)); s = Math.pow(2,e-8);\n      res[i*4]   = (r/s)|0;\n      res[i*4+1] = (g/s)|0;\n      res[i*4+2] = (b/s)|0;\n      res[i*4+3] = (e+128);\n    }\n    return res;\n  }\n  \n  /** Convert an RGBE buffer to a Float buffer.\n    * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)\n    * @param {Float32Array} [res] Optional result buffer containing 3 floats per pixel.\n    * @returns {Float32Array} A floating point buffer with 96 bits per pixel (32 per channel, 3 channels).\n    */\n  function rgbeToFloat(buffer,res) {\n    var s,l=buffer.byteLength>>2, res=res||new Float32Array(l*3);\n    for (var i=0;i<l;i++) {\n      s = Math.pow(2,buffer[i*4+3]-(128+8));\n      res[i*3]=buffer[i*4]*s;\n      res[i*3+1]=buffer[i*4+1]*s;\n      res[i*3+2]=buffer[i*4+2]*s;\n    }\n    return res;\n  }\n  \n  /** Convert an RGBE buffer to LDR with given exposure and display gamma.\n    * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)\n    * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)\n    * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)\n    * @param {Array} [res] res Optional result buffer.\n    */\n  function rgbeToLDR(buffer,exposure,gamma,res) {\n    exposure = Math.pow(2,exposure===undefined?1:exposure)/2;\n    if (gamma===undefined) gamma = 2.2;\n    var one_over_gamma=1/gamma,s,l=buffer.byteLength>>2, res=res||new Uint8ClampedArray(l*4);\n    for (var i=0;i<l;i++) {\n      s = exposure * Math.pow(2,buffer[i*4+3]-(128+8));\n      res[i*4]  =255*Math.pow(buffer[i*4]*s,one_over_gamma);\n      res[i*4+1]=255*Math.pow(buffer[i*4+1]*s,one_over_gamma);\n      res[i*4+2]=255*Math.pow(buffer[i*4+2]*s,one_over_gamma);\n      res[i*4+3]=255;\n    }\n    return res;\n  }\n\n  /** Convert an float buffer to LDR with given exposure and display gamma.\n    * @param {Float32Array} buffer The input buffer in floating point format. \n    * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)\n    * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)\n    * @param {Array} [res] res Optional result buffer.\n    */\n  function floatToLDR(buffer,exposure,gamma,res) {\n    exposure = Math.pow(2,exposure===undefined?1:exposure)/2;\n    if (gamma===undefined) gamma = 2.2;\n    var one_over_gamma=1/gamma,s,l=(buffer.byteLength/12)|0, res=res||new Uint8ClampedArray(l*4);\n    for (var i=0;i<l;i++) {\n      res[i*4]  =255*Math.pow(buffer[i*3]*exposure,one_over_gamma);\n      res[i*4+1]=255*Math.pow(buffer[i*3+1]*exposure,one_over_gamma);\n      res[i*4+2]=255*Math.pow(buffer[i*3+2]*exposure,one_over_gamma);\n      res[i*4+3]=255;\n    }\n    return res;\n  }\n  \n  \n  // Float/RGBE conversions.\n  HDRImage.floatToRgbe = floatToRgbe;\n  HDRImage.rgbeToFloat = rgbeToFloat;\n\n  // Float/RGB9_E5 conversions.\n  HDRImage.floatToRgb9_e5 = floatToRgb9_e5;\n  HDRImage.rgb9_e5ToFloat = rgb9_e5ToFloat; \n\n  // x to LDR conversion.\n  HDRImage.rgbeToLDR   = rgbeToLDR;\n  HDRImage.floatToLDR  = floatToLDR;\n  \n  \n  return HDRImage;\n}));\n\n\n//# sourceURL=webpack:///./src/includes/hdrpng.js?");

/***/ }),

/***/ "./src/includes/index.js":
/*!*******************************!*\
  !*** ./src/includes/index.js ***!
  \*******************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"glMatrix\", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ \"./src/includes/mat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2\", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ \"./src/includes/mat2d.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2d\", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ \"./src/includes/mat3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat3\", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ \"./src/includes/mat4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat4\", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ \"./src/includes/quat.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat\", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });\n/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ \"./src/includes/quat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat2\", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });\n/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ \"./src/includes/vec2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec2\", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ \"./src/includes/vec3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec3\", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ \"./src/includes/vec4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec4\", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/includes/index.js?");

/***/ }),

/***/ "./src/includes/mat2.js":
/*!******************************!*\
  !*** ./src/includes/mat2.js ***!
  \******************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LDU\", function() { return LDU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {mat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\nfunction fromValues(m00, m01, m10, m11) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\nfunction set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    let a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction invert(out, a) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n\n  // Calculate the determinant\n  let det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] =  a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] =  a0 * det;\n\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  let a0 = a[0];\n  out[0] =  a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] =  a0;\n\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {mat2} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction multiply(out, a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nfunction rotate(out, a, rad) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  out[0] = a0 *  c + a2 * s;\n  out[1] = a1 *  c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nfunction scale(out, a, v) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let v0 = v[0], v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nfunction fromRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {mat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {mat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[2],a[3]))\n}\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {mat2} L the lower triangular matrix\n * @param {mat2} D the diagonal matrix\n * @param {mat2} U the upper triangular matrix\n * @param {mat2} a the input matrix to factorize\n */\n\nfunction LDU(L, D, U, a) {\n  L[2] = a[2]/a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  return out;\n}\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat2.js?");

/***/ }),

/***/ "./src/includes/mat2d.js":
/*!*******************************!*\
  !*** ./src/includes/mat2d.js ***!
  \*******************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 2x3 Matrix\n * @module mat2d\n *\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, b, c,\n *  d, tx, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, b, 0,\n *  c, d, 0,\n *  tx, ty, 1]\n * </pre>\n * The last column is ignored so the array is shorter and operations are faster.\n */\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {mat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\nfunction fromValues(a, b, c, d, tx, ty) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\nfunction set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nfunction invert(out, a) {\n  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];\n  let atx = a[4], aty = a[5];\n\n  let det = aa * ad - ab * ac;\n  if(!det){\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {mat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction multiply(out, a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nfunction rotate(out, a, rad) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  out[0] = a0 *  c + a2 * s;\n  out[1] = a1 *  c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nfunction scale(out, a, v) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let v0 = v[0], v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nfunction translate(out, a, v) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let v0 = v[0], v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nfunction fromRotation(out, rad) {\n  let s = Math.sin(rad), c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2d} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat2d} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {mat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +\n          a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {mat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[2],a[3],a[4],a[5],1))\n}\n\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  out[4] = a[4] + (b[4] * scale);\n  out[5] = a[5] + (b[5] * scale);\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n          Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n          Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));\n}\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat2d.js?");

/***/ }),

/***/ "./src/includes/mat3.js":
/*!******************************!*\
  !*** ./src/includes/mat3.js ***!
  \******************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat2d\", function() { return fromMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalFromMat4\", function() { return normalFromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projection\", function() { return projection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1], a02 = a[2], a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction invert(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  let b01 = a22 * a11 - a12 * a21;\n  let b11 = -a22 * a10 + a12 * a20;\n  let b21 = a21 * a10 - a11 * a20;\n\n  // Calculate the determinant\n  let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction adjoint(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  out[0] = (a11 * a22 - a12 * a21);\n  out[1] = (a02 * a21 - a01 * a22);\n  out[2] = (a01 * a12 - a02 * a11);\n  out[3] = (a12 * a20 - a10 * a22);\n  out[4] = (a00 * a22 - a02 * a20);\n  out[5] = (a02 * a10 - a00 * a12);\n  out[6] = (a10 * a21 - a11 * a20);\n  out[7] = (a01 * a20 - a00 * a21);\n  out[8] = (a00 * a11 - a01 * a10);\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction multiply(out, a, b) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  let b00 = b[0], b01 = b[1], b02 = b[2];\n  let b10 = b[3], b11 = b[4], b12 = b[5];\n  let b20 = b[6], b21 = b[7], b22 = b[8];\n\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nfunction translate(out, a, v) {\n  let a00 = a[0], a01 = a[1], a02 = a[2],\n    a10 = a[3], a11 = a[4], a12 = a[5],\n    a20 = a[6], a21 = a[7], a22 = a[8],\n    x = v[0], y = v[1];\n\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nfunction rotate(out, a, rad) {\n  let a00 = a[0], a01 = a[1], a02 = a[2],\n    a10 = a[3], a11 = a[4], a12 = a[5],\n    a20 = a[6], a21 = a[7], a22 = a[8],\n\n    s = Math.sin(rad),\n    c = Math.cos(rad);\n\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n};\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nfunction scale(out, a, v) {\n  let x = v[0], y = v[1];\n\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat3} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nfunction fromRotation(out, rad) {\n  let s = Math.sin(rad), c = Math.cos(rad);\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat3} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n\n/**\n* Calculates a 3x3 matrix from the given quaternion\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {quat} q Quaternion to create matrix from\n*\n* @returns {mat3} out\n*/\nfunction fromQuat(out, q) {\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n\n  return out;\n}\n\n/**\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {mat4} a Mat4 to derive the normal matrix from\n*\n* @returns {mat3} out\n*/\nfunction normalFromMat4(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n  return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nfunction projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +\n          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +\n          a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]))\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n\n\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  out[4] = a[4] + (b[4] * scale);\n  out[5] = a[5] + (b[5] * scale);\n  out[6] = a[6] + (b[6] * scale);\n  out[7] = a[7] + (b[7] * scale);\n  out[8] = a[8] + (b[8] * scale);\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&\n         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&\n         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n          Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n          Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n          Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n          Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n          Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));\n}\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat3.js?");

/***/ }),

/***/ "./src/includes/mat4.js":
/*!******************************!*\
  !*** ./src/includes/mat4.js ***!
  \******************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromXRotation\", function() { return fromXRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromYRotation\", function() { return fromYRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromZRotation\", function() { return fromZRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat2\", function() { return fromQuat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScaling\", function() { return getScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRotation\", function() { return getRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScale\", function() { return fromRotationTranslationScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScaleOrigin\", function() { return fromRotationTranslationScaleOrigin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frustum\", function() { return frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspective\", function() { return perspective; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspectiveFromFieldOfView\", function() { return perspectiveFromFieldOfView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ortho\", function() { return ortho; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lookAt\", function() { return lookAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"targetTo\", function() { return targetTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1], a02 = a[2], a03 = a[3];\n    let a12 = a[6], a13 = a[7];\n    let a23 = a[11];\n\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction invert(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction adjoint(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\n  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\n  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\n  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\n  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\n  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction multiply(out, a, b) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  // Cache only the current line of the second matrix\n  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];\n  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];\n  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];\n  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n  return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nfunction translate(out, a, v) {\n  let x = v[0], y = v[1], z = v[2];\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;\n    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;\n    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;\n\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nfunction scale(out, a, v) {\n  let x = v[0], y = v[1], z = v[2];\n\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nfunction rotate(out, a, rad, axis) {\n  let x = axis[0], y = axis[1], z = axis[2];\n  let len = Math.hypot(x,y,z);\n  let s, c, t;\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n  let b00, b01, b02;\n  let b10, b11, b12;\n  let b20, b21, b22;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) { return null; }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n  // Construct the elements of the rotation matrix\n  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateX(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a10 = a[4];\n  let a11 = a[5];\n  let a12 = a[6];\n  let a13 = a[7];\n  let a20 = a[8];\n  let a21 = a[9];\n  let a22 = a[10];\n  let a23 = a[11];\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged rows\n    out[0]  = a[0];\n    out[1]  = a[1];\n    out[2]  = a[2];\n    out[3]  = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateY(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a00 = a[0];\n  let a01 = a[1];\n  let a02 = a[2];\n  let a03 = a[3];\n  let a20 = a[8];\n  let a21 = a[9];\n  let a22 = a[10];\n  let a23 = a[11];\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged rows\n    out[4]  = a[4];\n    out[5]  = a[5];\n    out[6]  = a[6];\n    out[7]  = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateZ(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a00 = a[0];\n  let a01 = a[1];\n  let a02 = a[2];\n  let a03 = a[3];\n  let a10 = a[4];\n  let a11 = a[5];\n  let a12 = a[6];\n  let a13 = a[7];\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged last row\n    out[8]  = a[8];\n    out[9]  = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Scaling vector\n * @returns {mat4} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nfunction fromRotation(out, rad, axis) {\n  let x = axis[0], y = axis[1], z = axis[2];\n  let len = Math.hypot(x, y, z);\n  let s, c, t;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) { return null; }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromXRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0]  = 1;\n  out[1]  = 0;\n  out[2]  = 0;\n  out[3]  = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromYRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0]  = c;\n  out[1]  = 0;\n  out[2]  = -s;\n  out[3]  = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromZRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0]  = c;\n  out[1]  = s;\n  out[2]  = 0;\n  out[3]  = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {quat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\nfunction fromQuat2(out, a) {\n  let translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  let bx = -a[0], by = -a[1], bz = -a[2], bw = a[3],\n  ax = a[4], ay = a[5], az = a[6], aw = a[7];\n\n  let magnitude = bx * bx + by * by + bz * bz + bw * bw;\n  //Only scale if it makes sense\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n\n  return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nfunction getScaling(out, mat) {\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n\n  return out;\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nfunction getRotation(out, mat) {\n  let scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  getScaling(scaling, mat);\n\n  let is1 = 1 / scaling[0];\n  let is2 = 1 / scaling[1];\n  let is3 = 1 / scaling[2];\n\n  let sm11 = mat[0] * is1;\n  let sm12 = mat[1] * is2;\n  let sm13 = mat[2] * is3;\n  let sm21 = mat[4] * is1;\n  let sm22 = mat[5] * is2;\n  let sm23 = mat[6] * is3;\n  let sm31 = mat[8] * is1;\n  let sm32 = mat[9] * is2;\n  let sm33 = mat[10] * is3;\n\n  let trace = sm11 + sm22 + sm33;\n  let S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if ((sm11 > sm22) && (sm11 > sm33)) {\n    S = Math.sqrt(1.0 + sm11 - sm22- sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @param {vec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n\n  let ox = o[0];\n  let oy = o[1];\n  let oz = o[2];\n\n  let out0 = (1 - (yy + zz)) * sx;\n  let out1 = (xy + wz) * sx;\n  let out2 = (xz - wy) * sx;\n  let out4 = (xy - wz) * sy;\n  let out5 = (1 - (xx + zz)) * sy;\n  let out6 = (yz + wx) * sy;\n  let out8 = (xz + wy) * sz;\n  let out9 = (yz - wx) * sz;\n  let out10 = (1 - (xx + yy)) * sz;\n\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nfunction fromQuat(out, q) {\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction frustum(out, left, right, bottom, top, near, far) {\n  let rl = 1 / (right - left);\n  let tb = 1 / (top - bottom);\n  let nf = 1 / (near - far);\n  out[0] = (near * 2) * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = (near * 2) * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = (far * near * 2) * nf;\n  out[15] = 0;\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nfunction perspective(out, fovy, aspect, near, far) {\n  let f = 1.0 / Math.tan(fovy / 2), nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = (2 * far * near) * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);\n  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);\n  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);\n  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);\n  let xScale = 2.0 / (leftTan + rightTan);\n  let yScale = 2.0 / (upTan + downTan);\n\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = ((upTan - downTan) * yScale * 0.5);\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = (far * near) / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction ortho(out, left, right, bottom, top, near, far) {\n  let lr = 1 / (left - right);\n  let bt = 1 / (bottom - top);\n  let nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nfunction lookAt(out, eye, center, up) {\n  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  let eyex = eye[0];\n  let eyey = eye[1];\n  let eyez = eye[2];\n  let upx = up[0];\n  let upy = up[1];\n  let upz = up[2];\n  let centerx = center[0];\n  let centery = center[1];\n  let centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] &&\n      Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] &&\n      Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n\n  len = Math.hypot(y0, y1, y2);\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nfunction targetTo(out, eye, target, up) {\n  let eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n\n  let z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n\n  let len = z0*z0 + z1*z1 + z2*z2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  let x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n\n  len = x0*x0 + x1*x1 + x2*x2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n};\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {mat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +\n          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +\n          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {mat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]))\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  out[4] = a[4] + (b[4] * scale);\n  out[5] = a[5] + (b[5] * scale);\n  out[6] = a[6] + (b[6] * scale);\n  out[7] = a[7] + (b[7] * scale);\n  out[8] = a[8] + (b[8] * scale);\n  out[9] = a[9] + (b[9] * scale);\n  out[10] = a[10] + (b[10] * scale);\n  out[11] = a[11] + (b[11] * scale);\n  out[12] = a[12] + (b[12] * scale);\n  out[13] = a[13] + (b[13] * scale);\n  out[14] = a[14] + (b[14] * scale);\n  out[15] = a[15] + (b[15] * scale);\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&\n         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&\n         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&\n         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];\n  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];\n  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];\n  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];\n\n  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];\n  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];\n  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];\n  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n          Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n          Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n          Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n          Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n          Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&\n          Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&\n          Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&\n          Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&\n          Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&\n          Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&\n          Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&\n          Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));\n}\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat4.js?");

/***/ }),

/***/ "./src/includes/quat.js":
/*!******************************!*\
  !*** ./src/includes/quat.js ***!
  \******************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxisAngle\", function() { return setAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAxisAngle\", function() { return getAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateW\", function() { return calculateW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slerp\", function() { return slerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat3\", function() { return fromMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromEuler\", function() { return fromEuler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotationTo\", function() { return rotationTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqlerp\", function() { return sqlerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxes\", function() { return setAxes; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ \"./src/includes/mat3.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ \"./src/includes/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ \"./src/includes/vec4.js\");\n\n\n\n\n\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  let s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {quat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nfunction getAxisAngle(out_axis, q) {\n  let rad = Math.acos(q[3]) * 2.0;\n  let s = Math.sin(rad / 2.0);\n  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nfunction multiply(out, a, b) {\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bx = Math.sin(rad), bw = Math.cos(rad);\n\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let by = Math.sin(rad), bw = Math.cos(rad);\n\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bz = Math.sin(rad), bw = Math.cos(rad);\n\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate W component of\n * @returns {quat} out\n */\nfunction calculateW(out, a) {\n  let x = a[0], y = a[1], z = a[2];\n\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n  let omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if ( cosom < 0.0 ) {\n    cosom = -cosom;\n    bx = - bx;\n    by = - by;\n    bz = - bz;\n    bw = - bw;\n  }\n  // calculate coefficients\n  if ( (1.0 - cosom) > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] ) {\n    // standard case (slerp)\n    omega  = Math.acos(cosom);\n    sinom  = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n\n  return out;\n}\n\n/**\n * Generates a random quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nfunction random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  let u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n  let u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n  let u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n\n  let sqrt1MinusU1 = Math.sqrt(1 - u1);\n  let sqrtU1 = Math.sqrt(u1);\n\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nfunction invert(out, a) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;\n  let invDot = dot ? 1.0/dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0*invDot;\n  out[1] = -a1*invDot;\n  out[2] = -a2*invDot;\n  out[3] = a3*invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  let fTrace = m[0] + m[4] + m[8];\n  let fRoot;\n\n  if ( fTrace > 0.0 ) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0);  // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5/fRoot;  // 1/(4w)\n    out[0] = (m[5]-m[7])*fRoot;\n    out[1] = (m[6]-m[2])*fRoot;\n    out[2] = (m[1]-m[3])*fRoot;\n  } else {\n    // |w| <= 1/2\n    let i = 0;\n    if ( m[4] > m[0] )\n      i = 1;\n    if ( m[8] > m[i*3+i] )\n      i = 2;\n    let j = (i+1)%3;\n    let k = (i+2)%3;\n\n    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;\n    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;\n    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;\n  }\n\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\nfunction fromEuler(out, x, y, z) {\n    let halfToRad = 0.5 * Math.PI / 180.0;\n    x *= halfToRad;\n    y *= halfToRad;\n    z *= halfToRad;\n\n    let sx = Math.sin(x);\n    let cx = Math.cos(x);\n    let sy = Math.sin(y);\n    let cy = Math.cos(y);\n    let sz = Math.sin(z);\n    let cz = Math.cos(z);\n\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n\n    return out;\n}\n\n/**\n * Returns a string representation of a quatenion\n *\n * @param {quat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nconst clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"clone\"];\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nconst fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"fromValues\"];\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nconst copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"copy\"];\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nconst set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"set\"];\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nconst add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"add\"];\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nconst scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"];\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nconst dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"dot\"];\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nconst lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"lerp\"];\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\nconst length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"length\"];\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nconst len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {quat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nconst squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"squaredLength\"];\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nconst normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"normalize\"];\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat} a The first quaternion.\n * @param {quat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nconst exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"exactEquals\"];\n\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {quat} a The first vector.\n * @param {quat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nconst equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"equals\"];\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nconst rotationTo = (function() {\n  let tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"create\"]();\n  let xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](1,0,0);\n  let yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](0,1,0);\n\n  return function(out, a, b) {\n    let dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"dot\"](a, b);\n    if (dot < -0.999999) {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, xUnitVec3, a);\n      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"len\"](tmpvec3) < 0.000001)\n        _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, yUnitVec3, a);\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"normalize\"](tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n})();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nconst sqlerp = (function () {\n  let temp1 = create();\n  let temp2 = create();\n\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n\n    return out;\n  };\n}());\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {vec3} view  the vector representing the viewing direction\n * @param {vec3} right the vector representing the local \"right\" direction\n * @param {vec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nconst setAxes = (function() {\n  let matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\n\n  return function(out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n\n    return normalize(out, fromMat3(out, matr));\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/quat.js?");

/***/ }),

/***/ "./src/includes/quat2.js":
/*!*******************************!*\
  !*** ./src/includes/quat2.js ***!
  \*******************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationValues\", function() { return fromRotationTranslationValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getReal\", function() { return getReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDual\", function() { return getDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setReal\", function() { return setReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDual\", function() { return setDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatAppend\", function() { return rotateByQuatAppend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatPrepend\", function() { return rotateByQuatPrepend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateAroundAxis\", function() { return rotateAroundAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ \"./src/includes/quat.js\");\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ \"./src/includes/mat4.js\");\n\n\n\n\n/**\n * Dual Quaternion<br>\n * Format: [real, dual]<br>\n * Quaternion format: XYZW<br>\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\n * @module quat2\n */\n\n\n/**\n * Creates a new identity dual quat\n *\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\n */\nfunction create() {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    dq[0] = 0;\n    dq[1] = 0;\n    dq[2] = 0;\n    dq[4] = 0;\n    dq[5] = 0;\n    dq[6] = 0;\n    dq[7] = 0;\n  }\n  dq[3] = 1;\n  return dq;\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat2} a dual quaternion to clone\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction clone(a) {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n\n/**\n * Creates a new dual quat initialized with the given values\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n\n/**\n * Creates a new dual quat from the given values (quat and translation)\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component (translation)\n * @param {Number} y2 Y component (translation)\n * @param {Number} z2 Z component (translation)\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  let ax = x2 * 0.5,\n    ay = y2 * 0.5,\n    az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n\n/**\n * Creates a dual quat from a quaternion and a translation\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {quat} q a normalized quaternion\n * @param {vec3} t tranlation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromRotationTranslation(out, q, t) {\n  let ax = t[0] * 0.5,\n    ay = t[1] * 0.5,\n    az = t[2] * 0.5,\n    bx = q[0],\n    by = q[1],\n    bz = q[2],\n    bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Creates a dual quat from a translation\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {vec3} t translation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Creates a dual quat from a quaternion\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {quat} q the quaternion\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Creates a new dual quat from a matrix (4x4)\n *\n * @param {quat2} out the dual quaternion\n * @param {mat4} a the matrix\n * @returns {quat2} dual quat receiving operation result\n * @function\n */\nfunction fromMat4(out, a) {\n  //TODO Optimize this\n  let outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getRotation\"](outer, a);\n  let t = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getTranslation\"](t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n\n/**\n * Copy the values from one dual quat to another\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the source dual quaternion\n * @returns {quat2} out\n * @function\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n\n/**\n * Set a dual quat to the identity dual quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @returns {quat2} out\n */\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Set the components of a dual quat to the given values\n *\n * @param {quat2} out the receiving quaternion\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} out\n * @function\n */\nfunction set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n\n/**\n * Gets the real part of a dual quat\n * @param  {quat} out real part\n * @param  {quat2} a Dual Quaternion\n * @return {quat} real part\n */\nconst getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\n\n/**\n * Gets the dual part of a dual quat\n * @param  {quat} out dual part\n * @param  {quat2} a Dual Quaternion\n * @return {quat} dual part\n */\nfunction getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n\n/**\n * Set the real component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat} q a quaternion representing the real part\n * @returns {quat2} out\n * @function\n */\nconst setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\n\n/**\n * Set the dual component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat} q a quaternion representing the dual part\n * @returns {quat2} out\n * @function\n */\nfunction setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n\n/**\n * Gets the translation of a normalized dual quat\n * @param  {vec3} out translation\n * @param  {quat2} a Dual Quaternion to be decomposed\n * @return {vec3} translation\n */\nfunction getTranslation(out, a) {\n  let ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n\n/**\n * Translates a dual quat by the given vector\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to translate\n * @param {vec3} v vector to translate by\n * @returns {quat2} out\n */\nfunction translate(out, a, v) {\n  let ax1 = a[0],\n    ay1 = a[1],\n    az1 = a[2],\n    aw1 = a[3],\n    bx1 = v[0] * 0.5,\n    by1 = v[1] * 0.5,\n    bz1 = v[2] * 0.5,\n    ax2 = a[4],\n    ay2 = a[5],\n    az2 = a[6],\n    aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the X axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateX(out, a, rad) {\n  let bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    ax1 = ax * bw + aw * bx + ay * bz - az * by,\n    ay1 = ay * bw + aw * by + az * bx - ax * bz,\n    az1 = az * bw + aw * bz + ax * by - ay * bx,\n    aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateX\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the Y axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateY(out, a, rad) {\n  let bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    ax1 = ax * bw + aw * bx + ay * bz - az * by,\n    ay1 = ay * bw + aw * by + az * bx - ax * bz,\n    az1 = az * bw + aw * bz + ax * by - ay * bx,\n    aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateY\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the Z axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateZ(out, a, rad) {\n  let bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    ax1 = ax * bw + aw * bx + ay * bz - az * by,\n    ay1 = ay * bw + aw * by + az * bx - ax * bz,\n    az1 = az * bw + aw * bz + ax * by - ay * bx,\n    aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateZ\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat by a given quaternion (a * q)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {quat} q quaternion to rotate by\n * @returns {quat2} out\n */\nfunction rotateByQuatAppend(out, a, q) {\n  let qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3],\n    ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n\n/**\n * Rotates a dual quat by a given quaternion (q * a)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat} q quaternion to rotate by\n * @param {quat2} a the dual quaternion to rotate\n * @returns {quat2} out\n */\nfunction rotateByQuatPrepend(out, q, a) {\n  let qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3],\n    bx = a[0],\n    by = a[1],\n    bz = a[2],\n    bw = a[3];\n\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around a given axis. Does the normalisation automatically\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {vec3} axis the axis to rotate around\n * @param {Number} rad how far the rotation should be\n * @returns {quat2} out\n */\nfunction rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return copy(out, a);\n  }\n  let axisLength = Math.hypot(axis[0],axis[1],axis[2]);\n\n  rad = rad * 0.5;\n  let s = Math.sin(rad);\n  let bx = s * axis[0] / axisLength;\n  let by = s * axis[1] / axisLength;\n  let bz = s * axis[2] / axisLength;\n  let bw = Math.cos(rad);\n\n  let ax1 = a[0],\n    ay1 = a[1],\n    az1 = a[2],\n    aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n\n  let ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n\n  return out;\n}\n\n/**\n * Adds two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {quat2} out\n * @function\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n\n/**\n * Multiplies two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {quat2} out\n */\nfunction multiply(out, a, b) {\n  let ax0 = a[0],\n    ay0 = a[1],\n    az0 = a[2],\n    aw0 = a[3],\n    bx1 = b[4],\n    by1 = b[5],\n    bz1 = b[6],\n    bw1 = b[7],\n    ax1 = a[4],\n    ay1 = a[5],\n    az1 = a[6],\n    aw1 = a[7],\n    bx0 = b[0],\n    by0 = b[1],\n    bz0 = b[2],\n    bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n\n/**\n * Alias for {@link quat2.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Scales a dual quat by a scalar number\n *\n * @param {quat2} out the receiving dual quat\n * @param {quat2} a the dual quat to scale\n * @param {Number} b amount to scale the dual quat by\n * @returns {quat2} out\n * @function\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n\n/**\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\n *\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nconst dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"dot\"];\n\n/**\n * Performs a linear interpolation between two dual quats's\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\n *\n * @param {quat2} out the receiving dual quat\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat2} out\n */\nfunction lerp(out, a, b, t) {\n  let mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n\n  return out;\n}\n\n/**\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a dual quat to calculate inverse of\n * @returns {quat2} out\n */\nfunction invert(out, a) {\n  let sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a dual quat\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat2} a quat to calculate conjugate of\n * @returns {quat2} out\n */\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n\n/**\n * Calculates the length of a dual quat\n *\n * @param {quat2} a dual quat to calculate length of\n * @returns {Number} length of a\n * @function\n */\nconst length = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"length\"];\n\n/**\n * Alias for {@link quat2.length}\n * @function\n */\nconst len = length;\n\n/**\n * Calculates the squared length of a dual quat\n *\n * @param {quat2} a dual quat to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nconst squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"squaredLength\"];\n\n/**\n * Alias for {@link quat2.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Normalize a dual quat\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a dual quaternion to normalize\n * @returns {quat2} out\n * @function\n */\nfunction normalize(out, a) {\n  let magnitude = squaredLength(a);\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n\n    let a0 = a[0] / magnitude;\n    let a1 = a[1] / magnitude;\n    let a2 = a[2] / magnitude;\n    let a3 = a[3] / magnitude;\n\n    let b0 = a[4];\n    let b1 = a[5];\n    let b2 = a[6];\n    let b3 = a[7];\n\n    let a_dot_b = (a0 * b0) + (a1 * b1) + (a2 * b2) + (a3 * b3);\n\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n\n    out[4] = (b0 - (a0 * a_dot_b)) / magnitude;\n    out[5] = (b1 - (a1 * a_dot_b)) / magnitude;\n    out[6] = (b2 - (a2 * a_dot_b)) / magnitude;\n    out[7] = (b3 - (a3 * a_dot_b)) / magnitude;\n  }\n  return out;\n}\n\n/**\n * Returns a string representation of a dual quatenion\n *\n * @param {quat2} a dual quaternion to represent as a string\n * @returns {String} string representation of the dual quat\n */\nfunction str(a) {\n  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';\n}\n\n/**\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat2} a the first dual quaternion.\n * @param {quat2} b the second dual quaternion.\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&\n    a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n\n/**\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\n *\n * @param {quat2} a the first dual quat.\n * @param {quat2} b the second dual quat.\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3],\n    a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7];\n  let b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n    Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n    Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n    Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n    Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n    Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n    Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n    Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)));\n}\n\n\n//# sourceURL=webpack:///./src/includes/quat2.js?");

/***/ }),

/***/ "./src/includes/vec2.js":
/*!******************************!*\
  !*** ./src/includes/vec2.js ***!
  \******************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2\", function() { return transformMat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2d\", function() { return transformMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nfunction fromValues(x, y) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to ceil\n * @returns {vec2} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to floor\n * @returns {vec2} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to round\n * @returns {vec2} out\n */\nfunction round (out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x*x + y*y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.hypot(x, y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength (a) {\n  var x = a[0],\n    y = a[1];\n  return x*x + y*y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nfunction normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x*x + y*y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }    \n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat4(out, a, m) {\n  let x = a[0];\n  let y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {vec2} a The vec2 point to rotate\n * @param {vec2} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec2} out\n */\nfunction rotate(out, a, b, c) {\n  //Translate point to the origin\n  let p0 = a[0] - b[0],\n  p1 = a[1] - b[1],\n  sinC = Math.sin(c),\n  cosC = Math.cos(c);\n  \n  //perform rotation and translate to correct position\n  out[0] = p0*cosC - p1*sinC + b[0];\n  out[1] = p0*sinC + p1*cosC + b[1];\n\n  return out;\n}\n\n/**\n * Get the angle between two 2D vectors\n * @param {vec2} a The first operand\n * @param {vec2} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n  let x1 = a[0],\n    y1 = a[1],\n    x2 = b[0],\n    y2 = b[1];\n  \n  let len1 = x1*x1 + y1*y1;\n  if (len1 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len1 = 1 / Math.sqrt(len1);\n  }\n  \n  let len2 = x2*x2 + y2*y2;\n  if (len2 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len2 = 1 / Math.sqrt(len2);\n  }\n  \n  let cosine = (x1 * x2 + y1 * y2) * len1 * len2;\n  \n  \n  if(cosine > 1.0) {\n    return 0;\n  }\n  else if(cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1];\n  let b0 = b[0], b1 = b[1];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));\n}\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nconst len = length;\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nconst sub = subtract;\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nconst div = divide;\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nconst dist = distance;\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nconst sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nconst forEach = (function() {\n  let vec = create();\n\n  return function(a, stride, offset, count, fn, arg) {\n    let i, l;\n    if(!stride) {\n      stride = 2;\n    }\n\n    if(!offset) {\n      offset = 0;\n    }\n\n    if(count) {\n      l = Math.min((count * stride) + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for(i = offset; i < l; i += stride) {\n      vec[0] = a[i]; vec[1] = a[i+1];\n      fn(vec, vec, arg);\n      a[i] = vec[0]; a[i+1] = vec[1];\n    }\n\n    return a;\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/vec2.js?");

/***/ }),

/***/ "./src/includes/vec3.js":
/*!******************************!*\
  !*** ./src/includes/vec3.js ***!
  \******************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hermite\", function() { return hermite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bezier\", function() { return bezier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return Math.hypot(x, y, z);\n}\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return x*x + y*y + z*z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return x*x + y*y + z*z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let len = x*x + y*y + z*z;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n  let ax = a[0], ay = a[1], az = a[2];\n  let bx = b[0], by = b[1], bz = b[2];\n\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction hermite(out, a, b, c, d, t) {\n  let factorTimes2 = t * t;\n  let factor1 = factorTimes2 * (2 * t - 3) + 1;\n  let factor2 = factorTimes2 * (t - 2) + t;\n  let factor3 = factorTimes2 * (t - 1);\n  let factor4 = factorTimes2 * (3 - 2 * t);\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction bezier(out, a, b, c, d, t) {\n  let inverseFactor = 1 - t;\n  let inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  let factorTimes2 = t * t;\n  let factor1 = inverseFactorTimesTwo * inverseFactor;\n  let factor2 = 3 * t * inverseFactorTimesTwo;\n  let factor3 = 3 * factorTimes2 * inverseFactor;\n  let factor4 = factorTimes2 * t;\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n\n  let r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\n  let z = (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0) - 1.0;\n  let zScale = Math.sqrt(1.0-z*z) * scale;\n\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n  let x = a[0], y = a[1], z = a[2];\n  let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n  let x = a[0], y = a[1], z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n    let qx = q[0], qy = q[1], qz = q[2], qw = q[3];\n    let x = a[0], y = a[1], z = a[2];\n    // var qvec = [qx, qy, qz];\n    // var uv = vec3.cross([], qvec, a);\n    let uvx = qy * z - qz * y,\n        uvy = qz * x - qx * z,\n        uvz = qx * y - qy * x;\n    // var uuv = vec3.cross([], qvec, uv);\n    let uuvx = qy * uvz - qz * uvy,\n        uuvy = qz * uvx - qx * uvz,\n        uuvz = qx * uvy - qy * uvx;\n    // vec3.scale(uv, uv, 2 * w);\n    let w2 = qw * 2;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n    // vec3.scale(uuv, uuv, 2);\n    uuvx *= 2;\n    uuvy *= 2;\n    uuvz *= 2;\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    out[0] = x + uvx + uuvx;\n    out[1] = y + uvy + uuvy;\n    out[2] = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n  let p = [], r=[];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0];\n  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);\n  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n  let p = [], r=[];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);\n  r[1] = p[1];\n  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n  let p = [], r=[];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);\n  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);\n  r[2] = p[2];\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n  let tempA = fromValues(a[0], a[1], a[2]);\n  let tempB = fromValues(b[0], b[1], b[2]);\n\n  normalize(tempA, tempA);\n  normalize(tempB, tempB);\n\n  let cosine = dot(tempA, tempB);\n\n  if(cosine > 1.0) {\n    return 0;\n  }\n  else if(cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2];\n  let b0 = b[0], b1 = b[1], b2 = b[2];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));\n}\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nconst sub = subtract;\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nconst div = divide;\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nconst dist = distance;\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nconst sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nconst len = length;\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nconst forEach = (function() {\n  let vec = create();\n\n  return function(a, stride, offset, count, fn, arg) {\n    let i, l;\n    if(!stride) {\n      stride = 3;\n    }\n\n    if(!offset) {\n      offset = 0;\n    }\n\n    if(count) {\n      l = Math.min((count * stride) + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for(i = offset; i < l; i += stride) {\n      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];\n      fn(vec, vec, arg);\n      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/vec3.js?");

/***/ }),

/***/ "./src/includes/vec4.js":
/*!******************************!*\
  !*** ./src/includes/vec4.js ***!
  \******************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {vec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nfunction fromValues(x, y, z, w) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to ceil\n * @returns {vec4} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to floor\n * @returns {vec4} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to round\n * @returns {vec4} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  let w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  let w = b[3] - a[3];\n  return x*x + y*y + z*z + w*w;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {vec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  return x*x + y*y + z*z + w*w;\n}\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to negate\n * @returns {vec4} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to invert\n * @returns {vec4} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nfunction normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  let len = x*x + y*y + z*z + w*w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {vec4} result the receiving vector\n * @param {vec4} U the first vector\n * @param {vec4} V the second vector\n * @param {vec4} W the third vector\n * @returns {vec4} result\n */\nfunction cross (out, u, v, w) {\n    let A = (v[0] * w[1]) - (v[1] * w[0]),\n        B = (v[0] * w[2]) - (v[2] * w[0]),\n        C = (v[0] * w[3]) - (v[3] * w[0]),\n        D = (v[1] * w[2]) - (v[2] * w[1]),\n        E = (v[1] * w[3]) - (v[3] * w[1]),\n        F = (v[2] * w[3]) - (v[3] * w[2]);\n    let G = u[0];\n    let H = u[1];\n    let I = u[2];\n    let J = u[3];\n\n    out[0] = (H * F) - (I * E) + (J * D);\n    out[1] = -(G * F) + (I * C) - (J * B);\n    out[2] = (G * E) - (H * C) + (J * A);\n    out[3] = -(G * D) + (H * B) - (I * A);\n\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\nfunction lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  let aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n\n  // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n  var v1, v2, v3, v4;\n  var s1, s2;\n  do {\n    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n  do {\n    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec4} out\n */\nfunction transformMat4(out, a, m) {\n  let x = a[0], y = a[1], z = a[2], w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec4} out\n */\nfunction transformQuat(out, a, q) {\n  let x = a[0], y = a[1], z = a[2];\n  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];\n\n  // calculate quat * vec\n  let ix = qw * x + qy * z - qz * y;\n  let iy = qw * y + qz * x - qx * z;\n  let iz = qw * z + qx * y - qy * x;\n  let iw = -qx * x - qy * y - qz * z;\n\n  // calculate result * inverse quat\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n}\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nconst sub = subtract;\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nconst div = divide;\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nconst dist = distance;\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nconst sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nconst len = length;\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nconst forEach = (function() {\n  let vec = create();\n\n  return function(a, stride, offset, count, fn, arg) {\n    let i, l;\n    if(!stride) {\n      stride = 4;\n    }\n\n    if(!offset) {\n      offset = 0;\n    }\n\n    if(count) {\n      l = Math.min((count * stride) + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for(i = offset; i < l; i += stride) {\n      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];\n      fn(vec, vec, arg);\n      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];\n    }\n\n    return a;\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/vec4.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _gltf_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gltf_loader.js */ \"./src/gltf_loader.js\");\n\n\n//define custom element poly wolf\nclass PolyWolf extends HTMLDivElement {\n    constructor(  ) {\n        //always call super first in constructor\n        super();\n\n        //set style\n        this.style = `\n            position:relative;\n        `;\n\n        //add canvas\n        this.canvas = document.createElement('canvas');\n        this.appendChild(this.canvas);\n\n        //set dimensions\n        this.canvas.height = this.getAttribute('height');\n        this.canvas.width = this.getAttribute('width');\n\n        //set container dimensions\n        this.style.height = this.canvas.height;\n        this.style.width = this.canvas.width;\n\n        //set opacity\n        this.canvas.style = `\n            position:absolute;\n            opacity:0.9;\n        `;\n\n        //set webgl 2 context\n        this.gl = this.canvas.getContext('webgl2');\n\n        //set model url\n        this.url = this.getAttribute('url')\n\n        //create load button\n        this.button = document.createElement('div');\n        this.button.innerHTML = `\n        <img src=\"https://img.icons8.com/color/48/000000/circled-play--v1.png\">\n        `\n        this.button.style = `\n            margin: 0;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color:black;\n        `;\n        this.appendChild( this.button );\n\n        //load model once button is clicked\n        this.button.onclick = () =>{\n            //hide button\n            //this.button.style.visibility = 'hidden';\n\n            //append loading icon\n            this.button.innerHTML = \"loading\";\n\n            //load model\n            this.load();\n            \n        }\n\n    }\n\n    //load and render model\n    load( ) {\n        Object(_gltf_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"load\"])(this.gl, this.url)\n        .then((gltf)=>{\n            this.button.style.visibility = \"hidden\";\n            \n            console.log(gltf);\n            gltf._render();\n        });\n    }\n\n};\nwindow.customElements.define('poly-wolf', PolyWolf, { extends: 'div' });\nwindow.customElements.whenDefined('poly-wolf').then(()=>{\n    console.log('poly wolf has been defined');\n})\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });