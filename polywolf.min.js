/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_gltf_loader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/gltf_loader.js */ \"./src/gltf_loader.js\");\n\r\ndocument.body.innerHTML += `\r\n<style>\r\n@-webkit-keyframes spin {\r\n    to {\r\n      -webkit-transform: rotate(360deg);\r\n              transform: rotate(360deg);\r\n    }\r\n  }\r\n  @keyframes spin {\r\n    to {\r\n      -webkit-transform: rotate(360deg);\r\n              transform: rotate(360deg);\r\n    }\r\n  }\r\n  .stroke-dotted {\r\n    opacity: 0;\r\n    stroke-dasharray: 4,5;\r\n    stroke-width: 1px;\r\n    -webkit-transform-origin: 50% 50%;\r\n            transform-origin: 50% 50%;\r\n    -webkit-animation: spin 4s infinite linear;\r\n            animation: spin 4s infinite linear;\r\n    -webkit-transition: opacity 1s ease,  stroke-width 1s ease;\r\n    transition: opacity 1s ease,  stroke-width 1s ease;\r\n  }\r\n  \r\n  .stroke-solid {\r\n    stroke-dashoffset: 0;\r\n    stroke-dashArray: 300;\r\n    stroke-width: 4px;\r\n    -webkit-transition: stroke-dashoffset 1s ease,  opacity 1s ease;\r\n    transition: stroke-dashoffset 1s ease,  opacity 1s ease;\r\n  }\r\n  \r\n  .icon {\r\n    -webkit-transform-origin: 50% 50%;\r\n            transform-origin: 50% 50%;\r\n    -webkit-transition: -webkit-transform 200ms ease-out;\r\n    transition: -webkit-transform 200ms ease-out;\r\n    transition: transform 200ms ease-out;\r\n    transition: transform 200ms ease-out, -webkit-transform 200ms ease-out;\r\n  }\r\n  \r\n  #play:hover .stroke-dotted {\r\n    stroke-width: 4px;\r\n    opacity: 1;\r\n  }\r\n  #play:hover .stroke-solid {\r\n    opacity: 0;\r\n    stroke-dashoffset: 300;\r\n  }\r\n  #play:hover .icon {\r\n    -webkit-transform: scale(1.05);\r\n            transform: scale(1.05);\r\n  }\r\n  \r\n  #play {\r\n    cursor: pointer;\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    -webkit-transform: translateY(-50%) translateX(-50%);\r\n            transform: translateY(-50%) translateX(-50%);\r\n  }\r\n  \r\n</style>\r\n`\r\n//define custom element poly wolf\r\nclass PolyWolf extends HTMLDivElement {\r\n    constructor(  ) {\r\n        //always call super first in constructor\r\n        super();\r\n\r\n        //set style\r\n        this.style = `\r\n            position:relative;\r\n            background-color:white;\r\n            padding:0;\r\n            margin:0;\r\n            border-width:0.5px;\r\n            border-radius:10px;\r\n            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\r\n            background-color: #F5F7FF;\r\n            background: radial-gradient(#F5F7FF,#F5FFFF);\r\n            cursor:cell;\r\n        `;\r\n\r\n        //add canvas\r\n        this.canvas = document.createElement('canvas');\r\n        this.appendChild(this.canvas);\r\n\r\n        //set dimensions\r\n        this.canvas.height = this.getAttribute('height');\r\n        this.canvas.width = this.getAttribute('width');\r\n\r\n        //set container dimensions\r\n        this.style.height = this.canvas.height;\r\n        this.style.width = this.canvas.width;\r\n\r\n        //set opacity\r\n        this.canvas.style = `\r\n            position:absolute;\r\n            opacity:0.9;\r\n        `;\r\n\r\n        //set webgl 2 context\r\n        this.gl = this.canvas.getContext('webgl2');\r\n\r\n        //set model url\r\n        this.url = this.getAttribute('url')\r\n\r\n        //create load button\r\n        this.button = document.createElement('div');\r\n        this.button.innerHTML = `\r\n        <svg version=\"1.1\" id=\"play\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" height=\"50px\" width=\"50px\"\r\n\t viewBox=\"0 0 100 100\" enable-background=\"new 0 0 100 100\" xml:space=\"preserve\">\r\n  <path class=\"stroke-solid\" fill=\"none\" stroke=\"white\"  d=\"M49.9,2.5C23.6,2.8,2.1,24.4,2.5,50.4C2.9,76.5,24.7,98,50.3,97.5c26.4-0.6,47.4-21.8,47.2-47.7\r\n    C97.3,23.7,75.7,2.3,49.9,2.5\"/>\r\n  <path class=\"stroke-dotted\" fill=\"none\" stroke=\"white\"  d=\"M49.9,2.5C23.6,2.8,2.1,24.4,2.5,50.4C2.9,76.5,24.7,98,50.3,97.5c26.4-0.6,47.4-21.8,47.2-47.7\r\n    C97.3,23.7,75.7,2.3,49.9,2.5\"/>\r\n  <path class=\"icon\" fill=\"white\" d=\"M38,69c-1,0.5-1.8,0-1.8-1.1V32.1c0-1.1,0.8-1.6,1.8-1.1l34,18c1,0.5,1,1.4,0,1.9L38,69z\"/>\r\n</svg>\r\n        `\r\n        this.button.style = `\r\n            margin: 0;\r\n            position: absolute;\r\n            top: 50%;\r\n            left: 50%;\r\n            transform: translate(-50%, -50%);\r\n            border-radius:20px;\r\n        `;\r\n        this.appendChild( this.button );\r\n\r\n        //load model once button is clicked\r\n        this.button.onclick = () =>{\r\n            //hide button\r\n            //this.button.style.visibility = 'hidden';\r\n\r\n            //append loading icon\r\n            /*document.body.innerHTML += `\r\n            <style>.image {\r\n                position: absolute;\r\n                top: 50%;\r\n                left: 50%;\r\n                width: 120px;\r\n                height: 120px;\r\n                margin:-60px 0 0 -60px;\r\n                -webkit-animation:spin 4s linear infinite;\r\n                -moz-animation:spin 4s linear infinite;\r\n                animation:spin 4s linear infinite;\r\n            }\r\n            @-moz-keyframes spin { 100% { -moz-transform: rotate(360deg); } }\r\n            @-webkit-keyframes spin { 100% { -webkit-transform: rotate(360deg); } }\r\n            @keyframes spin { 100% { -webkit-transform: rotate(360deg); transform:rotate(360deg); } }</style>\r\n            `;*/\r\n            this.button.innerHTML = `Loading`+this.url;\r\n\r\n            //load model\r\n            this.load();\r\n            \r\n        }\r\n\r\n    }\r\n\r\n    //load and render model\r\n    load( ) {\r\n        Object(_src_gltf_loader_js__WEBPACK_IMPORTED_MODULE_0__[\"load\"])(this.gl, this.url)\r\n        .then((gltf)=>{\r\n            this.button.style.visibility = \"hidden\";\r\n            \r\n            console.log(gltf);\r\n            gltf._render();\r\n        })\r\n        .catch((err)=>{\r\n          this.button.innerHTML = 'failed to loader'+this.url;\r\n        });\r\n    }\r\n\r\n};\r\nwindow.customElements.define('poly-wolf', PolyWolf, { extends: 'div' });\r\nwindow.customElements.whenDefined('poly-wolf').then(()=>{\r\n    console.log('poly wolf has been defined');\r\n})\r\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: layout, type, uniform_names, anim_lengths */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"layout\", function() { return layout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"type\", function() { return type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniform_names\", function() { return uniform_names; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"anim_lengths\", function() { return anim_lengths; });\nconst layout = {\r\n    \"POSITION\" : 0,\r\n    \"NORMAL\" : 1,\r\n    \"TEXCOORD_0\" : 2,\r\n    \"COLOR_0\": 3,\r\n    \"TANGENT\": 4,\r\n    \"WEIGHTS_0\": 5,\r\n    \"JOINTS_0\": 6\r\n};\r\n\r\nconst type = {\r\n    \"VEC2\" : 2,\r\n    \"VEC3\" : 3,\r\n    \"VEC4\" : 4,\r\n    \"SCALAR\" : 1,\r\n}\r\n\r\nconst uniform_names = {\r\n    \"view\" : \"view\",\r\n    \"perspective\" : \"perspective\",\r\n    \"env_map\" : \"env_map\",\r\n    'diffuse_map' : 'diffuse_map',\r\n    'prefilter_map' : 'prefilter_map',\r\n    'brdflut_map' : 'brdflut_map',\r\n}\r\n\r\nconst anim_lengths = {\r\n    \"translation\" : 3,\r\n    \"rotation\" : 4,\r\n    \"scale\" : 3,\r\n    \"matrix\" : 16\r\n}\n\n//# sourceURL=webpack:///./src/config.js?");

/***/ }),

/***/ "./src/env_map/nx.jpg":
/*!****************************!*\
  !*** ./src/env_map/nx.jpg ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAQABAADASIAAhEBAxEB/8QAHAAAAwEBAQEBAQAAAAAAAAAAAAIDBAEFBgcI/8QAShAAAgIBAgMECQIEBAUDAQYHAAIDEgQTIgUxMhRCUmEGFSMzQUNTYnFjchZzgpIHESQ0AVGDovAhRLKBF0VVk6GjZJHBwtHS4f/EABoBAQEBAQEBAQAAAAAAAAAAAAABAgMEBQb/xAAmEQEBAAICAgMBAQADAQEBAAAAAQIRAxIhMRNBUQQiFDJhQnEj/9oADAMBAAIRAxEAPwD2AAD5T6YFqMACAOLUNOAABNAAAIAAAAAADlToAAoDHKl2OAdqFSjgHahUDgHahUmxw7U6BByp0AAAAAAAAAAAC6B1VGp5AEAAAAAAGgAAQA1RU+A5kAAAAADAcU6AAAAAAAHV5mWxUYAKwAABWoAADIcAAKDqnB15hIZVHA6plXBH+I4j/EAT4DnF5HQAAABgOKdMAOrzODp8AAAGXkFjoAAadU6cU6ZAdXmcHT4F0AZeQpRVMgqcKk2JAKdOKdHsA4q8xiNAAABl5DinVMDp1eZwcAGXkKnwHMgADqkHTq8zg4aA5xeR0yoOqCnQA6vM4OADnF5HSDqnQAyOrzGAAoGXkC8jphoDHFOgdXmMAy8jI6ADAcU6AAA6fAVeYxhY/JwAD9G8AAAAAAAyKeQg4AIB2pwNAAAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO1DTg4AGQAAAAABoAAEAADmQAAAAAAAMcU6AAAAAAAaA4q8xgUAABkAAGGwMvIUcIAAAOqMvM4dXmSqqdUVeQ5ihRBzi8jQ6AAAAB1TNHQAAAcE+AEAOcXkdDTqhUFKU8iKQB61GqZCsoDNyFKGVSyqTjUsvIxWhUWRSokhkSADq8zfpIZPgAARQMvIUczQwHFGXmQC8xgGXkQdAAMhgOKdCurzGAZeQV0AOqZV0AADq8xgGXkB06p0DPoB1eZwcgAAZeRlp0YUYig6vMF5jAA5xeR0yAY4p0LQADmT2Bl5Cp8ByK/JAHOVP0b55QAAAAAAAACaAAAQgDhTyC7IAAFAAAZAAAAAAAAAAAAAAAAAAB2oacO1Gp5AE2AAAgAADQAAAAADOwAqjVOkAAAAAAAB1VCp0AAAAAAAoOrzODhQAAGQAAZaAACfAgZeR0ACg6pwYIDq8zh1eZlTJ8BxAABzi8joAAAADHFOmAAB1eZoMAAnwMqcBjiho0amipFCpgcY6AEoRuR0YUodeZUkvMa/mZrSlib/EL+YthIODp8BV5jAAAqjVIBeQynBjIB0+Aq8xgAc4vI6ZAdU4MRQOqirzGChPgOcXkdMqYDinQAdPgKvMYAT4DgdUyOgAEDp8AACLAnwHAYy04p0Dq8wGBPgA5kAAdUL6dAAIenV5jAMvIyroAdUD8mAAP0b54OVOgAgDiU8gAAAAAAAAAAmgFPIACFqcHALsgD08hahXAO1CoHAO1CoHAHp5BTyCbIdqMANgAAIAAAugAAFAABAAA1SBRwAAAAGgAAw9BRgAAAAIAAANADtRgAAAMgAAy0AACKBwAAADqqAKdACewDirzGKAAHMgAAAAA6pmjoABQDirzGIAcRPgORp1TpxRm5hTIWXmTjHOdWOMCqdApoCjHGUILBY4dULHQAenkCAAAypl5HQO1M+wKdA6vMgZPgCfABl5EHQA6pkCnQOrzDRhl5Cjkqg6pwYgAAdPgADLyFHIAY4p0yAcVeYwUDLyFT4DmGgdUFOgdXmMAJ8DIZeR0AA6p0AC+wOKvMYyoHOLyOkHVOgAH5KAAfo3zwAAAAAAcqKOAT0QBqihQAAAAAAAAATQAABoAABAAAAAABdAAAKAAAAACnkABTyGqdCbcqdAAaAAAUAAAAAdqZ2Cp0AIAAAAAADQO1Gp5AAAABkAAGWgAARQOcqdAAAAhgAAAAHCgAAyGXkdAAAAAAGOKdIAAOrzKGAAMBl5HQANuqdOKdAqvIcknwKKYHQAA05Y6KAHVOnFOgA4q8ypm0IOcqdM0dU6cU6ADirzGIGXkdADCgY4p0LHV5jACfAKZeR0BjI4p0AA6vMYAT4AOdU4MZAADp8CAABl5GWnRhRiKB0+Aq8xgAc4vI6ZAdU6AWg6vM4OZqgE+ADkAdU4MAAB1eZKPyWoVOgfoXzygdqFS7HAADQAAAAAADlRRwAQBqigAAAAAAAAAAAAAAAAAAFPIaoChTyHAAAACaAAAUAAAAAdqQcO1OgQAABAAABQAHahoVGAAyAACAAAIoAAIoGXkFToAAAADHFOhAAHV5hTAAGQDLyBeR0AAAADqgp0AAAAB0+Ag5mgBPgAy8iLHQAA0BjinQHGXkTXmNfzMiljolhlI04dU4MAAA6fAlAAAQOMKMZ9AAByAGXkKnwHJQHVODGWtA6vM4OFA5xeR0yA6oKdADq8wXmMADnF5DmaOKdACK6vMYAIQy8joHVMtBToHV5gMADmQAB1Q06AHV5kDJ8AAE+BkMvI6AEHVOgAAOAy8jKvyIAA/RvAAAAjlToAEKB2pwuwAAGgAAAAAAAcqdAJpyotPIcApKeQU8hwASnkNU6AHKnQAJoAABQAAAAAAAAdqQcO1OgQAABAAABQAAFB2o1PIAAAAMgAAm2tAAAyoAAABwAAAAADqqCnQAAADqqMAGQAA4AAAAHVODAAAAAAAB1eYwAYAOcXkdDQADqhXQAAOrzGADIZeQ4oxGgAAEjq8xgAyoHOLyGUAU6AGB1eYwDLyIOgB1TLUCnQOrzAZPgADLyCugB1TI6ADp8AAE+ADkAMcU6ZAOnwFXmMRdAc4qnTLQGOKdABwAyGXkdAA0BjinQAcAMgHOLyOkAdU6BkA4J8AIBPgOB1Q2/IAHFqfo3ztuAABQAAEAAARypwYAhQO1OF2AAA0AAAAAAAAAAAAAAAAAAACAA7U6TYDlToAAABAAABQAAFAHajALUYACAAAmwAAGVAAAUAA1QCp0AAAAAA7UKnQAAAAHAAAAGXkZAvI6AAAAdUAU6AAAAAAdXmcHIAABPgZU4DHKhoVOnV5jECDgNUgUaoyqdI04p07UYmwh1eYVGIAE+ADgAxxTpkA4qqMQCfAcAMqBgAjQHBPgADLyOgBkdU6B1eYAvMYAT4AMvIcUYwAAHT4BoAnwAcyoOqdAgDq8zg4AOcXkdMroDCjEUDp8BV5jEoBl5CjkAADGQHVUF5jEAMvIFU6GjAAGVfkQAB+lfPAU8gGXkRNFZRampYybRjaoAdbmcKAAAIAAAjlQqdAIUBjlQOAdqFS7HAO1Co2OAdqdADlToEHKnQAAAADWgAADQAACgDtRghajABEAAA2ugAAZUAAAABTyGqAo1ToAAAAAAAAHVBVOgAAAAOFPIAAAAyBPgOAAAAdUDgxxToAAAAAAAdXmMAGQDLyFKKRp0DtRqeQUDLyFGVTDRlUFOnagMnwEHCnkZAOd0w6DOxMZVBVsUqUIdUGOk2AAHIAZeQo5KA6p0DLYOrzODgAy8gXkdMgOqCnQAcAABwOqZUKdACDq8xgGXkZadABiAADq8wGABzLQADqgCnQHMgABl5EHQA6pAKdAcyoBPgA4UHVBVOmVAAOZH4+AU8iiqfptvnhY7lo4xoYyyxnPbWhp/gm0ZoqFTErWnlyRkjbkR1Mp2jBAHZRamkcAAAAA7UI4AHV5g0FW4MtDZDCLkRmN7VkA6ynDaaAAANAAAGgAHWUDgAAU4tRgDIT4AABQAADQAACgACnkTYAGqdGxyp0AMgAAAAAAAAGAU6qhU6AAdqcAB0+Aq8xgAAAyGqdAAAAADqnTijLzA4B1uZwAAAADq8zg5F9AABPgZIZeQynB4/eBpaorKUVSlTntpnXkMo1RlUoCiqFRlUwCoKpReR0xscqKylm5kZGEUqqMygOERADq8ygXmMAy8iDoAdUy06AHV5hTJ8AAZeQHQA6pkdOrzBeYwAMvIVPgOZq6AwAQ9gcVeYxK0BwGMjinQAnsdXmMAEaMvI6AAdU6B1eZkC8xgAgE+A4HVIBToDmVAAMvINOjCjGQAA5AAA5lp+SUKLH7QZYzUsdz9Fa8EgjjCnkVA47acqLUpUKkGWaG5jaE9RlM8kZ1xyow6f5F0956Sw7Bezmu8Y6vNaMWh6kmKTXHvGXtE1XnspTT2GhsXeW7PcdoaefolMeG0m43dm8ikOLRyXPwvURxk5oTcsINGcJnq7beLNjmVlPoJse55M2P7Q9GGfZjTIBp7OzoNDDeQ32jLPQbT9mbmx6CtGZ2umWGG5SSPYWjhLNH7MmzTy6eQDSL7QGU6bZKAAUAAMvIiiopZVFZSCYyqdAAAAIAAAAA7UKgcGAAOVOgAHKnQAAAB1UAAc5UyFGVQVSmn7MKiOABAAAADAAAOghVVIsKyiFW5E15hXAHf4iqpU0ZPgADVMnsLyOnVUZVI0KloYwVS0amLWjKo1RlUc47EKhUtUWnkAtQXmUqLTyAZeQ4p1TLUdINzLMKylKWnkA51QibKBRiZYGXkdADKwwAAUDgnwABl5HQGMjinQHT4AAAMvIi+nTqnQMlAAORoDLyFT4DmQDHFOkoDq8wXmMRoDnF5HQA6oKdM0A4J8AIAc4vI6AwAdXmZUyfAAAw0ZeR0DqgCnQHIAAGVTLQXkdA6qhX5jp/k0KoVGPtV4QFPIAMgAAKAVoxk+A4CLGNojKMvMloVo/ZkdP8mp/iTqJVTjxzR2dBoVLGblV0z0GWEtQapnZpPT/IrRmioMpFZWjMs2KelUVlNTLSaeauKThxaSHqLGGkbnIaefNCTjhPSaG4uiWZ6ZYdH2hRodhooU09g7jw5Me05PKx6ntLi+0I5WOdZyeU0+fGVTVkY9NxNYzvvbGkajRqUoNGoQqqKymhVFkjJsQOVKP8RVUoFUGUsqgq2Az1CpZoxaeQCtzOFdP8CgA1QXkUVQJ1Fp5Fqi1JtdJsohdidPIqFXmWjUmqmqFTNVNYxamyhNozO10nHGWqMsY1TO2tMcke8WpokUiym2SDHKnSsgAHVQoVSlRVUsYtaTYnTyNBOpAtRSjKTKgT4FKiqpZVCmVdgyqNUKnPbRk+BZeZFPgWVjFFF5DklYc5jtTpyxwKYDigwacHrQFUZ/iETYVmGYVuQKF5DMKqjgjjHAAKDqgp0AOrzODgA5xeR0yAYDq8wBeYwARTVOgdUyroAdXmQC8xgGXkRXRhRiAABzLQBPgA4AMKMQB1VBeYxkAy8hU+A5FAxxVOkAOAGGgOcXkOBxToHV5kUyfAAAyAcADTqnQAlH59pispqqTZT6+3j0z08hqlNP8gyl2aRFsUZSdTTLh2xw5YopfzGsRsFiaGiw1jPYZWA0KxZWMqsWVjnY00nVIqxSxlTgcsdMjtQqC8xhtS1CowDZotRVjKANmk9AbT/JU7UnY0nQjNCaqgyiWmni5GLeOpnjxaIe5JDcztCd8eTTOnl9nJtDQ9ZoSMkNzczrLz9P8itGbGhItGdJltNMMkY0amhoxam9saLUZVOjmWk2jF0/wWCnkNiNTO0ZsbmTqal0jOqlF5hWhw0no4CAZ004wrKOOymmdFjU2RqTjjNCqc8q3DadybRmhQZTltUahUpUGUozyRkam5VJtGalGFlENbRk9PedNslVRlUaoLzIugvMYE+A5lUm5gvMoyk15lDP8SLciwgSuKWXkTVSyqKqifAAA5gHEGXkAylBVUYwHAQcwAAO1DaiqAAT0EFKsohQAAAcqdHp5CAAAOADLyFT4DmQHVBToAOAEUDnF5HTLTqnQAyAcE+AACfAcDqkAqnQOrzMtBeYwDLyA6AHVUgFOgOZAADmWvQOqdAgB0+Aq8xiVQMvIVPgORQMcU6ZAOCfACKBl5CjhQdU6BAHV5nBzI+DsdIan5GufX08qlRWUNT8C38yIVlFqNYWxpE2UQq3Im3M6MuCNyGYm/xNBrDWJ38wv5gaFYoshjuUWQzobFkKKxhWQoshjStysUVjGswyyGdK1WGsZ1kGuZ01tawWI3C46020ArEdT8BqfgmqbaLDWM+oGuTStFgsZ9QbU/I6ptckyi6n5DU/JdGyspNlGZibMaRFlIspobkRY6RlnZSbKaH+JFuR1iJHbA3M4bSnAQ7YaQwh2xwNOMpA0CMpqMlVRlUoqhUCaqU07gvMovIy0I1qWT4CHV5mKNC8zgisNY5joHGBWA6BxmOgSp5BQpUGLsZW5Ei8hFuZ2gZPgOSXmUXkZHRBxAAWow1SgVSi8xVGXmZoYAHMhBl5BUZSUMvMYQcgZeR0RPgOYajqjVFUonwCmXkdA6pkFSbKVOMBAenkDKMvI0BeQrKM3ILGQqqNUVPgVAU6p0AA6qhUYLoDLyFHMNA6oKdIA6vM4OZAMvIF5HQGAAMtAcAT4AMqnQGIOKp0Dq8yBk+AAMvIw0FUcUYig6vM4OTYAAci+gdU4MZqg6vM4ORQADLyA6AHVAFOgdXmZDJ8AACD8x1hlmMdwuffuLwt2qGqY9T8BrGetGzU/Ian5MesNrjrRo1BWkM+p+A1PwWY0WZhWYjcLm9ClgsR1PyFi6FLDWI2CxeqbaNT8jLIZbAshNG2xZiizGG42p+DPVW5ZimuefqBrmeo9DXG1Tz9UbWJ0o3aoaph1g1idKN2qGqYdYNYdKPQ1g1jz9YbWHSjdrBrGHWDWJ1o3awNIYdYNYdaNWoKzGfU/Aan4NTEUZibMLfzFsbA3M4ByxqJXQFAqO2CxwAGA5YLANYYQCaaOF/MWwWMiisMrE7+Y1gKWGVidgVjIoMvInYa/mQMzDWI2CxNClgZhb+YthoKxFuZobmRf4nSBCq8hRl5ADchQf4gAyqNUFOk2AdPgIOnwIAcQCBzqnDqkHTq8zgEDjkl5jEVRWGsIMZaOOSXmUXkShwOKMvMilaMFjLKoVM7NItGTp5GhlJspRw6pw7UpHTq8zg5hoAAy8gBeQ4oxAAA5kAJ8AHDQGOKdJQDp8BV5jEAOAGQwAdXmRQvMYAMtAcDqkAp0Dq8zKmAACmXkdA6pFCnQOrzMhk+AAAAOcXkdIAY4p0yAdPgKvMYAAAT4GWn4/fzC/mIB+ofNPfzGsSAB7+Y1iQAVsLfzEOWApfzC/mTsdLoPfzC/mIBA9/ML+YtgsA1/MaxOwwFLC2FABrDWJhfzApYawgAPqfkLCAZ0H1PyFhANB7BYQDOg9hr+Yhyw0KXC5Ox0B7+Y1iQEFbBYkdsBSwWFv5i2AYBbBYBgEHT4AMvI6cXkdA6p0Sx0mh2wWOAAx2wqnSLDjWJqwxFUsFiYX8yaDWCwoFDWHJATQpYVuQWOkCANUKmgog4gFVYLCp8AApYZWJryHMjthr+YgAOMvIUCClgU4BkMOIAFbHRBzLR15jKxNRl5maq51eYqgrEWLLyHEXkOYaKSaO5apRY/ZjehjqdKtyFKAACnkQCfAcDqgCnQOqpkMnwAByNA6qgp0yA6vMFUYAHOKp0yA6oKdMtaA4J8AMqBzi8joDAcU6ZV1eYwAGgOcXkdMgGOKdIAcVeYwAADLyA6AHVMDoAdXmGjAAGQDiJ8ByD8XAQD9W+aax0QAHOWFABrBYW/mF/MBrBYUL+YDWCwoBnaljpK/mNYGjgcsFiaaNY4ADSO2GEAiezgABo1gsKADWOiAA5ywt/ML+YDWCwt/MAHAQAHGJDLyAawWFsFgGsFhbBYBrBYnfzGXkEOdXmcAypwEAgcAv5gAy8jpxeR0AO2OARdmO2J2Cw0qlgsTsdGg9jgp2xA1hr+ZOx0BxxE+BRTAKhUZVGp5EE2UjU2VM8ilCgAy8jQF5DijGQAB1eYDAAAOADGAAA4UJ8Bzi8hqmVCjLzOHamGlF5DKKvIZQ0svIZSY1jAovMuZlYpfzMWLE5FJv8SojKaQo4HVGwKdA6vMgF5jAMvIjTp1ToGQHVU4OFAy8hRzIBhRjKg6vM4OZUAA4UHVOgZNA6vMF5jBoAAy8iDoAdUyOgA6fAAAAJsCfAc4vI6RoDHFOmdgHT4CDkAAAFMvI6IF/MzV0/FbHAFP1j5btjooBDHLHDlgmzWOiWCwNnAU7YG3QOWCwNmsNfzJ2CwNqDWJ2CwaUsdJWGv5gUsdJX8xrBDnbC2FsTSqWCwthbDQpY4JY6VDAKBNMmA5YLDSmsC8xbHRpThfzJ2Cw0no1gsLYLDQaxwU6o0hl5jCrzGI2cBL+Y1gGsdEsFgHO2J2CxnQtfzC/mTsFhoNYLC2ODQYDlgsBS/mF/MnYLAUv5i2ODp8CAT4FFFXkdMtHXmWUivMovIzRZPgUUmrFFY5hqk5FKLzFZSRqo1FqWZSdTbLgABR1eYwAADnF5DKZHQAdVMtBVGqFTpFAxxRqmFC8xhlUaoaKvIZTh1QKX8wEOrzMCi8hmFXkOSrAB1uZwyrlTp2oVAF5jANUAVRzlRqmbVFThYiYV1eYwDLyCugB1SbHQA6vMyGT4AAyqFC8jp1Tplp1VOAdXmQMAAZAOcXkdKGAAIunVUYAMqAAZVIOgAxkAAAAOIBFOBOwWJpVL+YthbC2GlfjByx0Q/XvlAawoEZF/ML+YrczhUPfzC/mTsFgKX8wv5iAQOAgFDjWJD38yBztiYX8yClgsTC/mBU7YnYLEXawE7BYNKX8wv5k7BYM7UC/mTsFgbNYYQ5YG1L+YX8ydgsDal/ML+ZOwWBtS/mF/MnYLA2oAgAWGJX8wCqgJYawFL+YX8ydgsZU1gsLYLF0zs1gsLYLDTRrDX8ydgsQUC/mTsFgKX8wv5i2CwFRiV/MaxA4CjGR1WKLyJrzGT4ErSilE+BNShiiysNfzJDGRWw1iK8xjKmbkFdgVKKpF0jQE+BZlIhAMvIKjmlAHVUYyCnkMvIVPgOZUHVBRl5mWhUYACmVhrCryOmaA6p0CAHp5ANUAXkUVhDqmWjWBVODkFFUVlGUGMNaKqlKiqUIBVGbkdONyMKV/iADVNBaeQ4AZAMcVTpB1eYwDKpNroVHFGI06qjU8hAM6HajCDgAAORYDqhU6RQAAZHV5jAAAqjgBkB2xwAO2OHLBYDoCX8xbF0qpywqfAVuZFpr+YCAXSPx0Dljp+sfMIAzcgqGdJtzOHWUVgOAAwQp2wVOAAAAHbBY4BR2wWOAQPYLCAA9gsLYLAUv5i2FsLYC1/MWxOwWApYa/mTsFgKX8wEAg7Ya/mIBQ9/MaxGx0mhWwWJ2Cw0KnbEbBYaFrDWI38wv5jQtYLE7BYyqlgsTsNYG1Av5k7DWDRr+Y1idgsA1/ML+YtjgFbBYnYLAVGJJ8CliUdHVidjpBVeQyk0+A5mh15lF5E15jGGlFKE1GXmYFF5DiLyGsQMvMYQ6vMyqi8iyEV5FkMZNqVuTaE0IW0/yZ3pWFY2G0T0I4Si45n5Nel6vLWFnCp62iYZsegxz2a0gdqdA0OqowAAAA4AdVQqMqmAVGACLoDnKjVIroABB1eYwDKplo5yxwDNV1WGsKp0ge/mAAQMvI6cXkdIAYAIvoDgMvIlUKp0AIoGFOqRdOgB1eZlQvMYBlUAXkdACbHbHQAyA6vM4dsAwC2CwDBfzFsLYmmtKX8xbE7BYopYWwtjoHbHRLDKFWVdgrKUsLW5z2IHLFK+z3CHQfjgAOfqHygMcU6AolPIqAEqBQqdqa2I0FZS1RWUbEahUoyi1DOiAPUKlNEAeotQOAAGkAg1hSpQLYG5nAjtgscOWCKX8xrEbBYgtYLE7BYmlWsLYnYLDS7UsFidgsNMqWCxOwWGmtqWHIWGv5jRtSwWJ38wv5jRtU6vMmvIaxFUT4DWI2GsTQpYLEbBYaFrBYjYLDQtYLEbBYaFrDWI2Gv5jQsrDX8yNhrGWlCisRVii8gqlii8iRVeRgOOnwFXmMcmjjrzFUonwJQy8jog5GjAcUZeZkUXkWT4EV5DWOd8tNUchoWQ89ZC2oYaeksilFmPJ1nG7Q3mcvja29TU/AsiqxhjmNUchOummORaCGuRd5nZTtLtzFPIKeQyqOTYAAdPgGhTyAAp5GQDgdUyCp0AMtAcAABrCjmdqDtQqdABwAigaoVHMKAAAAcVeYxlQNYUAujWOiJ8BzKgY4p0gBwAgZeR0QcgDqnAIrtgsLYLBo1gsTuLYopYLE7C2LoUv5i2FsdGh2wWOHLDQaxaNSBVWqQNUbpJ6n4FuZ0LWGVjPcNYmhoZifQR1RWmHWj8jHEVhz9U+Xp1TpxRqkquAdqFRscO2FqdKHAVeYwC1FaMtUKk2M9QqWp5C1Kmi1FZSlQqDTOynC7KTZTW0sRqKUZRam3MohWotPIomxwdlFqEcA7U4EAAAHLBYKilgawWFAoawWFv5i2ApYLCgA1hrEwv5gWsFidgsZFri2J2CxdClgsTsFhoUsFiN/Maw0LXC/mSOqZFrDWIrzKLyI0pYovIipRWM1qKKWXkZ7FFYy0uOrEVYovM50WVil/MirDmWlVYorESimKKDiX8wv5mW1LDLzI38xrEGix0grFL+ZgNYaxMcimOrzEHXmZaWjN0ZjjU2Q8znk1Itp3jMskZuUGU5zLTTz1OjyLQWp02y4OAEAOcXkdI1oHVOHVJsdOrzODkUABRVIuhUFGqcMGgB2oxDQHET4DkaAwp2xNjoHLHSAO2OAGjgAy8jA6ADBQAAF0cBDliCgX8ydgsNKpfzFsTsLfzApYLE7+YX8yhrBYW/mLYCpyxOwuoBawan4M+p+AsBa4XM9/MawFlYaxn1PwGp+ANFg1PwZbi6n5A0NIK0xn1BdT8F0NGp+BbmfWFaQuk2/NhxDtj9G+WovIovMmvIcNHv5hfzEAmg9PIWoWGv5kC1GAAAawoAOcqLfzHA5UKnQASnkKylTjci7GfT/AAFS1PIKeRRFoybRmiotSppnqLU0af4FaMsyjOmenkLU0af5DT/JvaaRoLUtUKk2I1JspZlFZTTKIDVFp5GkFPIWowBCHajDVNbUoDVFp5GQAArMEMLY4BrQ7YYQAHAWoxAy8hlFVRlM1TLzKLyJDp8CLDjCjrzMKYZeQoyqYbUXmWViKqUXkSilhlYVVKVObRlYorCHV5mRcDinTDYHVQGXkZDKMrCHVIKALYYwsNYorERrBpoWQ0R5BhViisYs209BcoouUeepZeRzuMa20M1hQQoqmGkwLaf5JyLQbTWgvI6cXkdAB6iqUT4EXRVUYAVSKpGtyiqNGuwoqnK5NaTVRWU0KosimdmkQKKorLU1s0UawNyFG0NY6IMvIi6dGFGIoHT4CHV5ka0YcQCKcBL+YX8wmjgSsLYKtYW5OwtgKWCxOwWAcBLC38wKWCxGwWLoU1PwLfzJ2Cw0KX8xbC2CxoNYLE9T8A0gFLBYztIK0hdJto1BWkM+p+Cep+S9TbQ0guoR1PyLY1plbU/AtydhbGtC1/MWxOwWGh8HU4OB9x88tg1PyM/xEAe/mNqfgkPTyAorHRF5DWA6dsLYLE0KATsdIHAAAL+Y1hQAawWFABrBYUAAKeQAAU8hajX8xrAR0w0y4F2M2n+A0/waKhUbGNoxdM2NGLp/kvb9TTGyi0NmgGga7xnqw6f5DSNjQi0Ndoday6f5DT/Js0/wTaMdomqy1OGloSdC7GcCzKTZTbOi08hajAGS1GACgHEGVSKZTp1VGVTDQp5DKoyjLzIoVRlUKeQyqYaMqlBV5jGdtHGFOqQMvMspNPgUUwOjp8BVUovIw0ZTpxTphT38wv5iAQPfzGsTXmMnwIHO2OAF0deYxNWKJ8DDSilE+BFeRReZlpZS0ZnXkUVjF8q2RsWVlPPv5jLIctN7bmkJyNcirFSNOLyOgdUBl5lFUFjKVOfZdJ1NEcYqfAorKYtWRap0lrINrGGziP8AEXU/I2ogADKLdAsArKKylLB1FREc4y1Fv5lNHO2FsFiKcBLC38yClgsEcdylak2I6n4CwsmyQQ0Hv5jVJ2KWICpTT/JNZBmmAWTYTZhWaxNlNCmoLYkdsbRSwWI2BpAaUv5hcjqfgVpCotqfkVpDO0grSGuqNGp+CbSEbi2LoW1BdT8EbBY0LWFv5k7BYCl/ML+ZGwWLoUsGp+SNwuNClgsRsLYaHyYCAfZfPdscAAA7Y4ADqw1iQ9/MBrC38xbHAK2CxI7YDRqfkLoZ7BYDTqKcsZgA02Gv5mNWYazgaNT8i6hnZmCzAaLFE+BjViiyAaAJrICyE0KAKzCtINCgEdYZZBoUv5jWJ2Gv5mdBwEv5jWIOnKnQG2tEp5BTyHAbNJVFaMuI/wATW0Y2jJtGbGUmynTbOmFlCpq0wqb7saZaOFTVUVlL2NI1GVRgCCnkMqi38xrGaKKoyfAjqfgZZDLTQrBYjqfkZWMtbUsNYQ6oVS/mOSVSyqZApZWFVRrGLVUXmUXkR1lUO0+Zz1Wmk5Yj2qxSOZXJZVtOByyFLKZ2aLU4caagupcK0VOkNcFYitCqUT4E42LWQxfFAqlF5gvMoqmHTTp1QqMqmFMMqgqjKpldKKo4gyqc29OjrzFqdMqrqfgm2RUzsxFmYsx2m2zWcNQzrIK0xdfhtq1xlkY89phlmYdKm27U/Iaph1rjKw6aXbdrONrOZU+Ay8jOlalkuUv5meNhtT8HOxpq2shGxOw5FOLYF5isrEDLvLKq0M+5AaYSbFtam1RWyjK0xGTIU1MEamyrhrHmyZioT7d/5/kdOn4z3j1Lk2mPPjymc0LYvTXtZlto1nFuxOwuoTStGoLqfgz6n4FuXqNFxdT8mdpCbTGupts1PyK0hjuFmcvVGhpBWkM+7yG3F0htT8BYnY4UWOdRGwy8yhmagthmUmykDWCxFrILZzWhawtiR2xrQpYLEbC6n4Gha/mFyLSE2kKPngOWCx9R4PDoCWCxEOByx0AADq8wOHanBwFqcHABDtRqeQ1QqdQqUqFQuk6nCtRwaZzjGioaYRA6qltMaotEasC3LVCpNrpPd5isrGinkLUbNI7hqlNP8hp/kbRwReRagun+RsLqDan5JtGLpuVGi/mFyLWQnZyaGxd4WMqyMg2p+Cda1tZ/iBOwfNLo2oKyjCENOaYrRlFYa/mXaM9PIi3I1MTZTSM4FKityN7Y0m3MLAzC2NMqX8wJqUT4AUUZeZNeRSNTnXSKLyHOxqU0TFulTViisLQJFIGaQXUdhDtQGKLHcVVN2PGveOeV01JtOHBaXpLLw1l+Ybo6pGOee8mVdukYOysvUNpGyoaaGe1Orz9FwaOh6GmgNCrF7nV5oKx6XZYhuzxD5IdWOONnNUeKU06dIy3M3JZiouPQZYSd3GWRjjdumotp0GUmsg1jNVSpRVI6gyzKZ1tpZVOkO0INrIY66FRGW4an4DU/BFTaFvqGdoy0kxnZmc7Yys1NrITsxRlZg03Om45kKryF0XKLGw3F0FKKwLCUWM5dm9BZBtT8ndNTtVMN6MrFF5k1YNT8GFaF5BYz6n4FaYz1o1an4FaQytMRkmNTCo1STGeTIM8kxNpDtMIzs0kzORazjWF1PwdZ4YL2dnGXHqGsLrF/0mo1R1U2LIp5OsMuQc7jbW5dPQk+0ztIKuRcVt5JNRrezXCzOLu8g1PyVBVxqCtkVItmF80aKDbfMw9uZybZRelqdo9KyoDTKeW2YHavyX46d49BajaiHnrmCtmMXpTtG5mUXtBjbIZxdQvT9TbZ2ryG7QvkeXJIKuRQ18cTs9bUV9wsjHm+sKE/WFy/HkvaNzTCtIZda4a460aLBqGXWFaY11qNWp+BWkMrZBNsg10qbee3IUs3MWp9B40wGqFQFGsMsY2n+TIWx07p/kahAgDrGUWMgmnwBPgW0/yGn+Q1oh2pSgywkojU6X0A0CCNQqaOzguOBGnkFPI0LCU7OQ2y1Cpq7N5Ddl/JNm2PT/A2mauy/kbsvmDbHphpmzsvmd7KxkYtMbT/ACauz/8An+QaLk3GmXT/ACGn+TRosg1C7Rl0/wAi9nNlVDaZ7Kx9nDs3kblVXDT/AAa7VdR58mO3dItGx62iK0JqZ2MaeO1ye89ZowaNTcyZebrBrGxsNXItgl3iI3DUcp2VkG0WG8RGzBuLaf5OAZmYizGiRibLc1EqRypSgUNbY0E+A5zRKLCS1vRVGVSmn+DphXFsao5GIqwysZvlqKbw02YaOQ1RscrdNSbY1x2KLjm5WGOdzrXWMawt9MtGtTRYLGbltdGjYawh2xybUv5jWJHbBpU7YnfzHA7Y6cVRqmGjDiU8hqko6dVSdmFaRhpFqodMjTMLqOXrU20X8xZCO4Xd5GtJ2WWQZcqhnqMqsXUTbR2ryO9qYgqjVYz1jW6p2hxlmI1CrDrDbUsg1/MyHLE6m2y42p+DDqC6xOm2uz0NVQ7Qvkea0xPXL8TPd63aBdY8vtC/8g1kHxHf8et2hfIXtKHktILcvxHd6zZSk2yDzdS4XL8R3ehrCtIphuTaQ18bPZuaRSbTKeezMTZmOs4ozc3odoXyDVU82zBTyNfHGe9ehrILrIY9P8Aqj44dmrUUZZDGqlF5mbj+NbbFYorGNWG1V+oYuDcrZfzFaShn1SbTE6ba76WaYi0xNpmItkHTHBz7RRpBdS5HWcXWOkwrO1r+Y1jK0zE2m/UNdKnZu1PwTaYw636grMWYfqd/xubKFbMMLE2ZjXxxO9bpMoztkMZWkItIdZxxm5Vsab9Qi2RT5hntcZYzp0kY22LnFFzGcyxwmiOOhzyxkblqmszBZgT4DmJNOiVjg9PIapUW7P8A+f5DdnXyPSbHJtCY7MaY+zr/AMw7Ov8AzNWiwumw7GkezoHZfyW3nRaqHY/wL2M1LINcm02x9nb/AJhosps1htT7BsYasNpublZvpjKspnvFYdBvpjLC30z0FWX6ZRY270ZO483TfwC/5S+A9hYb9wZcUz3jU8PFZWCNWPeXFBsVk6Y4x3ivLVvFGUjjR+k9aHHXvB2WBH2nO5prTy2hlXp6Ceqep17dMVuDxZEm3U/sLM2tT7YWmVPlirkL3oz1P4ZbuyGf1Hk92jmu0Z1PpNYdXcvQNoqnU40nDczp0P7CLYM7dWI5na6U0lBscZeBy9Tacf8AMNE3D2xYI2mkui9wzcl0wrGr7VkFbFBspu7HGUhbGyOqOj/qFSxHs7d0NN/Abl4bBL7uQVuAzqns5P7x3kTTGyt+mKyymj1LpbpN7gvC4pdyxv8A0GplE0xtqoKzSselHw/S6uj73Odl/ljsPK3eQtmPYbF2WWPUcxyRtT2kkaHSXaWMN2F1HN3Y5W3LpugerW7xvtpJjthv5itU2SYapt1EFbBYbNMrVIyVNjYrE2x17xZWWFlUWqmxsdRey/g2MtPIKeRq7OLogZxl5GjT/AaIEVGqU0Rlx2JtZNp08hlUposMsZjalWMouwNP8DVM1syyDXJ1CpjUVZZhtcgdXmTrF20LIUWplT4FTHVva+w6ZlUonwMdTbQnwGVjOvIoqk01taw1iNPIapk2rqKUIVGVWJpTDnFViiqFTVbCtCpoT4DVVzO0Z6oCqpo0/wAAsY2mkaoLp/g1aYrQllNMum4bl+WatP8AAtPI0M+4GYoxnYrIZibSFFJv8TUjKbSEWkYJCbWO0wjnsNMRkyAZWF0/wdesY2XWcpGzOTp5FFVi6hurLYcSO5RmY52NwVf6YM1Q1SbSKZ1trcg1F7wupETZVfpBYVOvVz2Kq/SK0LFo4VT5e4tW/wAsgx7V6immtLKbNFU3aYu1PkRkVj7Pf6grRxL9Q3LkMm3TjBsqd/ABjjht0xyFNHxSUGkx58j5gsfDvEXcU3Y9WPa9xfV3kaljaL3YajLuOe7fTTC2H4pBey0+ZIbsjIVo9uxzLJNP3dhuImysvjFZb9wP9T9QtHJL3jbDHRxWVjVIy/T3kd/0zcEW5i1Q0VV/ljaMXeKyx1JtbuxnpLjqwrYK90Sjy2t3ow07/LPS7PTb1jdlsa7RNPJ7P9gdjVz1Gw2QZcMd5DTyexqMuPT5Z7S4NzRHw9TN5FmO3grGv0yywr3T2vVyjLw9jneR1mLxVxSy4p7S8NLLw1TneVvrt4PZyi4p7y8LUtHw1THyz9XpU+x/kXsZ9I2CTbBOPyM6r53sf4Dsf4Pebh4vq/8A4FnInV4vq9BvViHtLgjLgj5TrHi+q0D1TGe8uCN6v8zHyrp4a8JUZeEqe4vD2G7Cxn5WtPHXhqqWj4eesuCwy4LHP5Drt5seH+maFxf0zZ2OVA7LOX5qz0Y+y+GMFx2+mbOzy/8AMNOdTPy39Jxs64vijLdhi0/dllWdClsr6Y+eJcGHsMSbtDYNqQfT3nodqn70YrZF+qCMXln0dLfacccTR20w04n26ZbtESJ7sXtSt8sf8ir8URkwcZ+qN0Msno3jSx+zkdD0FyIPpjNlRJ4zPzb9tfFr1Xjw+i8qfP8A+8JPRvO7uWet25U8ZSPiESbmkJ8u/azHJ5+LwefT9t7d/vN3qfVjrJBsNnrRPsLR8Uv8yM3OTGOOWHJfp4s3o/g96ChH1Pg46ez2fzD6RspW+8wzVbqjM5cu/TWPHfbw5uDrL7mSn8tAXhsWOlpruexqLFtjjKKsssf1Djc3bTw27Dj9UciHnzZHD32tG6H1UmHLPtaMj6pi+dJHU3OQ6yPi5Mrh+pXQd08bmPIk4Z3YJ3/rPssjgODL0yHj5Ho+q9J7OPkxrnlNPFjbDl2tqYv9ZGTh8Ce0jz7/APzPU9SB6kO8zm9xz8vFZp+7OaMeRn2ySXseh6n8wXhaoW5ypI+fkwfae7NC46yx7tdEPoJMdZfsI9lQk5F08OsWFH7yQxzLFkblvc+obFgb3nR4CcnC8NumPTNzOQs3HyrRsLZoj6j1SvdFbhbU94b+WfbPWvm2mYFklPe9Tk24PcfJida8+ON36hdf9M9D1GyeMpHwH9Qz3x/W+tearK5Sp6HquCLqu43q+J+mOQzc4sxrzd3mKzN9M9b1av0ybcNVenYTvF1Xl636f/EFkic9T1f4jO3CVXpkL2iarKtW6RtP8Fl4W3Usger5PGNwT0BlhGXFYbRZekjRdEbRKR6qdW8tb9P/APUxarOsYyxmxY7leyqY23piWMbTNXZyi49/mE3DTGsYywsaqxL1SDK0HTqGdtSM6wlFhNy49hlhoYuS6Y1hYOznoLDQGVU+8zaaYezlFhNUdZekouOXZpj0xljN3Z/ETaSKL7/5ZNtM+iGibO0Yy9UlAhaLK9zJcxbYdYwtCRkhPYbF/TIti/plmaaeO0ZFoz2pMNXFbh6t9Q6zOOXWvn2jF0/we96rVunUuTbgs/djOk5Ma59K8NoV/rJtGx73qOdtoSejuUvTGdJy4yMdK8NY77SbYvdPYXhM/ejo4smDLqbox8slOleT2X8B2P8AJ6nYX/5lF4exr5J+p0yeT2eg2ke0vB5X+WKvB5X+WT5cV65PJ7PY52VT3YeAyy+APUtNskiJ/LJOWHSvC7KonZz6KbgbRbo98RNeCs3SJzQ6ZPFWEbRVD2vULfMkoNDwCLI3R5cc9Pli8kOleLUNM95uDwJBIzRyQOp48nFsPF26H/UkLjl2uolx17RWFe8U7Krlo+PRSx1aNHT9Q3Y+DBnwSTY8mjTruMrpqTbz1xVGbDX6g0nEMbF2yRvP/LMrccaWdFhg9k798ebNrvV1TNj0M7Qse9GuHkSVXTv9MG4fFp7oJMVyTLXtesr51scOznsNCvS2JP8AvjJ9nw3065eg/wBOQ1OROv8A48vs6/8AMNA9r1G0vu8uB/sMrY8uBP7aAvdNV5rY5PSPUkVZemOjkWhb6ZvHNi42MLYqi9nX/mbmxxuxl3+svPqydIun+D1Owv8A8wXDNdpF815umMsbHpLh/pllwTFzi9a8tccouKp6y8PNWPwdpTjeWfrUwu3jx4auaFwz2PVOkUj4ecLyz9eiY14vq7yNEfDz3oeE23dAzYNDheXbr1/XjrglFwVPWjwWb5ZReHsc/kaeSuGWXFPUXh7FPV7Ge+xo7H/w+mL6vQ+o9Uj+qTn2rhuPlPVqh6tU+q9TON6lYbyTtHyq8PX6ZReHr9M+m9SsUXg7F3mdsHy68PXwFl4ep9J6mcX1YY/0u8Hz/YU/5h2FP+Z9B6sH9WE/0bj57sKjdjPoPVp31SX/AEdo+e7Go/YT6H1MTk4esRLbInePB7Cn/MGw4k6j6KPDg07Mebncc4VhbWkjuXadt3UZV4X7O3cGj4bFLt6Dw+Ken0uLtxcTYTw/8Rp3gkbIg2fYdZNzbNmX2+kbgbp9/wDLGj4Hq9UdD5/hf+ImHr1yo5IIjdH6VcP4u9Yc/KRFf3knQZtkXWf09CTgvd0Ogj6jidLaEf8Aeav4s4LhJ2fIz3yrnoY/C8HNxe1cPR3R/lksn0zMsvWTwf4fgl92iP8Ay5CM3A8aLa0ciHvfwzBlSafZJ8VPHA56WD6M5nDY5I2y+1RdzXJ5t9eFy5Ot9vh24Phk24Ph/UPuOxy6kjTQQJQ81uIYOpXI0PsjpvM7rpMt/T5X1LjdSll4Wq9OmfVZ0fBcKCPImjuj79iHkzcW4RLJ/o9D+vY5Lf8A10xy7fTz1wVQbsf5PYxcGDMTbHJb9OS6Fl9HZW6ZJET9Qxvd1G/8z28Fsenyw02TpPYb0fn7s/8AeRm4LmRblj1/5YuejxHlyavSZ+zs57TcDztO2h//ALmeThuYu5oJEQ12HkthkZMU9JlYXT/J0mada8lsEVuHnqaLJuFaNjpORnq8n1b+Sfqm56zRsLoub7ufR5PqkX1Oh7Gn+AaFi/IsxjxfVKoc9WHr6f5FaFu6X5KddPJXhoLwvxSHqUYGx2ctzTTz/V8SoK3D4vqHodjsHYTMzb081sFe6L2M9b1f/wABfV9dxPkNPJbDUXsZ7S4JReHrpl+Vrq8HsYdj8UZ9B2H7BfVrMPlTq+fbDuK2Cp9F6rYn6v8A+Br5DrXz/q//AIE/VaH0jYovY7GvkOkfPrwtX7gep0Pouy/gGwyfKnT/AMfOrwtfplvVq/TPYaGgaLC8h108jsK/THjwV+mewuOveKLD+mZ7rI8nsq6e6Mj6rgeT5h7nZ7ho97TMTPQ8mPheN3o7llwcaLpjjPS0+6sYvZx2tV5rYsX0xfVqvHVug9RYV+mNooW38Xby14PFF09Yvq+nVsf7D1JI69JGspZdpctMLYcvy47k5pMnFj3YH9h6yrKK2r9Qsy/UteDNnT/OxJKFFyMSlVun9B6zTSkY2li6Trti5aefI0WnaSB/7BcXMWWT2OA9PqGyaadyMc0sW7Up/LNa3Ge3nQbiUqPXsk6J+oHriu3sjjNxD2dWju/6hnbiUqx1WOMnSUvJqt2PlYeV1akDnoRwwRJbUofPrxaf6cEiAvFJWf2kEdPsMXirU5ca97Wgi3NIhlbiWNK/v9h5tcPK6o3gcy5nDdKTbPrlx4/PlMuXT1pPVU7/AO/kQ2R8BnaDUweJyP8AvPmY4Vi6oz0sfizY+np6gzw8eDHkluq9yHF4rA9Zo0nQ3djWXqjjgc8OT0mzNCp4M007z62pIjnGcWV+2rySPvF4TT5cbg3D4G+nc+L7VxOf/wB27oMs0sT+0kdzPxX9anJJ7fVTYuHBtaSjgvCdXdHPdDw48iJ9unvNkeZFi7lkuW4Za8EylelJwdWg93vM8nBWTdHidZ5uZ6aZWOnsY0ueLxL0wzs1PeUHHx52sZcmD6pY5cDbNG//APYMuPFn+7jkgufF4/pdxqKPTWTXT70uUyOMce4lBtgkRPBHsOmXHq7XHOWPouKcJ4rhwSVTtSHg4a8X0JFh4TJs+Y5q4Hx7iGHPHHnZ8iRfqH1S+kmH3uLJ/wDlmJbism3wORxjicupDkbPsdDz4/RfM4l7SHQ/lyOfqUmRwj0t/wBK3X3J6Hl5n+GOZBuw8u6fqHXD+iYe3DPi7Xb4NfQXjndxI/7z0OG8B45wu7LibPAfSY/of6RxbVkoi/eao+D+kOBJG3v/AOsuX9UyXDj63b5fimOuUlm4a6ZHfoh5MeDLLJpxyJA/6h+lYs2TxaPTmxKS/UJ8Q9E4GTUmxHv+gZw/sxx8VrPh7eX5/D6Izu9l4lBq+C5o9bZ3C4+y5Ht3R+/3D2pPRNtS0ME9DLleied7xsSejHf/AJGGV8uNxyx9F4PxqXMerSaCfqHpZ3A+EZ6ak06JK3zI5DyV9G5enTdCi+j8sXy5DOWfHbuV1xuWvLYvobhokbYs+u79/UPSweC5MWpDnSRvF3Dw8fF7LPZdji8QyMnPerT9Jz3v7bn/AOPcm4TgptbTgT6lxZPRmWlo/bxN9M+ZjwZb9+Q+q4fx7MwoI8dsd6J0ahnky6+quONy9Rl/hed/kU/eNJ6I5MW736fpn0XD8yXMjkabUSp6GHjtE+tHlo8XfRzz5f0ZS+2rx6m3wq8Fr1bDRHwWx+gSTYLyVaRJHYpkcHgeOyx/2Gf+TlfVZmMj4NuBr1KNDwHVPsvVP/HwA3B1c5/8jJuYR8nHwWJPvKLg1PqPVMXdkKNwunSYvM3Ji+bj4bfqKLw1fpnuNgsovZ//AD/I5zOus1Z4eX2PulGwVfqj3npLCUbHJM9OdebHi0KdmQ9JYw07nXHl8OWUu3m9l8xuzm5sWwdjL8n4dX0HYQ7GfXer4xW4ep3+OPn/ADPlVwyi4p9I2CpPsdDXXS/JHhrijdjPb7KpTsJZGbnHhdl/JPs57kmCxhyIZYuk53KxrH/TD2dxuyN9MjkNmJ0yGVW4h9c4X+ibdZx39epHg+KMo2HEnVGefC2Z3p4xczFnyk/3caG7z6Z+O/degqwdKxnh8ahzP/bwXCP0fyert5nzsPMWPTXP2nK8tz8V0x4+uXivDmweIZvs5suOD9MMX0Dxkk1MyRHJzcBiR9STiV5f3jY8eN0zSTznT1NPRr8r0puA4mUmnoQTonR0mNfQvDyH0W4K6ffHUabsfDZ9THjv/Mcw5Hphxd3tDponcjNY3NnLG/T2Jv8AC/hUWmy4E89+veaI/QPh6Rxww4k+k7747nk8P9MuNRQSNJOj/vFj9KuNIlteN7f9hm5Zb2544Z79vUzPRdceevDcTEwpfqSJc+V4kvptgZenHkJpdzQ6D7LD9OMyVK5GIj7PeGxvSbBz0jjkgkdOjYhz76+3Wdtf6x3H5C2V6VSzzyRyTzzL10c+09E4/SiWC008dJU93JJvPtsXF4LK8a4+IidzoLZXD8Ph08bRyQI7/UcufJ2n+Wd4784+XwMfDfTNJJ42kj69mv8A/wBDDxhfTF8GOuAmsnW6JvP0rI41wiCe0mfA7/vMOZ6bcBwp9bXku5zlyl3tqZZfWL8h4Pxj0q7U+nHl5T9DpOmw+2wZM72cmZwnBeX7HW56n8fcA15GWeREb5dD5viHp9w/Hy/9DHBs6HfrNzK5131L7j0uKcSzp3jWGf1X+mkG8+bzvXSajY/Gp/2SJQ+oxfT7DyMHWmjjSnz5DDnf4jcISOSOSN81/wBBKG+OZRdYyasfLr6YZPA8SseembkN1xyJ0Grg/wDidmPOi50aU/QMsfGvRziOXbO4FHBE3zLlsf0y4Lw6SSHD4FAmOz9bnty4pl6jj8k37elxTFzsp5OIcL41dOt4PALw/wBKsmKSC2fr796SBlelno1B7TQu0vWkAuD/AAnmyRzRzvA7fLkPP8dmPmO1uOT6xuMYMqWaNLk42wc9/ZvHA6fUFw14e23Bkgd/AUzuGxI8cmRppEfP1ca7dMfpRuBs/wBNybcHr8sMGGCeO2DO9P1DVlek2DwT2eVl7/pmblnvxHO4eNvPk4Oq/LJtwleles+ixeLYeekckM6OjFpJIKWbTMXkzx9pMf8Ax8n6lv0yGduEsh9c2OuR0kZOFt9M6TmsOkfJtw2hP1f5n1DcLb6YsnB27p0/5FOkfMtw9e8HYz6b1DK/2E/Uct69ojuanNcmekfO9jG7Oh9A3AZ06pEJtwWvVOhr5GukeL2VXF7H+D1JI8aDqy0/6Yq9jfpz0/6g71nrHntijLhnpLDA3TnwFo8OJv8A3cbkuVnlqY7eP2P8jdh/8/zPWbh7N0zoHq2XvSRkvI10eP2GXuitgynueq5e6DcNb6kZn5tHR8/6vlb5YdhbvHvR4dnqs6O5ZuGy/UjF59fZ1j5vsX6ZNuHn03q+f7KDeq26Vo4nNKdZPb5VeH3LLwlnPebhct66H9hReGy093IavP8AidY8H1Ow3qlv3n0HYW70bjLisnVHIcvmyJji+fXhbfTGXg7H0Gj/AEC6LN0ic1XpHz/qmXwC+qpPpn0WiyjKrGpzX9OsfM+r2TqjItgn1irba0YLiqxqc9OkfJtw1u7GRbDb6Z9g2Ov0yLYbP0xnSc9c7xx8n2NmDsv4Ppmw4vmbA9TxSx2jkOvz6c/j37fLtik+w/8An+Z9N6nbU2itwll6ozc5ts/HXy7YNybcLufWeqe6T9Wsb+bXtmcT5FuD/pk24P4T7JeGt9MVuHt9Mk/on6l4nxvqCX6Yy+jrH2C4bJ1Gz1bK8dhl/TZ6qzhfn8nA50+WHqGV9p942HXqjFaGPvSIhn/k5LeLT4eP0Znb9hb+G5Yj7Jo1iFjZdT3ewnz5fSzjxfI/wzO+0P4bl7x9c1XItpKPmz2nTGPmW9F309uWY24PpSbru59NkZCoZY+JNiz2043r9Q7TLOwy6x8zlYcq9JPD4PPnvGs0nZcfdvPoOMcWXiW7s8cD/pmOP0inwNsMcb+C56sbl108u5K81uD8I6cifOfI+xNh6EPAfRWKD/Udugfx6hnzPSjO4jHp5GhS90olA4XkLr/6qPXQvnRMsd+miPI9GuGp/o4Mqd/qTmrB9PPaabQQQY/7Og2YeDwHT1M7UfwJGY+IcP4GvtoY6U+XIcu1ydtdfT0s7ino5x6COHIg7U/1II6Cr/hvwPNg1sOSfFf9c8mH00yeGyVwcDFSJPsI8Q9NOL8R2ySUiX6ZwvFn9NTPH7fVcF/w5nxZ45u3xvFT5Gw96b0Vyaexz3/6h+aw+nHFYo9FZ6Y/0z6TgP8AiFLix6ckev8AzDz8vDn7rUz36r6yPhuSkGm0iThj8Nnx5LSRon9Zo4T6RRcUjs0ccB6mVw9c+DbJRz5ud1/+t6yn/b081cFciTbQWbDbF+Q7uZf4ZzoJKw59EMuZ6P8AEEktNxamP3yYZ9r4b6fletHaX3mJIhnx1gikk/089/1Dy24TxzAeObDy/WMTmzH4xxCCSuVHoOn1EOtzsT4/qXbZXGypKtiSf1oNkcHw+lthsh4tFLH7SRDLkcQxZdupf+WYvPZPBjx5S/jKvo3wpNzR3cjJw3hS/wDtI3cjkZkSSVjkkuZ48idvlyP/AEHTHO11nHJ7rZgzcKikq2AkDnoTYfDs1N0cboeLJgz5EllxJ/7CcfD859sOJOb7XWnPrjLuU02Pg8Gy42hkf74yPrjGX2nYEdyOVwvOi95iToZ2hyV/9pP/AGHaSfZ7eh/E0HvJMCn8sx/xZh4upHDBO/7wx+H5OZJpriSX8FD0F9Dc5Xj1MQm8MfpjxBw/0kw5+qOeB/qHpfxFjRbffoRh9E5ZY7LHGiKasX0abU3RnHLPV1FmOOXmssfFsHPnq2I6feet6lWeO2POC+j9ZNvWetj8DZY47SfvNYf6/wC0c8+uP/W+XhtwWdffSbP0wm9H50S0e9D6SPha/qONNNBw7308aJ953mGE9uF5sr6r5VeB5nejoDcLnSSqxyHsZXpdwq+n2+BDdh8Sxpfd58Dl+LDZ83JJuvn14TOqboykfCZfpn1kmQqR+7u5jXiSu+m0dHHXjx82uc5eS/Tw/VLjeq2T5Y2Z6bRYuovq3Ld0+w+Zyv8AFSDH3TYGWiL9g78U8R2xw5s/On7F2f8A8/yDRPz/AAf8UpcqTdBRT6CP/EDhCp/qMhEc3ObG14sv5uTH3HvaKB2dDzcf0s4Vn7seeNyk3HI16Y7mrzY/qfDn+NjQqhOyoY4+LLPJXToUa5n5Y6Ti/WiyuTkw4pRaMTkkqZy5fDc4vys83o/FL8wyyei8XekNjZ1DLNxBmPDny8d9R6sePl9bYcj0ZiX5j/3mGb0Xl+XIepJM3VqE5OJaUfvDz95Xpx488ZuPncr0f4giezkkp+88HM4TP8yRz7JuMT9KybDz5JNWSzHfjvVd2zy+LbhMqbtQn2Ofp3n3UcixdMcDv956EPFsPHT20EGr+mh2vNpjT8/X0f4nP7uCRzdj+gPF8qCyx0/TkPsv4slp7NEQjH6TZzyWaRDlebJOuV/Hyq/4f8ax3q0Gw1Q+g/FV3acaH1S8azHT2hsjzu9JIZvPW5hlfx8/D6D8XeCuxDRD/h/nRR/7+NH/AGG7I41LLtjvQWGSeXcskiHO8sk1pJxct/8ArTD/AAHmRSWbPueLxL0B4hnz2ae59Y2LnSpWPLe5lyPR3i8se7LOeHJLdyNS2eLY+T/+zGVJLZE8af8AUNEf+H/BceS2Rl66fvPeh9Ce9nZ8n95ab0Z4UnVI7/1nTLO303jlv72+fb0P9Gsjpg6PpueXHgwSzvDi4HDeyL8ufr//AJn20fC+FYqbTz5sHgd9sCRv+81hy5YukmN+nzPEPRWLPg0eyYOLF9k5863oDg4+2bjSQfpwbz9Ckh4Qm7s6P/MPPyMyCL3fAo3Pbx8ucTLCZe3xsn+GeM8fseNSO/cPFyP8N+K39/AifUuffTZXD592VwnKg/ZsMMnDeAZCf++Q9vHzZybebLixr83yuAy8Lnkjbf49Pvk1hVZPaY8j/pn6RHwPgeVuWTOT+Ybm9GcalY53/rPT/wAma1p55/Pd7fneDxjhWLJ7bhs8D9x4HPcX044e8enNHPJ/MfefQSeieqnyKfUkMbehcHe0KHny5MM/p1xwzxY4+OcIngr2+eBDycxeA5T6knEsp3ue03oHh93LgQzzf4fr3Z0c1j8ePlMu/pPByOA8LT/R57u6fUJzelWlPVp0nTxxmiH0Fxv+O2aOT7NAMj0B4fp1hnngf9Qf/wA7fMT/APprQw/SxWn9nsf6iOesv+Iyxezmy96Hgt/h7LFuXPSP+YYZP8P0fUZeJI7v8uRBeLhzJnySbr6rI/xU0k9nJHO5jm/xe2R1ge/fPn4/QFpd0OfBP+mgTei+NgbcyTQ/+ZrH+fhvpi83JPNfSYv+JkGQ9Zp3n/YasfiWNmZXaMfEkj/Ukc+Vw+H8Klkjjx53u/1Eoh6HFPR3iWPiaa5CPE3cgMZcGGN01hy52PqsfjE+v7SRHrv6wh9IIMrU7RH2VF+oflrcFzMef22vA7/T6z0JOBwSpbK41JB+g+9zV/kxvmLP6K+8jzOGcSk9jOj06yOZxaLhvs+wa/3ng8J4b6t93Ok6fp9Z62jfbkTpf6ZyvD1ydfk3GOT0myflwQUX5dD2MfjHD8qCNpJ+y5HgPDyMFWn048uDZ9R6E/4frBrTZcaJ9m868nHjpiZ5R9pC2y0ckE6uWbIbvYDv/LPj8HgbTx2hy43xz3IZOK4senHPsU+blw4vXhnueXrY+YsEn+0nRzV2y/VgSOfM5HGuJ5EenoUfxmWHKzMCCRpJKP8AvOfwbaucfVLNBFJZcCjlPWSfQPiV9KMyLdqang1D1OF+kXbN2VBT9SMZfzWM48mOV1H0nalyo6tBOn8stDjxL0xuhjVm042jk2Fo5J3/AGHjyx14ejrGrWWL65ZeIQS/MoYZMhseCzRnhzcca+6OhvHiuc055yR9kq6vu5zQsbKm7efn/rzVk2yH0nA+JNSqyXQZcWXHNuPXt4j2KtL8uNCbY5o7QzdMdyyr4jzd1mHVhXHu+0nJizp0xm6t92ppk5siKJK6klzMztrV39McmPPpmeRZ0+XIbLTvt1HdPGNjrmLtZ0p+odpl+GtPL05U3aewWaOWXp2HuNqr1abhXxUJMsmpi+ZXhrPJukNSrLjx+8//ADDdmTY2P7uO8p8rxrO7Z7OHoU9fHLyeK45XHH3U+MenmZgZ0mPHAlE+YePH6ScQln7R2vf/ANhObhrS9Ulwh4XU+pMcMI8mXJbfCkmdPmz9okkk1T2sX0sbHSNcqO6fUPLXh7d00Nwt3j93qHDKS+Gpa1ZHpU0u6OOi/TKLxSkceVkR9fQY8fg86SWaP/pmjM4fk5GnaPp6KGL1ldJl+ozekUsu2GNET6hGPimSklmnLepcnuwFF4Pk/QuW5YJtSHjErx11OswtjtK5sXhOT9OhReA5PeOffCNatZY+04/7Bu0S96M9CPhM/dBuB5LmZzY7OteXNmN0qZWm/TPW/hvJfp2fzDRH6Ny96Q7/AC4fTl0yyfLzK0v2GeTDah9svoyrbSknozTqNz+jGF4bX572eVybcJZj76T0ZVOmQmvo+0XSbn9M+nG8L4X+H5X6RvUeTj7us+4bhsqfLJyYc6kx/o8nxafn8mLnNt06E/VcveP0KbHb95lbB8UZ0nNpj4q+HbBbujR8PnZz7JuFr3ow9Xr1HT5ovx6m6+PbhbdLGjH4eqbj6SThasC8Ha5n5tr1/EeH8WbA6T6TD9MpUT2kZ4q8JYb1ay7jx8mGGXt6JnZ4e43pVLkPGscfWT40s88HvDy48Gdd3hNEOPKnjPPOLHG7jtjya9jhOLxCJ/ZyPH/WfYcP4pK23IjR0/UPl1aVfqU/TKa0qJ8wmWNt8Nbxs09rimVwxJ7R4l2LYvFoMdLSYlK/MjPndSV+qMoqy+ztqGOmiTHWq3ZXpZh6/s8DXmI5nppnYWmsnDdBHJ6MidMYy4+ZLt1E/wCoaxmjrgpw3jnb57aGU/8A2IetkNHLB7+eD+sxw4+ZLu1I02Gz1bdPbTxucsq11x9s8nGuxR6MckjuvfkJ4/pJxWeSscCOWXh8EUlvfmiOaf5MEaIYyys9Vbx436aseTiEsdmjRH+w9TF1fmSHkrDktukno/6Z6EatTdIZx5LHDPjlmnpNDFKlTDlKsHSTaTwmWRtV67zrnz7njFww4tXzk+d41xbjSv8A6fHogY8nGpYLNqI59IuOsXV7QjkSXPP8l1p7ZJ6kfP5HGOORR6cMch8fxyH0h4jPabEd6/TP06PIbuiyMzObw5dXZ0nuR+HzcH4vqbsAMfh/E8eSyxvc/bMrDZNzRmGTDr7OOPee+f178WOXT/18fwf0u4vw33m+ncPcyP8AEDJyunA3+Mabhuk8loJLi4/B1nf7CZZ43yTjlu9PSxfTbVSPtGIn/TNEzcF44mnN0N8sng+ivD33TSOn7D1sf0L4en+3ke5y7XL/AKsWceN0+Xh9LFzILNwV0Rj5njXpxwrhc9ZOEuj/AKh9FxL0dw8r/UR8ZeBP0Ca+ivCpfaZEicRm8c56cbMa9Fx8aj5/B9MOA8Z9muJPA7/Tf/8A4fQYvo/xVPaYeX/pH+ohGbgsWE8cmLwmN/5D9B7mCs+On+nn0H+nOZ5cbveMXHwz4uDx7hr6y/62L6Z7EnHOJ/8A4TOefnTcTnxKtnwavco58PxxvT1ZNZYHeJfpnPHgud36Yy/a/YuF52TLHaRND9Nz2tNcpPvPw30f9NuMJBXiEF5V+W70c0L/AIwLwueuVgPB+pG5qceeN6+44ZcW/Mun602D7TcTkw1vVY9p8Pg/40cDzUq2e8H8w3R+mEuf7Th/FsF8dvqPvOGXFZ/8tSZfr3szhcUXz6fzDC3o+0u6ORJ/2GebiHE50rlQYk9u/cpj8Qn4bBqLgXlb6D3Q8/XzvTtMeTXtGbgcEXvstIH+mLJ6Myp0yXT7DVJ2HIePKzo48XL+9zUvGIpZK48iP/LEuS6rw5PR+dCfqHJ/oPS/iaDAf/VT6D+CQx4/pV6yeSHB41A8vgdDUmet6LKytwfJ6VjLR8JzIunHNWL6Sdgjk9ZcSxHfwRlm45h56RtHPJR/AZtyjUw34Tjw8n5kdCzYtE9255udw/tnVlzp+pcxtgwcNTU9ZTv/ANQa7R2mFxj3NSmnXEcZuKS4/TBIeXj8Ygnjrrz/APUJ9qrHb2n9Bn48vSddtU3pVPj7Y4JL/sFX0q4hkR7Y9i/MPJzvS6XhqVhxHynPLzvSTieVBqQxuiP8tNh6uP8Antnli9PensZnpJnTptjkf+g+bzuLccfpjnhT7EFm9LOIcL2yQZU8v00QpD6fZ3vMqDsSfqHsx/m63xHK8uHpFsjjSRxya8737mmWjzMzQs2JJO9/AYZvTzJ1LQxxzp9SMxzen2T8zEzqN9h3/wCPb9OfyyPQypsnqa8H9BTHzNJLdvn1fp+Az4vpRmZvtIZ4/wBmUhsXjk//ALiCB3/TNfHfxfk3UWzpciT2fEpNX6Znhx9KeRmz3f7DZJxLGfdNpo5nkzlbasiOgxxsZys20SZy6dVj1/5Z5uVjwZD7p58V3+W7myTO0oNSGPf+mfNyZkubtzMB5/1EOuGG/cZzz6+Y9rF4bFhSR+0nf+Y5qmVdOywSOn7zycOaDHg05JH0m7kn/wDk9DHklxf9rJs+mYvH4amfgs2LFlbdSRP6yfq/Bi+fl3fuXI5EfHJ9TU0IPAhnx4+L4/vNB7HXrPtzuV29CZWi01x5Mt/BvJ4+DPlTyac86S/qPcjlYuTm4tZNj/Tg75jhwZ8fdj4kiN47k1jotyl8R6jcN4nj5X+72fTkctkNxB4K7P8Apnn9llzY42k2ZCjZGL6QywR6M6DHHy3u68suHwfiGLlSMvsL/UF4tweXN3SSSO4zL6VRR1XA6PmFIeIekDwez4a7y+N4zt5xu3D34ebH6Mzxe0bPjRP+89iHiE+PBo4OXHq+Oc81sj0hXdpwRy/pkYcji/dgjypX+Y/cNZTt52xP8+I9Jo/SyWO2vA/6h8zxL0b4m8kkk2XHPL1uelHJ6UYEmosF7fL60KZ3HOL+zj9W6EvfeNDrjuOdvb6ebw/0VzH9p7dO/wCzsaPUOck9oe1/zHNmDHxyXUZst8VG+oelh4udFiV9ZR5T/ruMst+mpiWPBleD2mJiu69+d6OasfiS4aaOR2Sn00foPNyIcrqzIMGDS6HuNHi8Dyv9xPiTvf8AYYy4rcd1qZ6r0l9JMGDUj1I0f6cZ5/FvSjiGK9YcSN4gzuIejnDZNOOCB5U/rQsvFIsyDU7fiQReDvmZw686bvLvxKOA+mTS+zyMd06vdnsdnweLR60c+g/fSQ+fbKwZfdwYmVL9j0cnlSZmO9oeCyfzL3F4tpOXU1k9T1HBLJXHz4L3+fsNUPBc7Hk95G8S+BzwWw+GcZSPtkc+FL9m8pHi8K4RJHHHxLOu/f6DPJjZDHKe4+uk4tk4EcbRx3CT0i4rPHWOOhhx8qfKgtj5ev8AzDxeJcF9IZ57SSRunc09h4pxYy+Xsy5b18Pa/jTOxfZt1/eUh9OsmWT20EE8P7DDi4bRQV4lB2r9QbsfAXkq0bwUOmOGGtSOXbLW697HysPimpbEgg/lhHndgn9jHQ8XHx+FY8n+ny3T7DVJx7hST1mku/1Dz58W7qem5n9x9AvpVP3TVH6TS/MPDhXGaO2PJHu+8o2u23rQ8t4cb7j0Y5bnl6Telkuv7Po8Buj4t2pLLsPm5sWWfTWOCP8A6ZjZZ4tsnsCXgxrnM7j4fVSek2MkmjqO7/YZcrKw5ZLSZc6XPBx8qfDjk7Lia9/mULY8cEscmRnYkkCfTM/DMY3ctvWx8dopNSPP16mPiWZkxakmRnxpEZZM7BdNPHk0HPPXD32adMr9OQ68fFPtMsrInNxrJyNTTkeeIpirk5qWakCeNzPncWzon9nHSLuaHQeTNxaXI3TSSOfQxwmvDxZ3d8vYk4pFhyabb6/TBvSSJOmM+ZbIg/eT9k+47fHjXlt2+m/i5u7HGLH6YTofN6Kvu9oaoceK9u595fjwjeOT6jF9MpWerRnrR+lHikPl4V4fEnvNdz3OF8SwVjq0cdPvPHy8c+nrwsvt9Bj8eifqkN0fFovpngrHgy+0hjo5ohkiSSqxyIfPym47TDGvpIcqCf8ArNSxr3Tx8fKiWM9DheUs76Z4s7lG+mo3aakZIV6jQ2PfpJri+I8typjPDG0ak22Hpdh/8/zJycJvJukOk5G5dR5M2QRbIZOo9iT0dtuWff8AqEf4dyU6ZI3O05I53/x5LSSg00p7H8Oz97TCTgc8XSanLJUseH2ifpJyWeTcexJwmVPlmduHyp8s648srHS6efTyJtHc9JsNvpi9nOvaM3Hw83RDs7d09BYSkcLF+RLj+vL7K3UDY7fTPY020xlh7pfkv0TH8eXDisxojxanoKviGaOhyvJbfLXTTD2VPpjLjqbtAt2X8HP5LvydXm6MS/LDs6ueh2ZC0eGn1BeWx0mMeauPEnyxlx/0z1FxYkNEeOqnG81a6/jyVwW6ikeCx70ePEU7J+oPkyrPbGPD7D7MpHgqe5HjrfcW7PEh06ZX3WbyyPJhw0Ysy42L7yQ0TL7PaY5sWWU5f9fBvt53plm45hxP7PEkcxt6USq9ocCOho/h9r2UX1KydUhqZaTpjWiHjWTlJZY0Q9bh+Q0vvo4zwey06ZDZirL0xkx5LL58wz4sden0kmPjPHujjMPYcN392KzNp1kFhjWLcevLk3lrrp5Zx3GezTcJw0SywE48VG29wo01zHka6dKO5yzym/8AMdcMbrW25cOKJKtJsMc03DIpPd3lMa4+ZkSe7k/rNS8HifdJ1nP5Mr/1h0xn/bJ6EcmDlJXTMfEOGxKns32eAWTBnw47Rx3T7CMmZL3o3T+g3c8uussTHGTL/OSOHh6Xyzc2RpR+7MsczS/LKLZ+o4zK4+I73GZe38yw8W4nwmTUaCf+XJ0GzI/xAbN25GJeLwR7EPqpMHMzZ45MyC/8xDw+Pegs8sEmRj0RVP1cz47l5jxZ48kn+a8Wb0+4mns8GTsUX006yK5HpRlQSZTZ8iQ033feefJixYqbpL/qRkY8jG1PbSTvF9jnvmHFfTyd+T7pfWmYj1bIkf8ArPouD+mXpYmmuHJO6L9PeeDmNiy/7XUT95bhfpJxHgz2xZNM3lx43HUjOPJlMt2v1DB9OouJYkcfHuGxvkKm+Sm8nkcL4L6R/wD3T7Jfma9D4eb00lly+0NiQPKyb79BlzvSjJz490mh+nB0Hhn81l3i9v8AyZZqvssz/Cn0cyI7YOfPw6V+5I90Pn8r/Cf0jxZP9HoZqfUjc+bh4llRSe/d/wCs+gxfTbiuhorO8cX2DPhyxPlxr67g/wDFnBMHs8mBBPF++9D2JMjiEUnseLQYWXLs0O4fEx+m3EMCD2e9378h83xbi2Tn6kkkntTz4/y98vLrf6ZI/TuJelUHCMWSH0gy4+Nu3yMRN6f/AFPk4/ST0VSSRsfL4rhI7+4R+g/N3kn1LEdRn2n08P4OPGPFf7c9v1heE+jnpHPWH0sykf6E/WGDwXhXBMuSZvSGeB4uiPT3/wD0Py/h+R2eeORdjqfZQ+n2NoaeZidqRfs3nDl/k6/9XTD+ntN5Xy+qmX0Ogy45szPysrIl36ch72H6dcDxf9PhzxoncSNL3PyObiXBc95GzIJ/s0HPWweIcKxY/wDRwZ2q3RsucM/4pr064f1WV+lZ3p5g4UH+qnkg+w8leNcH4p/sc+OCX9c/LeMQ8VytSabEnovzKd08lcieLd7Silw/i45jpM/6uS1+3LlZMEftM/ET9m8ivEMyLc3pDiQRP/efkK8Slnj3T7Ppk45NV5F3nXH+PCTy53+rKv1STjGZLJ/o+NQP/MQ89s70hx3/AN3A/wB/cPkeH8UbF24+I7v9Q1ZXHONPHuxKY5fgm9Rm8t15e83GOPNJWTi2IlvvPF4txbOwtrQI9vmO9zx14kuRJp5Ef79h6EfGoMKDRjg1k6/aHq+LTz3Pt9tXDfSRYveRpg/qRoaG9KGfUrxafd8x+g8toYOM+59g/jvsMrejbJ/uMtP6DpJhvVSXKx6y5jZT2k4l2r9OlD0MWaeXbHiSJ+x+g+ZbhLLux8uCn37CeVlZ2Bt17/yJDOXHN6amVkfaTLFp6mRia8q9Ekhhj4xkp7PF0Hf7z5OPj3EE3RzyP+/eapMyCePUzoJHf9DYYnDpPl2+shyuOS+7kxIPsPPzOMekuLPVY7xfp7z51puCtu1M5H8COaIeOYcXs4Z86n7zePF1p3v2+sx+PZzQf6jhqav65bH4xnS6irgdlmX+w/P5JosqTU7XJP1e0kKQyTxe7z5KfTJeGVZzWeH6EvEs7U9tT+w1etIoveR0/rPhcPjUrbZp9ep7WLnYsu1Y+g8efFp68OW172PxqDI2xzxi5XpFjY71ae54uZhrm6irJoX8B48nD+CxP2VsuefI6LxjHixt3Vz5Mo+ozPSrDx9zT0T9Mzt6TY3EYLLPJi/qHg/wXgr/ALjLedO45l/hnGx3quXPOn2Hpx4ZY4Zcmf29yOTOZ42x+LI7/Tkfeelj5XpHjv7aeOn7z5VsfGwp41j1P5jmqThPaN0OpJ4LuXLhn2zM+r7CaFciTUyKX/QJzZGHElZI56fTjc+Tw4eyvaaSRHTuX2DcW4pLFBH2fZd/eHH4P9eHb5dx70fqpZJJJMvKgT94rekXDMCT2Ml4v1Dx+2ZMvvI43v40NDLB86SOlOgs4rGJyR6y8cweKYmosl0PBzMXhHd4nPBKeHnelEWPPIuPGiRJs00TYef/ABIs8mnJBG6Ho4/5b7efP+h9A3o/h5u3H4k88v6hP+C+Jq9Y5I53/TMOLxLhCprRySI8XyxpP8QmaOqxyQVO2PFlvUScmGt16kfobxeXa0cCIvzJHFzMHG9H441yKZrv3O4fNzelEs77Z54PHRyK8czIn/0+Xs/U3nT4N+3C82P095ePT6dsHgsbv40Sh583ppxXU95PBfZpkf4q4m8ntJOjo09hoyvTzMX3mhs+w1eKSnyDDyuPX1sfEyv5lD0v404xFqLnYjunR7eA+ZyvTDieV/7uSi+AMf0wzEf38k7/AE5N50vFjYz8lxfUYfp92Wes0Eel+yh9pwf0mweI+5kdP5h+e4fpkrf7zhsEieOhT+Mmg/2uJBBEfP5f5ZyXxHr4/wCjrfb9SkhtH7Oe9Dy8jhc+Ru/vPj+G/wCIjalWjPYX0wieCOaGPf8AT1Dwf8bPCvT/AMjDOe1MjhbRbfaE4cNVk9p1mzh/po3ErxyR0qelHxr6mJHRe/ITLHKeKs630nw/HZJKrGetNN2eOrSbzLHxTDyEssez7AWPhk+6SOQ8eWFt8x7ZdejLmS6m2c2YvEsmD3kkc8TeMzrwnh7e7kkRy3YYIvmO5zy6kl21TZEub/t5+yv/ANgKuZT/AFU+uY6xN07H8ZnaOX6hzmO1ueq3NkRJJVYI/wCYZZmi1LaZn7RLi7tO7nnyZErR+7O0xk9ueWf+XtYq4z/Mk/lnrY/o7wjPS00Fz43HymT5ZqXjmSnzDPJhbfFXjzkvmPoMz0TxseO2Hs/TPHm9H8lJI29nIEfpBkyyfMc9bF4sz7WgOO88J7bx6Z/Ty4fRfJypN2z95sX0B1eqdNh9AuVhsntJKE5sHV3R5+z6Zxy5s47Tiw14eLH6J42P8yN3Ny+j7J0xlo+Fyp7Rpwhklxfdzk+S5fZ00ztjy4vy+kpHNU9SHjVJKtBG5qXKwZ47SYlP2HLPksbxwl8seLC2RJHs2H02HCuLH7OM8GTIwYtyySU8BZfSC0mnDA7nl5L3dOsj2JOJS4+5oEM6+ky3qZ5OMMyf7T+8MfMgvuxEv+w4yTW6lxm9PoMfKXIjsEis/SeX26JvlyIZ4+JRY89lkkdDlMfOlmOvT1myK7WkGXOi+oYY8qDM/f4xcriWDBtaSSdzfTZZHtR5C/UMudxiDF2tJvPDyuIbI2hjpf8AvPm+IZE7SWWQ3x8VzunPKTF9NN6WMj/LobsPj0Gf8uh+e4c0uPPZo9R/1D7rhOdjZEFsjTg/Yenm4fjx8MYZS+27I2SbTO0i9WmLlekGIvs40ef7xsXQz39nqQv9555lqeW+u02VerTCiGpeGt9QXsUhPkhcNpqy9OmMqqN2WnULt7pZnv7Ov/htqDbXFWMpVULctpYNvejBm8IrSUC5lelpx2UFmiBZFQwvS1wvGyGdpl7oa4dOumxZCnaP1Dy2yqmeTMb6gxxtYuMe03EFiIycaiPBkyrSbpCi9m6pN5265aTrg9j1wU9aIeL6wwYPlk/4sw4pKqgnFnklmD6aPMsNrW7h8/D6YYL9MlDVH6UYbfMOc48/tjUnqPUqq/LBc6dOmDYeSvHlb5gSekkGP/w9+LM56i3Dc86fRLkNL1Y5oSaOntEPm4fSjGyI7a40nGsFuqeh6Jnlj6m3m+H9fQSZGH0lJG2exjPk29KOFRP/ALi7it6XcMlfTWd/+mWZZ63Ynw/lexlR8Sl6TPHwvMaTUadEfwEZOLYzp/v6f1hHlRP8+5w1/wCO8xvp73D1nx9sj3N2or9W8+XbFiyOqR0b95ox5OxbVnv+9ztjy9fGU8PPlw7u9vWysfurSh5s+hivWR40sNJnSSHm5HCYM/3395z5M5b4dePC4z/Vfh83EuIcN/8Af65TH9JGeC2RJf8ATPk5OIT5CbjPZnc/X/BNbvt8+/0Xb7KT0k4Y8dZMCCjnn24DxyfTXhtH+zYebDGtPadwp6waL3Owz063cpM9+zcS9BcyL2mHBRPpu93PD9WywSabRyXPqOD52T1a9/5h7mouV7yOM5Zf0ZYTT0Y8GPJ5fA+rZfp3M8nC6yWbYfpmnjaddNEYy+o8PNktJHcxP7cp7dL/ABy/b4OHhq9R63D4ezpbQjk/mH1n8O4KdJZsHGT5fSYz/ruZj/LI+JysPJzZNvR4Dz8z0dzoks0D/sQ/QJtnuYzK0k6btToOmP8ARkznwYzy/MZsGeldORDPHw+dHtpufpkkzS7pI4xrQRbtNLnsn9edea/zY32/M+wr3Y6WLYfo3mZ89Vjc/QJFwX3dnQxtxpYNRY+hDr/yM8o5Xiwwrw8f0HzF95pwp/3npR+iediv/p8+n6bxhJ6RRX1Gy/2Hn53pIuhaOd3dvqCTkzibwkfRYseZgT2ysvXTofwFlzsOXUj0I6d/Z1n57J6TTummsmw2cJ44qajSG/gz1sx5pvw+uk4XwrMT2kECRL3Dz9RceSPsfZMXE/7z5Xi3pFLLtjk2HgycQvJ7yh6eP+bLXly5OafT9aj4ljS+zWSOcy5nC4MzU0ZJ8WX9+w/N8PiDRPtkoexH6WZPdn2C/wAuWN8Mzml8Pcb0Xzl3ad7/ADBW9FW0/eXf/sMMPpdPqe8uNJ6TTu9lk2fTMzHkO2C0iy8L2tHJT7Cbcc1/YyQbP0+ss3phPF0xxv8AvMOV6VZMu5Y44/1I03lw48t+Yd9eIs2Ph48dtB3Re+C8c4K2nG2BIifUjPNb0mn70mw2Y+VwrMk1JsSkv2HS8dnms/JK9KHB4fLBaON6dzUBcHh6/Ly3e/u06BfWkDbVkoTk4bnS7o+LQR47nDGZ/brLjE+IcB4VFpzTR5X9gYvAeGPHqQ66fzBYVzsLcvEoJ3/U6CzekWHipI03t3+w6WZ0/wAxobDw0grNppEKvo7gyx6kMlEbxnit6daUm2COn6m8ZeLQcZS2poS/9hm8Wbn3xt0+ij4LhvBGupGiJ8wn2fGw56rJd/sPLx+JLhR113nQ83i2Yzz2j2eAzjxW3y63OSeHtcS9IJcOSuPpvX6h5eP6Vdl3TYmLd/0z5+RZHnsx6TY6Pi2zKdn/AE+s904ccfEeT5MsruvQm9KO27Y/+w8mbjkuHJI0eojv4xm4xw/F24cFCeRxiLiUenNHsc648evpzy5N32zyelmY+1jHNxyd/nv/AHmHOx3ikk8BlVv8/wB56umLy5cmW30mH6RTt7OTeh7XDcxZZNOTejbz4/Hx2pZozdHmS46d843jwviOmPJcX02Zw3JzHk0+JI/f0zG3CYkj/wBRxKle4eDJxSTui9obvHOcX01lyy+n0GRwNpUtgydqJ4/ozPLHaaPsv6jnm4vFpcXdHJvKZHpFmZUlWnkc6dcvUO0UzvR2XF3a8bp40MfqtUf2k9D1OG8WZvZ5UevEfRYuRwqn+jxI4H//AIreccs88PpuY45vk8fh8XUsEmV/LNC8PZ/d8Nyk/lofUNxRZXrJPAn7CeZ6SQYr6OpP1/LM988q6/Hhp4MPD58fdJgZU/6dDZj4OMz60nCZEp495ZuMLke54ll7PlvvIyek0qbY77TNud9rJjKabi3DMD3eBHBL4KdZGP0iieTdgYiJ9ke8JOMRZ/VAjy+N0Gj4bFlbpNCD9OM3vrPLGu10suDwri+6Od8V776dBlyPRXf/AKeS/wDPNEmHw/Fj9pO9G8A2LxbGgk7PDJJpP9czJfca1j/9PPb0R4hjpqK8D9z2bhNw3Mwo7SdHjPaj4bw/haakmfHOj/Lj6xf4g4Zhx1X26eCQluV+jWP28XFzJ4umQtlZ2ZLuad3T956HD+NcKzcvTj4THA7d89SbFgl2x6D28ZnKavpvCeNSvH4T6SZOG8a9zwH1kfpFjNHZo/8AvPDyPRmfITWhgTFfr+w8fIx8zDkrkY7p/Qcc+LDkm3XHPLDw+8w/SrD1KybE/Tc+gh4kssFoz8djZVkPpOG8cbHTTPncv8st8O2H9F35foS5l092UXiGz3Z8jDxxj2sHM1+o8HJw3Centx5JW6TKV/lirxBUk3QXGsvdJ9G44y37dbr6UaSKV/dk2xYnkssZNsipPtDIau6f5aNOu1SmPCr7pDHqS/0FoZDOUXH29rHhxn+Xc9CGGJZLHz8cjGqHKVPsPBnhu7erHLT6TTgZ/dlJOHwSptjo58+vFtI1R8aoea4ZRvvPT0F4Oq/MoNMsEHvDC3FFl26hlVdWT3hZja1uPQ7Zg92AG9Img93AiGHs8RPs8SdJv60zp62P6VLK9ZNRHPaxeKY0/wC8+NaOL+saPO7OZy4plj4Xtr2+89hLtI+r8Z+o+P8AXkqfL2B6+yU6Yzj8NxbmWNfXNwtqVjnjRDD/AA21/fxueLj8YnSS0h6UPHlbaZuGWN8E1WjM4fkttXToeTNw/JX5Z6nrqJeqQm3pBh9OpIXDvj5Ljjk8eTFnT5dBlVl94e16yw5Y7aly0OVBTxodLyZa8uc4p9PLjbuqfScH0ooPebjDNHhzx2j2OTXYccr28Okx0+iaav3ha54c3FOzx11N5j9cZPVqbTl8VqddPotP8k6ofPrxidZLFv4ianuzXx5K9hmVSLMvUx5bccll6YxfWDS+8ohuceTU6vSaaL94y5Cp1HkycSipbUPLyPSKK9VOuPBlmlyxj6rtkXdFbiESdR8vHnLLuXrM+VnS6Z0nCx38bfVScYgTpGXiUT9J+dzcSZHCP0myYtqnb/ibcf8AkSP0SRmyE2nl5UOTqaix3RD49vSbOf5gq+kWYnTJQ64/z6jnefGvqo8fMnjsplmxcxNp4ePx7MaTdI56mPx5vnTuavHprHkmTHnRzp1GFllXq3ofRNkYeRu1DHNGr+7NYZdZqueeG3j20v3guY3V3zdJw9iLcNOsyxebWTOuZK/zHLY/EpcfpvcnJjshnaNjWsanbKvQ1mfdplGhaWPdPT7DyWaV9pPscr9QnHive2t00cEUm6SN0NEPHOHYu3T3/UQ8dsEGwVNdcb7W5Zb3HpTce4fpyewkv3HJr6UTxe7koYewqnUK0a9JZhh+HfJ6H8XS96Sd3NS/4hT46VXEjPF0UNUOKrHPLi45501jnybepD/iJxDUt0J9h7nD/TifIerbz5leHr4Ddh49H92efPj47HqwuW35aqtLJU9CFcZfeb3PHjaWXpjf+gssc8UddM/S5as9vgz/ANj1pJIncbH0Hkr3DzY1Zks2waGahwmLUz0+ixVgiPQjkic+RXiTLt7hqj41XpPLnw3J7MOeSPqJIVf5lCmPtPk/X1Cnr1/+Zx/49dpzx9Q0zIZ5MiU8NvSDS6usF9JvFGPgsavPjft6DZTqLJlM8ZnbjUD/ACxZs6KWP3ZelxmnO57+0ZMpkkM8kzP8wbUid/vFkx1ptOuM6+2NWsedlaEdV6z53MzGaQ9jOjseTNi+0+w+lw9ZHg5f9PNkkYjNNsqbJsdTycibS2n0OOy+Hi5JY0LJEgdqWL9h56tfqGkZaHp668ue9NEknaHqplyMWWJPsKR307KGteOrFkc75Y45GNCyN1E1jVOmQLNLtU6//q7asfIbvGjtHhM8ePKiGeSbSc52T6Xenqdqb6ZTtjd7oPLXOvtNkc0S7dMXFdqNmQSpXTJtM0Xuycyr9MtH7X7EM61N0gXIZwkknfxjRwtqbTRJDkruXYc94ukts2z+3l2tsKepZZ/eSaaN9hNZJb2aTYTyOLZLSVWTYdLixbr22dh4VgJ7TUzZW/sQsseK0kbYM9Hp0OeKy2SzSDLHSSNtQvTbE5NV7Hq3OlkrkRolPA5RplePs80en+oZ14tLpxrJp0XYM0mHn7W9g5wmGr5enHKfTPJJFi9PcPJ4hxRpZLalD0MrgMssdoZ9dDwcrh88UlZI3Q9XHcJ5efPc8I6xSHI3iyYLRbWLY/C55ZNsemn3nbtHKS1skZciPcRhx2STbHc1eq5cePUbeLJlaSbejvmPH0vXRoe2dKwOaFhnpaTv/LMMfGJ0f3mw0ScW7RpjVT2Mfhc8vu9l/qE+JcP0o9skc6d8zzZ076a6nULCzL8zrHXzus2s6yLQtDHLK+0pDir9O7satGWm2OiGrl1WS1nkknxdrRjLnNL8w9SPgeTOnttkQuRwGLT9jPv/AFDFzldJhZNsPtYtyyHoYbLKmpkSf9M8dbK4zTMTrLGcbY+gb0gixfZ48EcH3oN/G0q/Lg/sPlZlZdykat/WbnHjV+SvrJPSbGyJNRsSNH8ZqxeLYK7uwXlZz4uNT0sFtL2nR+8xlx46XHOy7r66SFeJR1WDYeHnej+TgR6ntKE141PFHXXc0cP49LFJ7TejfUPPMMsfTrcpk81lZ4/eGeRmd/GfVNNg5qamgkD330J464MWo0cEaJ9Tvm/k14rNx7XT52GRsfcp7EPGszT2yJcOJQ4b9P8A2Hn9lr7mS5uyZzybuN8PQbiWSz7nf+89bB9JmXbkSXi/UPk5mnxd0kdCaze0sYy4pZ4Pkyj9IbD4Hxb2kfsGcF9E5U3Q5cbofF4eZEhux+KNrxyLJ0Hiy4rjfD1Y82NexJi5Kv8Atc3Y/EMnA+Web/FEmnX2f8w0cNzu2SVk63PNnhZPLrM5b4fTYfHlbbJ1mqTikX1D59cVk+ZGUXHZtqnzrxy3b2Y53WnsNnW6ZAjzH+pc81cdkj95GhSNWTqkQzeNuZ/r1lyL9Qdso5hVtLqkLRs3V1oeezy7TN6C5zGjtUHzDDGymhVVjzZTw6ytTSYbx7bjNGqfMM6w+E0R8PaXqkocXXW1IciLU9p0GqHOxneOsclyfqmm5Z73JthtF8/eSyNzw9RlgyNy6gWiTqjPJXIii2yT3/YaFysb73Odw16dZlG7Tilj27DLNw9sd7al0CPIj7puhyF6WM+ca3rbzVht8yhbT0o+u6GiTHV47LIZZI1+oN+XK49Ss3hkMuVmSxR7SmnUbTudNMbtuo8ntGTLJuj/ALD0sGGe9pOg2Rt4Sy5TdJMr9NY4+WiGOvyzVqNF8sw9ubpUFzGPNq133p6kOY30yc00vdM65lA7cYuOr6atlmmeaSfqJ6krfMGzMzVj2nlzar/sPThHnyek2RFF1SXMLZTd2Qi1kSoyqx6Osjnd6RbOn7xObMnNyx6vUN2FX3DtNsdcnjtkT/Ucm2q249vsqkJsPwnomUjNxrLj5UsQ2VxBmBoaGeRlTqLNVjLc8F1rmdpGU1LMjgzROde0lefV+mNpJe6NG07/ACzVp+EKyi5SxJhaIdVOo9DHW/ULjtEm6SO56WPxDGXpgPPlba9WGPg2LiqeguCvVpkV4k3yzVHxjZVozx59nsx1pGSFjHNGydR7EeckvyxciG/Scsc7KXDfl865lkkVT0siNkfdGY5oVb5Z7Mb+vPcY8+TIUosyUsblwYn+WEnDX+X0HX5NM/HpjWZQsqblNHY6dXUTkx6fLEyTpIy5Ens9pGFVvuGmUytzO+M+nG3VexowJuuMuVjRbl3ni6lBdQnxyr8n49puJK5oh4kqHz8c19poVv7DF44s5HwvrhkCTi0svUDYMUXVJcxzKq9J9zWNfKi3bL9RFsxmM7SUJ1Zjtjjjiz9LNkb7MUXMMbY8uoFGNXqN3bGdK9waPKpqGFVYosfiM6x1pca1NlNL8sirS/UCOFpdqm6Pg6v7ySiGb1x8km6iszIUxZJcic0Nh8PxfnvMY8rjGlHWH2CGZh2rfbq9iOPS3NHvIrxKVE3R0Pm149OkltQ3L6RNLukMX+duc8viNU2Usu4wzb47GztWNlbmjo/6ZHKxfYbd5ZOt0zXiyMzHm5keqepM1OrrMtlc92Pjy8ufp5Kxswy4ralm6D0GjoRkjllPVLXl0aORU9mvQTXDi70gaYy1oXX0qMnD69Mhox4+yx275NV3jNDPS2nJU1cut0aDZFhZGil6hVhYbs6/8x3x+k1Wdoovl7BtZV94WXFpJYs2Cs+5esnffs67Y2yK7lFjznlkqWbhc/d6Ca8HlR7Np0OvbHWiYZfjdi52l97mqTiCypu2Hmtw9Yume7k6yoc7xy07ammrOk7yvf8ATPL7Q17FJI26ieoqfLOs8OWXmrRt3mLLlLLtMMk1hseShJNJi0Ltk3HqYskSdUZ5azK4rTMgyx3HSXT2sjjXZ5K4+z9RBo/SJqe29oh87JJ3hdRrkmGMnk72vebOil3LB/WN6yZ0rJ7o8eFiyzKvV7QnVrbdDNFFP7Ten0xsjMxpdq+wMrZVo6rHGZVhZ5JGYsVlzMGWJ5K70MsLMm09qaP2NTz1xaPu7v0zWPJpwyx8+E5G1Y93WLHfum5cWWXcsZshxYovfR3/AGD5JVmFrLg68vu95sjypYtrR7yy5EWL7nYhTt2Gu5o7+Mxf9VuSRnXInfdNJsNTZ0DdSbxZpoJdyx0/TGtBK+6A5+25f1OSHGyo6rG+qZcXgs88+73R62Pw1meynpdlxoo/aT/9NDGXJrxHWYS+3htwPh6aitJJfxmeb0TompDnxzn0TScPi93BJN/MFbMwU/8AaaH8skzy+mvjwk0+Tj4PKnvBpMHJ6VTYfWdnw5d3tBpIVfbHIiJ+oPltcvjj5NeFy96RBo+FqnvJD3puGqu7Tkkp9Mi0cTdWBOiHacm2bxaeW2KvdkkJzNLi+8N0awY8lm6PARzlgf8AYNy5M6+2GTM1SK5TROaNRYn2jLWU7emdM+Q2vBVjHJZo/Z9ZTKjaDaTjbujckc9bUWSm41Q5TE44VT3hsj0l6TjllL4dOtUhmZ3PQxchopNvWThWJk+w3RwwJuPHyZSvRhjdPcw85pY7MLJxZYvc988uSZulSa2c8XXGPbu61tqbMllLQyeIyxxmqOHvHLL9ax3t6EMmz7D0MWavTIePpt3SkckqnlzxlerCvoFmXvDNxCnSeDrMC7vmHDpt1yz36ew3pA0SfeK3pI3ePJbF1RfVrF6YMd83vYfpIy9R6y8UizU95vPk4+H7PeGqOFk6ZDnljjZ4dseXKe3vVX6lzZjzaG4+XXVTcxaOSVjn026Y8lj66HIgl6jZDXT94fG47Soeti5Evs7Hlz4r7dsOTy97o+8Wq94xrlB2yhx6107ytTRqTbYZ2zGcizM/zC44sXOablzlTqG9ZY3zIzyZI5X+YYciOe/uzrMJa5Xl6vpPWGMnSHrSBUPlWhnRCepKnUb+PHfhPlyr7KPikEvVGao5oH6T4dcqVXNS8QZRlwz6Wcr6xmX+gGb9M+Tk41LET9dTy/ME4LT54+saNX3E22nz8fFJ+9IaPW3iJeKrOaX29izIDSRN1bDyWztUnrM4nHFvLHsaMT/MJtDUwwzMnUaO1WJcdVZlLCstOoz5ELPHY0NJcWTf0mp4c8/Meaqlo1Qs2PYosKodO8cZP0qsqfL2DbXFZVBVUjtsWVSmszEWVSbRl0xt6WPt6pDV2henUQ8HT7w0dkczePf26Y56fSQzX+YWkyKHgxzMWX+YeXLjen5I2SZFzPrN9MZY16Rmqhrembin2gVsr9SgSMr9RnbFgQsc74GtT59waZn6ZCawxKLJGqdMh6I47qc2q8hFo79Q0iuhGS53ntxy9lqveFaOIKOT7O3mdduNiiwqozKpHsrjLCDenybY+r1B2WDpkItIyR7esisMsr2aQ98lvp5/tqbDw+7vCul7uOMiqxRdW8Xt0UXTGdJKjQqs/UEmLF1MZ/W1OkI+LX6idau8daU0YFFZYHLNixZG5ZKORbHWL5gl2ikM1NsZlyNVymoqirmb9o0PNbDnlIzcLlXqPUkmZ0IrkMvUeiXTncZXl+q5+7HcGwZYuo9hsxnNEcPao9xO9h0n08GFmRz1MfOXpLTcJg+oYZsNYtyyE32JLjTZWPBkblPLmhVNps/zbxlFVf3nTHK4udx7V47RsZ2ZkPcaOL6ZlaNdSp1nJuuNw+o8vc40anpaNNyhHHc7XkidKnj4+rJY9SGZEjr3CK2SOqgzLpnPLLs7+ppoZcZtumTbBxn2xi9lV094NHCqdMlzF8J79sbY9ZJKnoY8cCRxsxSSH2B5bSMm1hMu3ss6PWZoG6Y9My5GCsvTJQx2puNC5Sum4XxVmbx8rFlx9pjaau1j2syG3T0GHsdz048nh5M8fxhXKvtM+QbpsPSk93sFkxb7Vj3nftHHra8/T8IbkNzYsqfLIyY8vSxe0JGdmGVrjaNfljVL336XWgqs5ZYQWO24pVuoxlSY6NHDctHg6pGO56ELU3MYt06aUh4L4us0NwmvTINHNfpG6N0khwvZ3/zSrwnxadxl4St7dAy5USfLIzZ1zM7LOs8fb0F4fEnzNhlyOE23LPGeW0jfUFjyJcc7Y4aiXLHTRlcByYtRtO9Ppkcfg7UtN0dwaHik6fMCbMaX5mw1rJyulJOHxKns5N55azbzdjyEZMVmeRjc/wA+0yk9xsx85ooKt1mdW9pZpN40OKK2KuoYx6y7auzNxLSFXiWlqMDYKi9lVUOvi+mfLLkcYl1I21DRHxqV46yGebBVukx5GPLj/sOkxxrjLY97H452f5guR6QS6lt8f6Z8+s3dFma/V0EnH59LeTKx9RDxjGytuVpizY6vux47ofJrJQ9DH4o0WnXYc8uLXpZn+vYkjgn2zR0civA1d/Z5FAXii5XV1kZs5k6TO8tadNxsbgLUtqI5qj4bi4vvIN54q8Sl+psNS8YZOroOOUy03MsXqSQ43dgjoT7RBj9WIh5LcSu9l6BWzlfqEwsXs9yPKw5fl6YyyQd2Q8FZIpenYbsePS3Mcc8ZI64Xy9Rspe6Ujmv0nm9sp0wIhRcyf6n9h5+mnbt/puaahSPKZzDHNO8lus2LJKcMvDtGyHIsbo5lfqjPPjkKan/pY8uU3XaXUamZe6cJKyjLIYk0u2iOZj0IcpfpnnxyUNkMxxzxdMfbYyxS9ILjqnzCkZqjhVuo4b14dtbZVkXpk6TVDDBL0g3D79JTsulHuMdvxZNKLi0+80RqqGNofDOKsKv1TmbLWtxukjr0mW0+p7uSMFh7qyDR68W0zrUZbIW2bgbkZWyG+ZGRjylQmOKNjZFeoZcpX2mPTWfpFkhp1SRxnWSaZr2IZlYaTHil6o0PB1NL5lwk4tKnzKGcsdpK9KbhsDbV2GeThHhMbcUvJXUu5sxZMlN2nsNzHLGE19MM3DWQi2DL3Yz6ZpNWDdHvJxx+I3hy5RMsP14MeGxsjxWPU0YikeKvULlSYx58OOxqjxWc1LDTpKKrHG2tyaRjw/EU7PAvUNrIMsimLHTsnWAZVgG9n9MW0He1AmzLHB3SnZ1czssXdGZfDIc+uzajYq/TFbF/TFVp/qbCmpKa1puZS+2dsf8ATJ9nNyt+mdG7F1Kwdm8g7Oelb9MVVRyfJTrHnrCw1XNzQxdILir3TXbcRh1HDW7xubD/AEyLYJO0+1trK0wrNY0NhitjsWXGOdu2VlXvC2T6Zq7OTbHOmOUYtZ6xBVe6aOzg2Ka7TaaY606SLWc9RcVhWw2Oku2br7eSyyuGnK563Y3FbDY05V+TtmW3E2ymFbHqTk2H6DHF4blQ0zBZydiizUNeoxKFjZ+o1R4tNzE1yGcpqM8Zx7V1xk00doWLpFkyGfuGerv0miPHam72Zj0u01/lk2Vr1WM1eyiFkyvpmpdrfTKsMrdRaPF8RPWa+4FkZ+otm2PUbO2R4+1YwbOil6v/ANsxtDZymjTpJ4aWjWJwbFVxY1YuYt8q8zIjWLasZFZJT1mjVvlk+wv/AMzcykZuG/THG3iCSr/LNnquUZeH+KQveLMXk1/rKRyU2rGelpxRdJnmmo5uZbYuLLNu+WZat1GzU7wbpfl7DpM+qXB56qzGqGHJ7sEhujsu7TBsicmXJtccdNGLw+V/fbCzcFglj3HmtmS94b1lP3eg4WX6dbY1ScFiXapGThsSp94vbJW2sKs1+qQTeKeBJhqybjK2PEnSbGmVk2kdFn6Yzczkjnljtjmw16lJ9nc9KPh8rfYWj4enzJDp8n5WPj3Xk9nJthqfRdjgfaDcNif95flLxeXzPq+5NuFt1H03qte9In7Cnq9elTU5tXS/Dt8qvCWGj4TK3VJpn0jYLfYZ5OHyruXeX5v2sXikeOvB4ke2vvGk4e19siGpsVouonLs3HTHOWOcx0I8NunU3jdjnTcZ7Mj+8KR5Uq7mLfLGoVsVk8YrY9zQucxRuIKou56b/wA72w9j8JOTFZ0PSjyllj2xlNOKX7C9tNXCV4PZ2XUJ7vaLpn0E2Gy7Vkj/AKDO2K30zcz04Zcfh4uoy7iy5jGxsenyxaxIXt2YkRjZpeqQGqg0kkSdOwyzTKdNTK+F34WbIUNRf2Hn2JyWeM6SOPavQZVfpkI6l9rGNWYssiqNaFJsNWjsvWefJjs+1es9JcxhpMxU3ae8u8p6XUeP2OXq05Ajj8R70fEJW29wMjBgytyyIkpOzXXxt4+n4ZBpG8Rs9VyxfsLdhr1GO+1mDHGq9RTtCxfLJ5CtF0k/a96Mx4b66UZllJ7XJtscZV8QtJPwyrU9CORv6COPjq5q7LY82V34rvhPCisoy5Citjsm0I4zm7RujmVCy5CmFY6SWLLTvHnyk26xsXIbpWQNZvqEUNEa+I898NKLlMbIcpjKsdjVHjnO6jcbochTVHJE558cJqjhbunDKSvRLp6CzVLQ5xhjmlQptfcx5LjHSV6kedcVmlf5hjhr3ug2Y+hLJtkJrTctqenILpt3jY2OydMiUDs8vd0xvS6Y4Zp4pPsPYxcq/UebJaLqFWZk6SWTJH0FYpUFbhsUvSeLHlSll4hP3Yzj106TVehJgzolY6GFuHy39pGbMXOv7w9COb9QxcrinXbx5o4k2mOTFVz6aSGKX5Zlk4TE/SXDk0Xj34j5tsHwnpcN/wBP7yTYapuFsnST7CyfLO95ZlNRynHcWpuIQLuXeDZ0Tx7oHQjHGpaHF1X94cdumh2Vpd0clw050+WewuPpdIVMd2XitJKoLmSoetJjq5lbFX6ZqZxKiuVbcxRZlcm2O3dF02U6Sysf6WshTZ4zKqjV7xbGmzT8MgrRsZ7BYml20dHzBq/qf/oZW5Au8zo21Vp8wpZk+YY9NgUnXavQWZRvZOYVjLKrHPS7q2jECyLF0kw07mNK1LMUXIVjHRxlWpWbuemrqGaEyrYorF1E/wBLLGorQ37gqyDap2n+Wd0rY4umqlNUmzFSWltUjJt3KUbmKy2JNw7RhmyKGVprnqNjq5OTC8JuWn+X4vucVobmhVsUq3dP0faPl9a89sdmKR4rG7RbvFo46lvJ40dLWGPFp1GiOFTQ1BVahwuW3eSQv2k2kbpjKMwJ9wjLO0LP1B2cs00XdDtHhjudBHanTHcW07fLoWaaXu7CMmq5r053WvBujqBphVhZuoNJTWi2/Skc0vSU1mTpIstRZsjQQ5tS3XlqXIlpZi3aGl3Hzc2ZPkfUoCx5UvzJKGrxyp8le82Z3VkG3P1aZ5McOl0x7w9v3iXjiy16DY69TSUM7NhxP43MMkj94msixJuNY46O3l6C5kT7dOMtHIrbTyWyl+mC8Qr0l61JnHtLGrfMBsVe855K8QYovEDn0y+m+0bJoV7pn7PKxGTijJ0mduJM3VIamNZ7R6keL4iy4cR4q8UoWXiguFaxzj2FWBPliyZ0UX2HjtxJqHn5nEmLhw3Ji5x9BJxaJxfWi3Pk/WHiFjymfd3D048Ejn8r7D1orxi+srnya5H6g3bF0/eCcMjPzbfWLxKL5haHi0GpuPiW4lQm3FGNz+fbPzvvm4pjNJVegpHkK6bZD89Xikq9Jqh4hPL1T0QX+aVr5n2zZC/MkT9gunBL8tD5WPMVPmXLeupemPrMTgv0Tm3H0TcNxu7AR9UwOebDxbJfTXUN0eZL0sc7hnK3jlhkJuEq/wAwzrw2LH+Zc9Rsi/TpkWmZJPdpQktxXrh4rzWX6cZPTl+XGek0ay7gWG/TIdO+5pLhv0xrHOnVH/QaKs27uFNOm7UF9l3pNgqdU2x5Sa8PZo7NShasT/M2B2dW+eTz9LcZfTz5uC+02yXQxycFlR/dnuLCydMg2m50nJcfEY+LF8zJw2Xq0yLcPlfq2H1TLbqMuRjr8z/9s6Tm0xlw4vFXBXvDacEW5e+bJuHq3SZZOFzodJntxvHpNmiTdQVsqJPlxkZsOdDLpyf8jc0xZWqaZX6dhh1G1LKN2Wd/lmeRZU26ZqWM3f21LxSVNuoT9ZMhhZpe9GRkNSRN2PaXjT96hoj4hFKfN2GXIqYuMrczr6SSSLq07hI0TnhxzN9QZpmfvnO4WN9//XsdqVOkO3feeSrL9QtHU59f1rtXrLmaqAtjz1qnzC0cnhc5XH8dscv16SyFo5DzVa5ojZe9IcMo6yvUhr3TUh5cci/UN2PMebOOuPp6EK+I3R1MMLKxoqy9J5cvx6MfTdGpqjah5scjLGTkyJU/YcdbrvbMXvRtExqjx8P5kh8i2ZKUj4kybTPxVmcsfZeq4m3Y85NsWeLpkSQ8XhvGGXax60zdqjtHJdDlZY7yzKeGyNm0+4UWOVDyY4aHoRw+zssklznZ9u2PluVVl2tGZ5MPS+WNCzd42RyLLHWQ4brfTswx4q/UoM0JokjVOmQyyKWXbnqQtqB6yXF+wZd+1jO3D1l6jWmN2+mpeON3TRDxqd/vQ8+Hg/hkN2Pw/s5jOT0647r0o+JK/VHQtDkL1LIZVjbpG3J1RnndZG6THxspPd0cx6eltGjmi6ugpJMvd3k878JcfBochi0kkS7mMfalQjJkX6jcx25eHqRzRN0yAzJ0nk2i/rGWRU+YLjqM6eoy+KMVoyMfEq9RRuIRP1Em431Tkx0Ui0JaTMicj2iJ+mQ1LWbxy0dn/wDP8ifZ2/5hqM/zBdTxG91m4fiyxg0PhI6lA7ahZKmpGjcgKpHtSt0lFyFFa1GpWUayEVkVjuopzstXrF1qH7SI1jmulk+AWqZWk8QvaCybZa9RRGk8Jj7YvSK2QdccbUlaGmqK2VQzrNcoqq/UOtZ8X0btn6gdo/UDRgY72eA1vSWR1cgos3iFjw1G7KvjJ/qsdYpZCispnXFp0ltNyf6Y6x+WdhOLgms40lIz7ctcpjKj2XukexsWkmoTbK8Jv/SbkT7Cyh6v7zE2m7zTjLlL3pDpqseKbRohPst+os2VEL2rGYeYXqztpY/URkyl+XHc0amN9ORxo2gTpjob9xy8MPtX+RsJ9on6VjPQkmifqI2iXpkQ6Y2mtMenkt1SFFw27xZo5+6ZZI5E6p7/AGFm6wsqqvVJQVszGi26d3PNmjzJZK6iIgNMuKldS7nSYWp309D1pEsm2NDDmcenieTR0zCucupuBpFl+Ydpx6crk0Y/GJ8zbIaGbV6pDyZJlij2nmzZ0uptN/F2Zuen02iqfeRZYkPDh4xLp7jPkcWlfbqFnDb7ZnJK9ybI+nHcztlS92A+f7ZL1GheITt8yiHf4tOV5NPWZpW95HQZmVPmHltxKu32jk2zFf5Zn41+R7DTeEytNE/zDzWypelegi0h0nGnfcesuRF9QO3d1TyVksMu3qJ8cTs9JuIMTkymfaxj29Qti44yJ2qkzGVshulQka+4z2obk0573TNlMvUL27uk5pFYxyNQ1rc8sb03Pmd1Q7R4pDy2koHaHOs9Oe3rR5Rbt1Ok8NZhmmZSrja95cxuphlzmPDXIZhmyLjrKdq+k9cSr0lF4tPL8w+Z1P6zVHlUJ0lWZvqsXiUq/Moepj8Yb958WudST7zVDxLecLxTKu2PJZ7fdLlLLuaMWSPV3RyHyMfGN/vDdHxzwnlvDY9WPNK9ybByn3NIYZsOeL7yMPHl7xqXjivuMdLPbfaZIrDmNt09g2jmIaPW2NL8sbtEEu0s39p4Z1bJ7w3bJeliixq/TIDY692S5nL1prSOs3TqBHlMgTKyGWRe73BOtYu2jtVjPrK3zJDOyk5KG5r6ZtsamyF+oTkmuefJG/dI6jRHXrtntXqWl/oM80MrmFs6VRW4gyG5i59v1aaNkMrSMU9ZX6g7ZBLuYv8ApLZWViLR+E2Nod2MnJCr9MhZkzplXH/UG0WTpcm0bKLZkNM+mhVbvSDLt+YZdwy27xjKbdNtSzMWjyDEOhjW2nqR5RqjyLHjrY0QyHDLF0mWntRsbI2PFjyKSHpYuV4jy5Y2PXhl5etDIyHpQ5Gw8mPKU2LkKeDPHKvVMpHoayoHUY1kV/3gsxxxxa7NzKriti37hlXIb6hqx8zxEsyhOtMsek/gLR5EifeGssvUMzL3TF8RvWvTRHxKVTRDxpkkqYVhLdn7xnUsdZlZH0mLxTtG6Te5s1InPlY27ObI85uk8uXHN+Hoxz09xt/VHsFaHwnmx8SoU9aRHO4Wem9zL21adRlVn6ZDH6wRhWzF6lOkxrGVk9PUZZVGWZu91nnx8Wr1dBqj4xjS7ZIzl8eTU5MWxc6X+gpHkeKMyrlYz9IyyRd2Qx8em+70I2iKbDz9zR+zkBmlOdxsre2ibFVvmHnzR1KNNKvSefNJObw8OOXpor+pQa0S/MPHkkZuobWVUqeyY7cW6TIrJ7OS5NuKaXUYbL3QZVaPcNRm3L6ekvGC0fGIk6j59sOu5ZBZIal6y1O2cfReuopekWbiS6Z82zbCOs3yzU4cUnLa96TjSlI87VPnZJGfcLHkMh1vHD5K+qXIpuF9YUPHhzvENJlHL42rnHpNxQF4sx4MmR+oZ2yGOmPFtx+V9pj8Stt1DcuVfvn5326VCi8WnX5hi8EbnNJ7foyyX6TPkKx8OvHJ0+YWj9IpelpDHwfizmn6+kmWeLqjIx5ErHnx+ljRbWKR+kkH0zU4tJ3jc2UwvbmTpkGh45hy7WjGbseR7uShOn/jon60cG4syCycPV+mQxzY9CTGVi+Gr19Kgrcab6h5bRsTaNl3HaYYuNzr6CP0ideqQ1Q+kkUvUfKrvGT4Ey4pvwkzrxfWjdINxBm2+7MK4rd6QNFV6pD6kwleXtTSZDOLqOWhjibc0hnyuMQYUlY4951xwrFy/wDVNOeX5Y3ZZYktJsQ8HM9Jsln95RDzZOLStJZpJJD0/D+uN5X2Sth97LcyzcUiwvc+3PkZOIX+YRbMZjc/n2x8u5t9YvpV4scsvFop/mUc+NjmNS5CxG/gjE5tvopFWfc0gy4sXd1D5tuMMiVjM7cUZ92oScLpeR9VlYc79OX/AN4sKxYae0yLv3z5Fsy3UDZzdJv4WflexncSXuyHmyZ2q9TzWbvam8nY744aefLO16CyX+YU7RpHm6jKTaZjUxlTtXoScQM7TWMpoxcVpv0y2aY7VRbMUXBnl3aemaIWXFSy9ZOTOaX5hGitw1k+YlCLKydINNcnc0mVZ2aUpDdNzA03hJyMzFY0p2gNQWHHZjUuKS2T01Iz6linR1by3Z9JLGGaRjK+Y0akrkZMj+8i0niBpqCSbZ2WTIYytMWkkuZ5GNyBWkuTaS4sklScjHSTbAsLqe8qL0SfuFVu6Vk1u8NqOTbZHYb9oTyZpqdI2pfqItVNyhUqtGoMsxn1PyUVWNfS687bFyPZjazd0wqpaNjKTy3R5RbtPmeavIaxmzSy7ekuYybjQuceSUVqk01L5exHxK5oj4gx8+uRXapRZmMXBqZ19FHxKpqh4gzHy/aDRHmUMXjdceWx9lHxJvqDdsVuo+VXOKLxA8/wu85X1HsHM7Q4z/LPJXiBaPMUxlx6dO+Nvlsmw4jPJgxdJTtSDaljPkklebkcHifpkMs3BZP8tsh7DKqk9Q33sYuEr5+bDlTbpitjyxfLPpu0N0k5GSX5Zr5K5XCV872ivUUXIXvHqScPxp/sMcnA/aezkN9zpYirKwrMr9QzcLniItjyr1DtE1Taav0k5FoFqkWkN6ZkUVqFF5GeyBqfgaa29KNqGqOOKdPvPHXINEOZU4XHbpMpt6C4rd00LaI8+HOZC3bvEcbjdu+NjYuR/lt75btHeMOsrDftOVwamVepHnMpsj4hq/YeDvKRyMu453j3W5ldPolZW3GiOZe8fPw5RqXMPPnx2Tw7fJI+gjZCyyd48Fcw0R5x5/i23M9vchmbTNEeVTqPBXiRTtyv1HO8VdZnI97tSitMp4seVs3SDLmE+Kw+R6mp/eUhk8R5K5y97eMvEjN46nd7Gp4htRelTx/WXhJtxam41OO07vWkyK9JjaSXukY+NL3jVDnRN0m/juLPbaa8Uli2mqHjUr9RHIx4JU8B5smG0W5d6GeuO/LXavqMPjlPmHtY/GlbqPzXtFH3GyPixjLg7V0w5tP0btiv0k+0L3o7nwa+kUsUfvC0Ppgy9XWcf+Nr038+P2+waSCXqjIzYq90+dj9LFb3huh49BkdJm8WWLpOTGt2mvS2wm0fhkItnKxPtUT9WxzOsmv8ti7OoKrL0mPtWl8y4zZSy/YXVZUkj7pPR/oJtJL1LIRkypU6vaG+1jHWGkVU+YZWqUbIVjOzK51wvhm4maZUMsmQw0jUMck1DvK813DdscZcxjOuQoai/sO0k6uLV2xA7UrmNlVxasWSJt6GsgyzKxgO1Yupo29BR9RTAqsWjt3jlrVbm3qQzUjNEOVTqPLVmNCtY5WTbrLY97H4pF0sam0MjpkPnVWxaFaHnyxeiZPabHXumVo6GePV7shTf3ibpcZStsM7KbFjuK2Oa7acbha+NXM1emMJpooo7TbDz48js/SYc7M1eo/Q48clfNuXjbVncU7q9B4uRMrhI1jKyt3Yz14Y4z08mWVpmZSck3dUbs8n0yi4r9THeOFjLa4MzGiRa9MZnZZX2rH/AFlSFtaMXTlc1R4rL+w1Q47PtWO5Nt9a8/RoKsZ73qmfvR0T9Qp6pWLq0zO24+baMm0bIfRNhqhnmx0Taw7fp108FrGiHh88vTGelqQLtWMJshk6TXa1lGPgulptkT0t4BZOGr8uQVpJZeqMFjlfpjM+lHq3vNOU2xIWjwZ+9GU9W/UHfsvWvLaRSLN3j2OwwJHukIt2aL3cd/5gZseaq3Fr4T1GkV92mTkmvHtKaYVhZjRHCqJuKUcOys/2Et8roskid0n2qu1TQuCDYqxE2sjG0c8pOTFVPeSbzVNNpdJhktKWefKJsyptUjI1+kZlWLqIyTeE1GaVvuIyBrNqbjPJJY6SMGZSen4Rl8SlO4bX2i0JNo21K9BpEkZelQzvSLeEOgonwF2+QSBVXpC3iBmG6y7QtVd7FNT8C2+wKDSqKNa4qqdNM72dVGVlTawtu8wre8M6Znjyo0jFFYmvIosd5CzxWpR1DR7wVaFrULYzJulUonwItINrjq3dRoWQXWJ6n/rYLezsTSTK700dq8XQUXKoeezCrM6C4Nb/AF70PEN5shyr7j5ntH95btlfsOGXFt1meq+muMsh4+PxCibjdHnK/UefLiu3ecsvlqVRW8QLMr/YCr+oc+tatn0FbxBfzF03IyWSQaJlpbWoTkkRzOzMZ9Shq4zaXJokVXMc2HEwNJ4Q1PyasrO59sc2HTpkMsisp6jbzPJj3L217ZuP4xrcZZCjQhp/kblvlFI5i0chnT4FlXwmNadJbtojkoaoZjC1kGjkOeXl1l17essgax5qzGiOS/UcurcbFao2qRWrdPQMymPG/LVq2t7QpHNTcY7U/YU1zHSaa83zHoLlFFyqdJ56sU1yXD8blr0I8p1/aDZDdSnn6hRZvZ1JcZF7PSWT2m3oG1GPNXIG1zj087WNizNFtJzZDN0kVyL9QvaF6TpMNlEmRKoLxSVNwsjK5Fsc6acrv6e5w/0gbvbz1FzEl3KfHxxtEao8zSfcefPjmXp1xyse9NGsu4wzLQytxLwhDnK3UYmGUXe0ZpqmfWZPmHoZGlkR2755bQq71U74enLJaPijJJu6DdHxSL9h4vZ6ApvLHHJZbH00PGmi6ZDRH6QX6j5XUcZchlPNlxy11nJlH1TcW7ovrZu8fO9qt1B2ryOXxx0nLa+mh45TqNkfFFlPj1yC0ecyGLxbrWPI+obKRyLZHePF9ZB2xm6jMw013et2peozzZFzD2hXcGyu6xZjpyyqzSK/SMrHntMEeQp0c3oWlGWSvUY1yDQsyhVrDKzGfWvtLbV6S7WYrLY0R7uoyq1NxRchSLPD1IYWc2Q4rP0nhrJL1RyFo8zJi6ZDlca7Tw95cOU0R47Hhw8WnTc0hsj40xxsu3WZSPWjjZS2m558PGmbqN0PEklPPljZXX2NqDalCllYXRM7XT8lk9rtUm2K30zZqaSGWTKl1D9X/p+ezsniKQ4tOqMGZl2x0Ghx8mfdp0Qto4cX+4k6PpnWeLtzk8bYW8TGeaZelYzdNxTBTbobScfpFBFtxYI/+oblsRlj4bPldMZuj4HKvvpI0MsnFs7K6Y6E2jzJdzSbC9qkmnoafD8Dc0jzuZ8j0i+j7CEwycPb5k6J/LCHheMsnfnf9Q6TLbPm3wi3GGlktqXGWaV9x6UeHbqgjQo0mNFHXT3mN+Tq8327fpoWXD1fmFo8iCLuCtxZn6egXbQj4eqdMZbsMS7pJDLHkZmU/s9gTYsvek3mVnho1sOAj66xsfdHGeflYrLHaSQ8uZZU6Y3c6zCOeV0+g/iCWXpkohnm4grJukPPxcGfI3NsRfqGrs+HB1R3cuteiW0q5WrtU0LjtL1bEIzcYVI41hjRKGOTjEssm6QvWks35epJjxd6S5NcfGi3NvPJbOI9qsXrTvHtScQiTasZnm4kznjtlMCyXk3Gukidt+npdubuhrSuY1kVE2llmem0wsUZfETbwiyTMDTEVnmUyzLQ2SSI5nZfaGoyx1DT/Jqqri6f5NONjCOaVh8QNCvTpmpUrKzE1VtQ3Nik9GhuXbTKq/3hU1LjsMuOz9UZNs/TG3MZPgamx20wXFKjOq2GaM2R4tNxTRXU+wSrfLHHDc0LisalVV6dg0bUjqJ5WRj7KyDLimxmXTsTaTwlkSp9l8RTT9oLrb9ozSDTM8J1FaNSzMLXuifqRGtOonIaFXfVhWjOiWI9aWKK2wVoQqyIGZ72srK+0NG5HV9pXTGWapd6at8qdnu/uxWxyyyUGtfaY8ta8M6q6Fu0aROxNlZxrZGpeIfqGyPOY8etP3jaldpi4SrMrMn0C8UNC5kUqHzKzMkhZcqhyvE6zk0+i9k6GWbDvuU82PON2PnHG4WOsylZZMdkI9J7HaIJTO2PF3TPaz231YbeIceTF8JPTZDG4mtUuizA0ZaFfEalkXpJ5+nTrHkyGrDbeehJhxSpt6yPqttOymO25ok0JGinTdHvM8almxWUNNlQz6m3XX3U9Om4Fkq41bk295uJvfpNedtmO3tDRHMt9xjhkXUjqbI2VzGU96dcYtpq3ywbD8I0atqbjQq0jOWWWq6ya8MLRtF+w4evZWQyyYqd0TL9TpGNd5S/mNojLH3TXY0nuBWLLCK0Zi06fhbCsozRsL0FmTNx8Fs5RcqhPqJtyNw03doVzPI3eMepvDtBOqWmZu8pPWaLcDTKZ5JDcjN8LNxZhsXMvuPPsM2QqdJrUrEy29pciJ+qQnVe7IfMzZzXFj4ky9Uhr4k7x9Qtv6A1VPDh48yfMNC8Yil6jllxXfhuZyvW1FbcNdDy2mVtyyB2hlOd425m9bZ1DbepTyVzvEUXMOdwrfyR6SqFm7p57MyfMJ9qlUx8a9o9LWZQ1LnnrxJu8Wj4gveJcabatYFkvuI6kUobU2qZ66NN0cillyF7p5bcgWRgr1lmYbtX4PHbKZRo83xDSvcXK8Q3aF8jyVylH7UpnrDb01yPCWjzGPJt4ZBlyGQtxsXtXtLlN3ikeYeLHxCpqj4lF0mLjVmUe0uZbpNkczHhx8QiNkeVB9Q42WPRjlp7EecybTZDxBu8eHHMvdkNUclzz5YS132+RjxcZd02XQaTiWHi7cWPXf8AUM8kcXejuNHj2+Wfp9x8GzZcjIzs3qkp/LIrh91pD1IcWsepJITspqTTPV5/ZYkk3e0LQ4bdUcBobIii6iM3FmXbHsN+y6+1ux5LR+BCcmKqbmnv+mZazy7mdwbDZffd0xMWKs3Y16faE+3d3HjoT/0ybtMG4lAvu4zfWwl0JI87K+o5NuF5LyVFk443THsMsnGpek64Y3253LTYvCYvnTlLYeL073PFk4sz7V2GHIym/wAzrjh2qd4+gyuNNSq7DH6wZ/mHgtkMKuR7Q6XCRyuVr3O3C+uGi6aHitJKZ5MhjEx2navam41LL1SGOTKPPVr7RZGOsw16ZuVamm8Qup+THqXBW9oa0xLts1PZi6hPf1E2koNaNtCyKWWRTCsjd0GmOdXG68tyzDLkMef2gbtBnrHWZPSaYXWQwrIzgZ1tLk2WGrcyq1SiyBVNMZYxVkKLINCei5RcWpTUKWsBPs/iBce5pOqtyJtn0/yN2f2horTqATwM/Za7hey/3mppKE9Sxs2z9n9p9gzQmhaiqxSemeteoW1DQ3InJGbJ4RZu8IVqvT3yLL3SysWJv8QVijKLWm43vaSbK0niFWbvDMpNl3l3Il9DW7wsmRYNO21RWjoamvtjdNrbxWmuRkUnu8hMZGd6umhpmfpDU9ntM7NUXUNXxWd7bI5vZjdocw6gyzE6/bVy09JZrlLHlrJ7QtrUMdW9vQWrjaaMYe1fg1R5GzccnRbs6uK0KOKsxRZjO9NIsotmQ0Myk5GIgXIdNpoXMYx2FuZsjr2r0u2XDtX4PPVgaQ4XCbbmT0lyCetQwxzd0GmHSNTPb0o86haHiDJuPDWTwlFkYzeNqZXb6iHiCy7WFyMdZfdniwyd4tHnU6Tz5Yfj0Tk3NUMssUlWk3i2vJVik2VqmObILjx7c9tSt4TRDkUPLhmZ+k2K1Oo31kXHL9etj5DNJ9hqZvCeSuR4S0Mx5Li9OOUeguR7MVcj2hjZrdIKzN0jrFtekuVYpqKx4rSMhaHMp+wnx79NTLXt6jSUM7ZVCcmUtDDkZFzOOHlMs9NzZSORaQ81shlGXKZeo6zH8Yue43ayCyNY81srwk+3Ma6X6Tu3MxFmItnE2zCzGs3KVZpKE2koRkyiLZCl62s2xsaRTHNJsM8mQRbIOuOOox2hpJmoT1Im298XVUzsx6MXG3S3V0k2moR1KCySXJcds2tEec0XzDZj8abpaTYeGzEVmHSVjvp9Q2Usvu5KDLkSp0nzK5TIaIeJN0mfhdZyvolzm7xSPiVeo8Fcy5RZDj8bczl8PoO3QP1Auk3u5Dw7N3g1Pwcvjamde9V4tw0ecy9R4sedJEnvDUucrdRzvHG+z2oeJK21jRHkK/SfPq1ukbWnx+neZvG6zN72p4RmZe9GeLHxZk2yRm6PiCuhxvHY6TPbQvILd4XWil6QFjS2sxZcpqGPoCzGWNNy5AyyK/UYVanUNqF0r0lk8JRZjzVmKa5nW2pa9rHyDdDmMh86sxojyDlePbrM9NENU6es0XcxwtTcwzZDH1Lj58Pmy6UZWbqJ9n/UJzZGwjJnL0nfHGp3i02Ov1LkVhVZLMY2ztXpJrrttU7Y4VyuUelNmaSbTzZMqfI+wtHgt1ZEn/TjKSZUUUdVLMdJcnlyNL+8Fw55Ut0IapOLLF7uOMxtnSS+71HOjjaPV7NuaSimPIVYunoKSa/ejFWGfTs0e07b1NsWMO5CbMzntY+Dq9WwJsNYvmXLLPpnra8VYWaQ1KsWP0yajlMiOhPHxV6pBfKSeU5JDLMx6UmgnSYZo1aTaTGrkytMqGdpj0F4fq9RTsMGP8s3cmOteXHqy9MZuhx9D3nWW9kj7RZF9mY+9NSQs2VQwzNqyWNWj4hpFU1vSaYWkoEe6QaZVvtKY8ddxmkmzLi+Ip2dAZmoKzGdt6UVRRWsgyxs42aorYqcrQtHH4jO5vZoqqWVfZjLGUqS3V26dSxqaSDMNHZjJK0LzGZu6Z9o0jKC0y7ozpJdoG2FGBVFreQpp/km11/pwRlLR4vs47dY2nRy7b0y1YpVtQtpsgbfMm2EWhuRaGxusrE2qhvZZpjaPukWW+09Bo1I6KdQjHthZfaVYV/ibtG4rQ3Ne0Y12haw0mPUjWm42uiyR3ItGxZlfqJszGt+nKzTKy1FZfabjRIoadzVv2yz1BuRoaEGjVTUu1Z6jK3iLVDTQzKuiruNEOwn0yVGWQ52bpb1rQsgNIRWRQZjGm/UU1GYVrXGWZekNRWJa3HTmoKzEjCr6neF1GQmvMG5mbG54U1PaE9T8nCFiaWNWpcpHIY42LKxnWmpdNiyC9qoZV5jX8zEi9t+mrtHhBprGVmXqC3hGtLctLLJTcpoXIsee0gLNYaXb0mk8PQUXKY83tGwp2hukxcFvJp6UedSQ1LmHjx5Ch2gxcPpqcj3GmVjPJJTpPN7UwnamJjx6dJySvRabvahHWvuMfau6HaP/P8AMswXvK2aihreIx9oXqDtH/n+Y61O0q0imeT7hlmoTkkua8xjK7TkmYj2hykm8zyRsdZ5c7tZsgVpLmdlbvBRi6ibqjNbqIs1+kZuQppz2m1iO9DVp90VozW9LWfUoFrlmx7k2h7oTRaIK2OoVZRWZjUhU5MdiLKym5ZvEKyq4lZ0yrkVKR5TCyQkWjqa8X2m69CPiTKaF4grni2oMrHO4RqcmnvWifpGq6blPFWbwllzGQ5XjdZn+PW7QyDLmMknvDCudfqKLkRHP49Onb9eguYr9RaORW6Ty1micssa9SyHK4NzL8epHMyvtkNUedKh4qsyFlmZDncG5nXvLnK5RZr9J4seQU1GfpOVxrp2r2Fawx5azMhaPOY5da69o3fuGXkZ+2I3UU1InQxZpdqWZBo8gjYFkqJdo+mVVTaTmjXuyHlyZl5K9AqzMkm4+zMde3zJntSZZ32qRhw8mWOzR0Q0LxJYvl3covFMl4/d7DTXiptj9gjtpkZMpkjsuxzZ/rJY92OLHgtlPabrLPDN8vHmypX2x6juxqh9H8zIj1MqTsqH0EOC0Sex07/UMs0PaJPbT3M7v0dfDz+w8MwPqZT/AHkZONRJHWOONEU0ZWLhxblkuY5MfBTqjueiecXHJP1osslm3uWbii3tpiyaTbY4ERCKxqw1NeUTyOIM/UZ1yr9MZ6HYYn3NGY5IWi6YyBWmMsjMbFx7JuGXD1ZKrHsHaLMdsePj36jV2dfAaOyyp7uMzyY+YZubcwpWqhnbe+41Lw2WlpOsj6vYdonSs9V7pOT7T0oeDztuNEfCYotzdZO58e3z7Qs4zYLaZ71YopNsdwaTV6jPetdPx832NrlFx2PYm0u6T7Pf9he1Okebp/kaPHuekuKqbmDUiTpM9q10jH2NnKR4NOqQt2hUIyZFjW6l9GZUQWyE7eIVm3hj2s0gupcQdYyIVmG7g2nQZVN72a3SqrN0lFj8RSFSyrQzvy11TWE0Lir1DXQLXJfLcxhqAIcZSJTWJtIM3hJs1DpKtnnZlkFkkJyN3ibSBytWaYW3tCB2xqxlZmUVmIt4hbUNaFGkFsLI1ScjFRReRnm5itMxGTIbTNaY350aTcRqGqT1rmpkLN0biLSU6SbTEZGuVmrSZFP2CrIZ5G9mLqf+tTrJphsXIFbKbp7hl1PwJqKTUS2tet3hWmMqsNcVLlqtFw1mUys28GkEJfG2pcgGyt5j1BdTxEmMdNt3aqDLkHm3G1P/AEsY0sy09LXG1TzVmGWRrnOx0mT0lmuFlMasWWTunDTa1PIFahNWBjLayyeENT8EVkrtDUqVPTR1nTIslCiyU3ETYbYh3UU5qW/YKq79vcNQt0tbwi38xDjNUyLLINqGXUoTaRn3GuptsbIDU/BhaQZZiWa9Nb3dtDTVDW3kdZWF1Lhq+2jVFXIM7N4Q1CJjf1s7R/5/mHaP/P8AMx6gagLfLdrC61zDrCtMXrCZbbGkJtMZe0C6lizHaWtGoTaYizeEmzG54crWhZhlyDKzEWY3qVHodsZC3rBH6ozx7ONre0L1XvY9ZZFYbTRjy45KGhcihzuFdJnKs2L4TO0bRGqPKU0LIkvUc9WN+K81ZL9RNo+8elNw1H3RyGObFaIsqMckYrL7MszVFbxG9uNiKq1zpY428BdShRZrk6eQU8hprssshojymQx1DchzskrXbT0o85jQvELnjrIMshOn/jcze4uUr9RRZGptkPFWZiy5Bz+PbpMnuQ5DJ1GjU8R8/HlMaI+IHC8bp3euOs0qHnw5VzV2i/Ucrg6TP9bF4kvSxZeIRdJ5rKrkdMx019L3r66Phs+VJZTdj8Fb5kkaEcrjDslTzZuMN3j6txuXqvn+I9xuw4HTvM7cal1LR6aHz8mYzEWzGNzCszkfRScWll95IZ2440Xuz5+TKZ3BZPqSUNXjYuVetNxid92oZ24lK/VIee0yvtFjx5WSq9BZhMb5O1sbu2XI+sO6u8I8PS6iiyLFuUvienDa0ckr7u4WWSiGNshsjpNEOKzbpJDna74xRZmfpNWLjy5Ee4aORcUnkcSaXpOfn6dY2LiwRdW8sqov2Hj9q8ROTiDP1E6V2mcexqfgnZeo8dcpgkzCfHWe8j1JspX6hdZVPHbK7zCtmGutifJXqScQbpUzyZFjze0X6iiyKCZbbFZu6LIzd3oM/aO6K2RQjVWr7QVpm6e4T1rg28i26ickzdJFpLdJatikePcrM8xlVb7iy45ujjVRqqCY6YdEVcWx6DRqNsQztesY1x6g0Js2+Yoh1jKsbFK0NCxgyqT1CI9AKxSgrRiVqyfRb94O0FNPYK0JdmiyZAa4skZPT/JbdRzvtbWQGkViOn+RljKfY3A0ZSwWBcS6OwFjGZhtTwl3V6otCZ5lZDU0gqyULLUs2zrGzkWh3m65Ni9nK4vPYm29D0GhuRbHOsrNjz25CspsaGnUL2VCsPPZfEKy7DY2LvItj2NzJhh/cK0homhM8inWMeiscOW7pNmNJ6qlgZlJs3dFshbNMKaji6n5JswrSEWLWJswt/MW1yOhr+ZUzalRtS5KLWKLIZ1YDlpr02a1Ciye0MNiisYy8ukr0FZSit3Tz45DRHNY43FvbZs7pORVcmsndGWS8dTNmnX/ALFZQbYMzU2is1tpGMpqwup4RmkFqRkYsS+WhZLdQaiuZdQXW3mmWpmsKzU2qZ2mJ6zG8fxL4aLX3E7E9T2gWLlFnhSwXYjqbw1GMptoVqhrmewWJqNrNJcVmJscIp2YNT8k25HTU8Vn0dmFaRlF1KCrJc6TzGdjUcXUp1FLE2jVjTJmmuLqeIm0YtvEGTSN4RWZgXaH3HSIFkuM0gqfAQKuslDRHkGAdZLmeu2t6epDmMhsjzFf3h4eoNHkUfacssfDp3r2JMdZTLJiix5RoXIt1HHTpuV58kbJ+wVZD0JI7pYxyR+0N7ZymqWwykW5gvM3rbP3pc60asRViisTRRp91Ra+IpULeIy0OkZWFtcF8RldtEbXKR0MdiisZdJW5V7ylFkYwrI3dNEcjGdG2xcotHmUPPWzdQyt4jl0jpt9pJGv1DHMq90GmsT027x7/TxW2lZiO3yNHZ7k9FVk3G5lHKpHWjV03dY1alFqaa+kVX9M0LJpbSMkl9pFo2fcZ91Oti0mRdxo8dm6ghhVNwzZFXJrTUx21R1g/eLJnU3amw8+bMa+0xyZXiJ1uXtLdPSk4hb5hGbOY89Wt0jKu/cLNLMt+2hszujajmOzLtUpVm2lmvo3bWzWohGTKFaNhWjIK9qUTUZ+kWqoGpci+Yo0gyyE1Up+0zWt6uwv3FLKxGpwaXdaVYZWM6sMzHN021WG1KGexNpqF0rY0wvalMLSEbMTUZ7V6TZgLkHn3cFkLqJK9JZgWQ89ZKDLkDrpe1j0O0N5jLkHnrkX6g7R/wCf5i4ym3qdoGbIU8vtX4DtX4MdJVud09JZhlyDze0L/wAg1ydYsy6vQaRWFVlMesvdJtMNbO70tReoXVU83WcVshjcw8eUub1LITkkqef2pw7QzjqlyrZ2gXtH/n+ZlWS4MxLPC73NNTZSoK2QZ9vkNTyDEtWWYO0GdlGj3xhq3TR2hu6LqUFXb0i6n4Nez2WRvaWJyTKM0iuTaptyoZrEWjKTL4SMi0NRlOZTLIpZmsTaQ6JfTDMu8nIrmqShnZrbTrLtyymqnuQVmHJNzKgbosKrAzC9wLRYLU3CttFZgzBYFYVmFtTaGlrlNQz2GWS5zrTRau5hrWM9vaVGWplWixRW37ZDOsillZbmG2qOQpYw2KLJQ5XHbrtsVgZaSbSOqGsxjqu90zNQnZk6hmqkdgZvEGLU2+0W1QFrc6M1OS5Pe4zMMqm2dlVmFtQtJHQzyCrKZm8QWI2ZxlYhfK1/Mcgvu7DLJUw2pY6Jawy7BYfRQKnK3NR1vhOnkTbYalj7pNobdJpy1tHoBZC1GF0fF1mpVk0mrBUo0JPTErnYVlCkpRuZSxdp7Z6OUWFSmxxWWnSXZZpNsehOhoVr7RW5k2rPVxqeRZeYyt4iJEVapqjkYZWV9oysphvflZZGFkjvuCPIW5osrHKzy7W7efItHqK1Tc0Ki9jQbTTDWwhrkxak9NlNys3G7TVtgNcZq6YtbFqUb9MFkGrsFoZ3pqQysNqd0nVgp5GS7+jNNXpNEeRsMbKCrUtm2d3e3qLnUGXMPNsCsxmxvdfoWn4QkjoaJo5fpmWT/vOm9uYkyFTpM7TWBo2FjVnfcdpJEpdzvUXRZn94ehDCDQrFGYuX4zIxrCqdQsjGiRlMrbCKnJkMsde+TtfaUaG/VILpqibTpMtRPP2WRfCTVe8WXwjR4tRc9elk2iy9ofaN2O56Ucfd0xo46RnLLPa6jD2NYo7DKtEspqmWxFmbpM43fhqItJ3mItvLMoqxnTS1naNtQssLGiONQtQzWMptnaMK0G1Lg/xLrYn8oogtvCK1jCm6QsKzDWLva01qk+sa14xDMVxlBVHAgU5agynTYkzC9JURtw2hWZgsM/xCnkVC2Zxat3inQKyiILCtMCqTf4mtKpqFFkoZB2bwhlo1hdS5FWF1KEXflZpKdQWItJYVpDRto1Kh2gw2J3cG25sop2r2Z5bSMT7QSYkunsdqsDZVIzye0d4O2fgdDtt6y5VwXK3nmrMpTtCDX4srdqE2mMq5BSw9J22pqfkGkEO1QMlqRkUZmbug3M1YM7b0ItGatvmRbebnhzuPllZSbMpZozPIp1YqbMLqfkVmJv8AEsDWCxOwz/EVDWBpCNg1KmbNxd6UHJWGv5nO3y0Zt4ysRsMsgvhZ7W1KDW7xG3hGsYdPtqVhre0Mtu8UWTYRWppGUZWM6yXFsY0sard0a1+kzqwy8iXwe1Gk7oqsChJtNxnYZbDKtSatUZpDSbMykZlKWFbeCM9b7g0/wMpoX3ZjW1RX7SffNDRk9P8AJOp2L9o1hahUVray7Ckc1SK7gVRpvbUsilI1Ux2KRyEVuWMGhVzPHP4jRHNTaZ1W5lKjJik1xTVa5RZFQbSYvNaFk6Sei57VYm2i9lVy9rpmYR4qq3eGses2KlDLJimpkZY+GNYxtNSywsNpi5JMYj2Vu6L2OU2LcsrGZlprUeb2eUFVu9GeszeILL3jG9r0jybDLIyHpNDE4rYsTIa7bOrL1jRtUsuKHZWMbaDbxWUbRZRVZu8RpORVb5ZNoamqyv0k5FLtllVQ2oUrsFVTV8oVVVw0/wAgzKhFsodKz3jRQbs8Xmee2Vcn2jwmuljFylr1mx4vqCrjnndqYePOYvRJnK/UpsieXbp7CLLcJMpulSbavSse8w6dKosa6YLIsSDQ4c7/ACxm4LK72aShm5kxrO2VeMytNvPSbhK3tqdBNsEdoXGvP6dwaLMekuGrR2XrGXDl7sZe8OleX2W43Y1Q9ZeGt3g7C1zPf/1Zx7eesKINHH3jc2KlDOyjtsuOonH9orcijNUm0bOWLMdpEpJN5s7GzfYHYzW2NMOjvKaJq0aCtsEyrXVnbwk2U0NzJ1uGGVowWNjZ2cFjHapJWOrIKysbtMVo1c01Yx1DT/JoaM4ZNaST4Csw1Af4hdEHEHv5ghWUKhY4FcqL1DMwtixkVFf4hfzF1PybZMTZgZhbGmSswhWtxaeRSAVuZwCgJVY0U8hdPxBlFrk2Y1SRmeSECbSC6iA0bGeSyBKtYQg0nsw1zTJm5kRtS4r/ABNKLNewaw0YslQybtTL0lFyjMdqWTa9q2LlUGXKMA6fAzr9WVuXIsMslzHa4ysKm2jUuZZJBm5kX+JWqZpLmeQZmJuajlfNTYnfzGbkK/xNIWwNzOAW3cRxiLcyjchesyC1Q1HFZThK1FjlqCjVuc1NYonwJD2Mr6i1hrUIruKL4Q3tSNi3UZY1oUqovmrL5WXmMTVhlYG9qWoDNYOoXckhYl9kO7vIqdtsN68onfzC/mFak94FOpxqill5jQ4caMoDbjmJ7CbRmhVGZV0wMvQUVqdQMtRlVXM6XZlXusDQ+EaNlLKqsc3WMrRsnSFm7xa1JKnTc8NORzVGaQVlF00HhndWWahRci5jkhHJMdkybbitIZ+0ILqGerUzUk+0VWF1A1kNM7U1gWS37ydlYFqa1tntpoZrCtkVI6gtiWFyrRqfgNYz2DU/9LEuMamTUzFFmdDGsleoaOQx1tXs1doZAWZHM9l7wy7xcW+22iquLoqxGrJILqOpk2o2Gxlkx2XpNC5Tagy5XiNeh5rRt3jK2Ox7TaTdISY6mtudwteC0bC6f4PYkx1vujIyYd/dm5l+sddPL0+6NU1SYbKRkjY12jHV+9Nw2LUKR48UT+7DWW4rTU3Hybla+xNQ0ioZ5I7lGm7wrTGf9J/llaGm0XstjRqXBpDcrOt1FcdUFt7TaDMwtPI0WBpDPkNL8sowuoyCY2sssmrK/gJ6Bs6wWM0xdT2zx4fiKMqlG2kW5FQNyJFas4VZ9pdqztvJ1obOzitGptjqxspOtTVIpNlGzL0iK3MYGahpImxw5JIRZhWjNzJ2oLfzFZiuV9qWuLfzJ6gtim1NT8i2OCMwIqcsTv5gXR7NYVmEEsa0yGYLA3I6aYcXkCsKABcL+YgF0bPfzEO2OGh3U/I1qiHGYMmXmDcxbCswa2V/iZZuRobmZ2UsZZ2UjTyNDKTZTbJailRQEAAHsIOIPuQrMACDhoX8xrCgAzMTZgtc4VCiP8Rm5E25iMuEn+JRiZoIB1uYrAcEHEAK2FbmMBn0FsUViR1uZkXO1I28JZWIvtU4vILA3IzoMqluoipoVthZGpU1Ubd5jV9oNU1ZsCyFNrdRIdPgNIZlGj3HDsbFTYrcXTuWaO+4FbeRoRx36iixlFVSjKNjK2wkaa3DSM2jKzDK1hpISPSZJ4WEOLINIwBYFkJryFT4GYu2xZrdRRWUy9G4NT8h0lbGjXukWUVZhtQliCToIF13dQdBdHtjkVtQZmbqNlVeMXRuS1lh1HFaShqkw+8plmhZeo6Syp5iiyDLIZ1jYtQ0y0alxBFsg1jPtTLYKi2GVroRBYI2qK1hP/kJFaVk/vKKzdRlUoshpuZSNiyeIFaJjOsgKxx012aGhVycmO3dJrIC5Td4WL2iixsK2qhZcjxA0yuc3TsisndYZlUsrKCx2JlPKbjGysTbmelpoRaPeXdntH6drUFbI7pjZmDUWJLN1nKYzbvMrWpcgI5jLGzNJ9hStHLZE3WrWJtMZ2VnfaKu/aZ6xuWtDZGwXWuKuKzlocVjFu1Kqt3Q07ubI8dSmkpmZangkZ1hv0jLilGmWLpMc3EqdJqY2tXUaGx1bqItHEpjkzGcXc5062OHaNTTKorTEejqJyZSp0mZjWe9UaQm0hjbIsTaY744anlPk1VpJiLTEZMgztMXrEue2hpibTGVpArcume34s0yitMRp5C6bmtLu0zTXBdwy4/iKMqoY2J1OjEmYe0NYVtwrMLYukUVaCtITaQnY1pnajSCsxO1wsa0il/ML+YgDS7PfzFsKx00yDlgY4AwljoABxmCooBfzBmEABG5E25lSTczTKbcibMUbkLTyKEA63MXo6TQVVFT4DLyBlAWnkLYYP2gIdbmFTgHbBYVmDoCBhW5HRH+JYgf4itzGFbmIjhIqSZTQVlOAcYDgncHJNzAF5nAOMB0BTisZ0LU8gv5i2GKKWLKpAeNjC+llKJ8CasMrGkakLadzOvMtGxprYaEXpNJxo77iMs9RqhItOoVmApHIM/xJrUNbxEVRZK7WLLMYZGuNHMGmxmGv5mVZgkahz1sizSEZo7dJNZCi8znZqiNahuKMwKqOblE7+YKxoWFRuy03GW0ejaMylGrpioTWliemKq/qGpvdi6IRn+1iiyDMoadxtQshZWItGGm4ZbI2XpCSNW6jGupqFLV6itbUbHV9pPR7oysFiVk1BWx1YFYovIejW2dscVoWNyqNQztery+sFj9oeg0KkWhNsM9QZSmjQGUqM6yUCxRVFqym1LYZWbvCtHfcTsyEFmkuCyE7+YX8zPU3tZZGGWZ0M9/MGYkm6u2rtTIN/wyu8Y26CdhcKu9P1rs7IMuPfqPYbDX5gLpJ8s+dt9GYyMK4dynq/xGqSb+wnJlKL2PH0XsKqMsaoRbMoRkzFJ/pncamZRZMhTDJmIsZn7VY1MPund6naBWm/sMKyeIWbKN44xm56WmyFMM03hFaS5OQ74zq5ZZ2jVGfKbumWxNpPCddbcfTQ0hFmM7SMTZmLJplaSbwk2kJHalUvWFSyw2G0DltvTPpllhKVVAaQm9mtJ6aqLTyBpCbSGtL206cZibSE2Y1MWeyjSE7CsxNpDUjG9mZhWkJtIKXQpYLE0+AysQFjoj/EWwFzjExl5AHUdOMwt/Mug4gANAAAGgCDitzKOABxmAWQkOzCBlxhW5DdYrcjYUKeQ4jKBPoFbkM28GA4Bywr/EAZRWYYVuZQhyo5ywE7+YX8xm5Cj0wVmBuZw63MquEn+JRThUIyk2KU8hAFEHEf4gIBxjgAcXkdADqlE+BNS0agdOqwSKKvIDUoy8yKsVArHIaFZTDYtHIB6EbbBtSpj7R7MVpqhGqZroYWk7rDdqqTbfuCqQzX6gkYyySUDWAtcW3eJ6n4DU7ygaFmNCtc8vU/JshmIsWp5BZkADClZrdQyyBTyBPgNK1KxS1zKxSNq9JjTpPZZLKKrVKSNcjYlVqWT2YyyGWOfxFGkUmk3GiygrKZbAshNG2yqDafhMup+CkeRQaRo0WcNG3UC5BTWuNETbFIyY5v1FFEGLRcKeRu2+RFod4XSMchaORXDRFaOpnQtVBWUWrDW8Qa7SoyKQNrNYXTRjbOmOoqrY0SY/hI6bKO1Y0jWgumaGFqXssx2ytbpHK08gp5F2zrTPTyHH0/ENolXTOyk95s07yE2j9oOxp+sTcQYXt3dPH1ml6hzzfDJ7ervW9spuki2UZ7Cq1XNWRz7VoaZnF1PwTszlKmNRueTadikcNBVkVCcmR4RraelpNhncGkIySG5johpJKGeSRnFbeUjjN6YpVCtylBtP8FKytGRox6Gn+BWhBJpjWEssJbT8ROSSnSF3oyqqEZJBWkIyMTpti5GaYjJMKzEjpMNMXI4KoamwVWKbDcycjDSMRZi6S0rMTv5jiMppnYf4iDiGa3APfzEEZiIozHBLC38yC1gsII/xC7VO2uT1PwCsDalgsKrBYIaw1/Mna4WDRrCswtgbkGQzB0iv8QZgAQ6rWFbeUdOdZwDQBGYopwCID19mLUCfSGnccUBKeQv7g3eQz/E2JtvFZRwM+xIH+I5yq6e00yWnkLUankK3MzQtToAaRIVuY1PIH+IE2Um/xKMcAk3MVij/ABEA5UFU6AHalIxaeQ0a3AbrBVpIMq0kNEcNgyn3BVY1NCCw2LpaxyNvBZqFMiOjmeTYVFtYZpDK0jJuF1RpWhpAjmM+p+RWbwg00SNcmshNpid/MyrQslCkclzKzC6lC0am+0srGNZDQrVINyyWKLzMcchZZvEZVoZlJrIpNmFbxKRWywyyeEyx5F9pSNqSEVobmRk2blKW8QrMr7SCNg3jLXpGVa9JBNrC61CjMK0d9prSxSPIt1Fo5FYx6JaGMzl4StX7SkZNV7wyyUCxS1iiyEV39I1PI1s0sswSSEa+EDJtZZvEWWS5jZgExK1M394txVkC1zKGuCspGrIFhYu6szC1FVhmYmllLp2JsuwZpBWYmjsmyk5GLSMTZTTNTVimotNor/EVloaXaiyA3XYjvGsFfeLHUawR07wLukObbp1VGZRWapF7Q1/MLgrWjF6OkmiXQ/cLagzWFqWRn3XDlS1PIVlNOl9JqpRVGFaShNMy7MFPIjrA0hZKVRmVCbSEWYGN9WbkGkIyMUqLIprTmzswtWcsyi1Ns7TZTK282SKT0yoisYdJorQViSaXbK28kXkItzKVwk/xKMTf4hC2FYG2EzOmg/xFsMzE2IpmYF5nDsbAUbkFTpyxAoqsDczhkOrDKxOwMwDMwX8ybMDMAysNfzJs1dwWAoK3MmzUjFVmNaFrUFsT1KC2KKVuC8hb+Y3SB04y7Bbe0HARbiyDJ8BZAF1BW5DKveFZdgCrtF65Bu4D/ErPtPd3Tp3eu4Le0KqfSDeIatxukCP7hxhGsUK1BWUo28VlCI9R06yiqoE2UXoKP8Sf2hE3+ItSlQqBOpRVBuRReYC1KRqMqjRqBZYbR2LRrQosfsxo4faGk0agrY9TRp13E2awR5+ZHsMcm83ZzbKmNVsgRlkX2ZlZjVNyMtSqZWCSQmzEZGC+ltS4tyNhWkJ9DYrHTIshTVCtCsW1DKrBqf8ApYyN0cxoWS55qzFFyKgepHIr7Sm3zPL1u8WjyPaEaapFp0hYjreIL+ZkvmrNNsBZN5Hq2kbUCV6Gpcosh59u8GsxWnqdQVMMeRQp2iw0jU3uyas3dJ9o7o0e3pMjQrMWWRXJrMo0lX3Eq3xDnY2ZX+wju8gWQhK3K3iGrbpMccxTWoTTV8raAtRlkGb7eszvRJtOwyyE3+Ire8FotJIK0dhbe03AbZL0jK1xxJE8IDNyIyDW7rC/aGd+XBLjMpOo00o0gNyIqCyBoVBlsNYLGWX3SrQZbdQ2nUKmHTY1BeoFUpYpAqjRxgrCtII6KiMxFpibZBqRjemhpCbZBjbIFaY3MWLltoaYXU/BluFzek3GhZCisZVYorGk3tc5UVWKK1gwWoMpZeR0LWRlJ1Nj/EiyhEdOwtSjMCqBOtxZIzRWoAeaykWU9CZbmORQM7KKymhlJyAZWJsxRibbgqbEylQ0yAVSiCqoxGjNyFACBW5nDtSfSA4lgZrC38wBmDuCtINfzAL+YCs1Qt7QAZhbUCovfAGkKLHsJ1uUja4DJ8BWYZlDoDOwgzcg2+Z0NEp5C2KLyJ9IA2xDg7/EVmsgROy9IMy6Z0QoWuwGXvDKvdDoKhahUG2DL4iqWpw6u/pBuYE2bwnTtRW5BlNlFZSjKKyhU7CtGUqKygTqKylqgy7AI1KJ8ArSMcIB4/eCxlFUDZC1y1jPjsaGW5pFF3oTrQWNhre0Ax5i6phh2bT0Mha7TH9wZZ5FMMy942TMZ5FNRWNuZF/iWyORG/mZC2JyMUk2GdmCmVimoZ/lArArZHJcpqGWNhzI02uFiMcgrMFatTYNHMY7FFYD0FmLanhPNjmLRzEG5ZGUZmRzOswahNLtZbCp8AWS4tXLEMzUBZiLchblRqWYtHkGOxRWC702a5ZZqnnrIMslCD0lyLBrIeeshRWA9DUXTBZDHHIM0hNNR6CzFNc89cj2hoWQw1GjUFbkZ25CrMZ0baLjLMZ9S45v0jXG1y1jz1ahZZDLSzbzPJGM0gNvJ6c6izCqxSSvSRVS+2hW+4G5AysZ2sBYFZicbDWua0P0cBLE5Mg49dt7WsLqfgytkEZJrnSSm9NkkxGTIMrTEWkN9WNtEmQRaS5PU/ItjabWVgsTXmFi6ZUsOQsUjaxBYZWBVGVbANGakJxxll5AdEGqK/xNBWY4dZRak0F0/wABWg5xh6SpjVFKWKM8i0MshskW5lkUyI2IuW6SL/EKztGRZTUykWUDOyjFGY4Rsg4gyqZCsoX8xm5E6lHDjAxwgBH+I0hNmCBuYvRIFb7huoKVg/aNUm3IBmFrQGYXuF0HOWFVvEM32kRZegQSzaYKxVUtQYizA0hEWv5g/wAScdtOwt3CqWFXwqCtYOgA0xahbxBYukLuC3iBmFbmUFrgrHDtie2TCHag3M0tFRWqMvMNvkAhxtg1bjMviIM7KKxRvCK3MHsvzQYoq94GXulROoqqNu6SiqARqD/Eoqgy03AEbUNUMlzGvItG1ALV9oNX2hNZPabi1rgTylsn3nkzN4T1JmuY8jH7ymk082Q4dkUVWCFkjVjG0dTZIRZQrHNvj3GNlq5um5mNlCp9ILyCotPIyKKxZWM68ilgKWCwqsNUAsNYNMbT/IQKxRWJqviGf4hWhZhtYyqwLIQbFyKGjWuebYpqfko1M1ybE9S4alzNVaxRWM6t7QZWNFaGYNQizDW7oRSOQssxlj94UVvaVM1hsVrjWM6sU1PyaaWsUWShlsUWSxnTUumpci50zfNKXM6IpULEVmoUZlc0X2pqfkbUoZWWgLMZNtizFFmMayDWI01bXOEI5KFNRWMLDWFb3ZTb5CsD0jUGjqUVSbW6WNzyj7ZpGItIRaYmzWLGVmkJsxPU/At/M6JbaZmOnF5HQABL+Y4ZB1VGVSyx3NKiqmiOMZYSix0KGjjLRqLGpZVIoT4DKp07YWJsrchSoi8gFp5AD/EAhDjDWI2vIFiiqGmMvM4ZVJlMshqZjOygZ3+JFlNTKZ2UCLKTZSzkW5BtGQWozHSMwiqUqCqWVSKzsorKaGUyv8SKmwrMMxMIBW5jC9wqUV2WEO9YV9oRTNzF+4GawvSULfzFsC8wXmANUF2C6isKu8Ksu0GUQ4rWGhRVFZt4yfAFX2dRpArDMxGzag2orlTZla41ia7xpFIoZrgzUJs28bU8RpTE5GCwre7IyZd4rciMbFL+ZRZW8Qz/ABJ2Sn3gzXjsAzbOoVdgNujOhDp8Cbe73DdG0K+0Cp1FVWKVrIEjN1KBOnkOSVW1Bmbu6fSFT+ZZiisTYpGoZW6gaMWNu8pov3QMtqDKw1birseoFrX3Da1EFaMnps8YDMwM2wizUDU/AGHKX2m3oMshqyPCZZuYCruJyMdO1vuLtGOQyyKbmh9oZ2jqUY15DVKMtBfuMhWUVeRRlJ9IU5VeRFWLK2wCi8ylSKmhQOEqmipHoAi3IP2jagrcgGWQpczp8BwLqwWIqw1gKWLRtdDPfzKLIPtfS3SC8ibMCsEalYbokM6tU0KwDWoN1E2+06BVmolRlbYZ9T8DK3iIfbcsgfcZY2oNYzrSW6U1PyMs3dI6iE2svSaVuWQnJ9pnWZiiyXMaDLJUosxFjoWLrJ7QpfzMdiyyKo9tNSzUKLIY9QbU/I0NSsU2uYVkKan/AK1Mj6SwWJ2OnZyMdXmcOrzLUMOInwKl004qjLGC7BismVTRHGRjW5shjLCUyqNW5RVGVRAqxlKjLzCpkKxw7YXvlV0Y5Y6RUn+IU8hwAky0BVGAm1K3Mm3IozE2YgV/iIO/xJsBGQzspsZSMigZZFI1NTKRZQM7KLUtTujLHYKmsZZlGVTplpBlM7KiGqQyyFEW5k6s5SoVoT0zU2jFp5FQKRBlVOkVmXpUozE2qu7vk00mzUFteMJKuLYrMFQ+aFidvaA2AT4CtsGXYhQ1hb+ZNm8QRsFaFbeUrYz6ntCitYiBmBVr+8WwNyKKdG4WRvaCq3dC7hA33CiyNQWSSgbCyPr7hpmtGZ428XeGt3dQMhWKJ9xHuBYI0LzGViMci/1grd4C2pQZpu73yP2llWu0Ci7OopJsj2kWk7oysQCr7SzE7b6lJF8RO1CibM3SKzKUrYmy03BS2uMreIF95tBpKJ94RZWXTt4CyreOxljk9pUorf2AaTlaSCrIMrW2gUtsqIcXkTsBOTe5ORvZlyE2wCMjXMrR3NjMTk8IGVYb9IabKaI9m1Rm3gYWjuRkjuegq90jJH4QPLkjJ1rGbJI6SGWpaIhWxRlFrSQQSKryBoxqkDRqWXYTXaUYAYjIXJMoEgOsorKAvWLYYAGXkFhQApY6ctsCxFWVhySsNahUUXmaF+0xqxZWYKqPG1ydrbhlYzd/SrbXFZRVYbqEZN+0ZZO6T6QbkX2a2p0SDMxGwWJFNUNyHQIHuUshGoKxBZmJi2uHUU2ssjDan5IgrA20alwVjPbwlNQNPrpBU+Arcxk+B1cVTtjPYZWDK1iiqZ7Dahra7aLDKxnVjRGYqtUa0NkbGWM1QGlWjUZmFbYTZi+0aFYGYirAygHWOJfzGVSNbDchqjaf5CoCHajVFZiKnTyBmFZhWAVmFHEf4gTY6OyhWpkISoaFW4UAwyLQiym6aMz6dwJxw2LaBaGEpp/kLplaMiynoNGZZISKwyKRZTVItDPIpURZfCLUtQWrmRnZaE237izbhe4EZ25kWuaHMskm80JtyDU/9LBJJYWy0ClVryBIMq+zspNm73cChmZwZvCFhmsgTSfy/vFv5jW9nUm32hAszX2mqP3djCrN0qaIZKR7iKpNyF1LA3y2YnM1NNiotqW2gnuzOsnhLR+IKWRr9RnZvaFG2biNlcIawWu/2Bt8xtqJtAZd7g1gjoEn/YFKrLQGkoHR1DKvs7BDLMamX2cbGOvhNWKzd4AjXeaE+AvRuBeZkLIy6f7BZHfujSL7QT/4mldt7Qmzb6jMq3sKv/wCJsoW7w0m4VWqA0e4aOTeLZnj2gq1Asu795aNd5nT4FFbeBcRtwdwG3oBOtCfWUaMVlAzspObYaG5kZF7wGe3tBlk7oriAOzArE+jaFgM+QvtDOymxtxGRVVwMrLvDTuWqCx0LsRVQaP2horYVlIFrQKgtlGbwgTkJtzKVJtGAr/aHWFTgCX8xV5jCAdscA4rAUC1RbUGv5hVLDLzJ2GsQWVhlYmUViVFlYnavSKrDNzK0ZZCyyGe1Br+YjKzMNbukbDkofrAjYaxpYorDMzEVY6YaaVYGZSN/MNwngOdWwWQayuVnRl3BTyBWoBlUW2FlkFbmTqB9tTyFsMTsd3N06rHDq8yxnZk+A4hRVMmlI1LRk15GiMKshqjkqZ15DlGlmuLUI1NCqWKWOMZjp2o9Iz1LKNUoqmWvQXkKzDkQrik2Yp0E3+ICCjHagTqDchztTIWtzg7cxVjAFDrKUFVQJtGT0/ybKk2WwaTVRljGXmCsELUnMuwozE5FCsMi90jIpsZSLKEYZFJyeE0TbDLIzATrWOxGRjRJtM8niIJuZWa8haRqRk46oSIjWhFmLK1nkI1vuY0KbSbA23TCSSgBGvsxWYOuP7yMm/pAL94G9k4yr4gZd4Ct4QWTZUard4Vq6e7rCmaa5PUu4tvZ2D7gii1SMpbZVSLSd0iysgFm5EVjVOknI1J7FI20o7AMu/UUZYd41r7hWZu719YFFt0g2wisn941vZgNJJaSoad4xV8Td4pHuAIfCbo2XTMcMbGyGOnUBTqk2hX/uGXvisvs9pn0GkXvEVYsuxAp5GlRrbqBmUGX2grLcBW2BW4zKAInHGw0gqjKtQUW9oUqLp90pbuqEUXf1DbvMkVay6dQFVbkZFoaPtFkqu5gMrN3iL/ABNEy0It9wEW3k7+ZbT/APSxP5lWAiy1FbkU69osgEe+TrcpUWtAOHbLpi1oDcgD7jojNQVmA4dtcVvEcA7YXqFZriqwCt7wVuQzNU4AgqqM/wARW5gcOMozKFQFY6AAA5Owy8wNFhjOsndKKwWqJ8CpJWGsAMoyi2BeRBS1BmYnYLEIaw1/MWoqiChTUJqwrMI3tosGp+SKsMu8VFlYL+ZNmGXeZFGaw0bE6eQ4DD9W0mrVC3tCo+0cnUp1hWp1ciHVUKlFUBaeRRdgy8xlXeFMvI0LyJqpoWMCkZZVFjjNCqVpSNRzscY1bFE6lOgZuQr/ABHtALYqIZCAOzE2CuiMo4jcgFAQqvIyFp5AqjNyGqBOnkUVRqhUAqGn+RqeQ4EKi6f4KSE2agE22E25DMTf4hQzC2FVqbRm3gicjGeQt9zGeSQG0ZFV3M80ddxRuZGawRGZiLbyzLSMixBGZdliLKvtGLTbYCPcJBGuwi3hboLSfcTZfCaDN7JLKRZdVykkd0jJs13ANuoLXulGq+4WragE22OU203E2X3hRlXTCpybxWYbcvUKzXeQCaq3T3CbLR6qWjbxC/d3wgrfpI5C7NpqmbYZWZWk29wAar6bMNG146k5G1dqxjR2f94PtRWv1bBqqu0iq+7Y0K1uoKztGW6do0iiqtAha+7Y0Rxt1E6mizd3oAIbGiOTxSGeM0K1Qqis3UoLa9Ro2pu7gU8iIbTruJ1vqe0KL7sWtSiarYV/ebegt0oRZV7oCtS/3ha/SMqq7ip8AJsoy37wSLd9oV7oUMzezKKwv/wKRhFFag1kfpJrzKR2QBf3CsyuhRmVwZagRaMzyb5Nxo+UR0e8BFusVob7lKNyKV2AY7UF3PJtjLSKTa19oGeRSdjQ28y1puAJKJJUi3hLfuIrsAWRg+UHWK3vNoB0ijNyI29p9gDNzFqEnQLagA3IVW7wNuEA71B1C1odADlgZhV8IDKdOKwWAOsZWocOWA6VViKjKwGhWOElYpYLTdQLsFVgsFUso5JeZUiadVqgu84dXYFdO1vGKzDW7pUoWOhRWJqwxlpRt4q8hRlYp9qKxwReRRuZENfzC3sydgVTI++qdHVRlU6xyTVTo9PIZVNNaKUWMZYzRHGaZLGpojjLLCaI4TLURWM0KoVoCqEUGsKqjVIsFbg3IcTpKpX+IrcxusGUgnYWw1RW5ALfzAZVCpKBVHOKpZVIJ1GVSlRlUBahU6ACNyCwNyFT4AD/ABM7mh/iZ3+ICEG5lG5E2aiAKwKTv5gzUAGUzttLM1kMsjUDSMmwizXKTeEjItukjKc3Mjb2hRyLKURyCaq39pRmFW1yKVo+8ZZDU3hIxrUqFp5GdV3mho79Q1aARaodW1QZbPGU+1QM7LTUBtqbhobP1Ay0/rAm2/T8BE1KtdqitHcCQireTcWaOosn/wAwFmYjHtKTdcak2VgF6OkXvjMviGZabm6AKVqCt7SvfFZvZlOvcAr/ABKKvdIrfvFt4DVun7Sit/2k7XcZV31UAVrlI2bp7gbekaP7QLLv/oGjZvaW7pHq3KNWiAaNji+6028Ib9QppqiVYzpS27pNo9hTokF6tpUTj3pYVVKKtdvcCpROveBq94JNgN7zcFKtBmbS02FVqDa1HCKM2ywWZ0C14w02TaA0clAv5ix/cMALufaR3P0lOvTYWtNwEZFDd5DdwVmYCc0dDPJHU0Mq94nMy9IGX9xOTYaJF94xFl8QGWRmFazlOoWSwEV5DMoSN3lOASXeDbAkGtfcBNmqDe7Ft/eM0jdIE/uFbmMy0JyfaANsOHWYmnwAH+IX8xuoVwC/mOROrzApY6JfzABuoZhW5HQHXmMnwJ2GVgu1TtiasAFl5jdZIdWIUyfAZWFVgZikUqdEVjoDtzCpwczXQJ8BbDCqv94jBk+AysC8gbkEdOrsFbkMrBX/2Q==\");\n\n//# sourceURL=webpack:///./src/env_map/nx.jpg?");

/***/ }),

/***/ "./src/env_map/ny.jpg":
/*!****************************!*\
  !*** ./src/env_map/ny.jpg ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:image/jpeg;base64,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\");\n\n//# sourceURL=webpack:///./src/env_map/ny.jpg?");

/***/ }),

/***/ "./src/env_map/nz.jpg":
/*!****************************!*\
  !*** ./src/env_map/nz.jpg ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:image/jpeg;base64,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\");\n\n//# sourceURL=webpack:///./src/env_map/nz.jpg?");

/***/ }),

/***/ "./src/env_map/px.jpg":
/*!****************************!*\
  !*** ./src/env_map/px.jpg ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:image/jpeg;base64,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\");\n\n//# sourceURL=webpack:///./src/env_map/px.jpg?");

/***/ }),

/***/ "./src/env_map/py.jpg":
/*!****************************!*\
  !*** ./src/env_map/py.jpg ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:image/jpeg;base64,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\");\n\n//# sourceURL=webpack:///./src/env_map/py.jpg?");

/***/ }),

/***/ "./src/env_map/pz.jpg":
/*!****************************!*\
  !*** ./src/env_map/pz.jpg ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"data:image/jpeg;base64,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\");\n\n//# sourceURL=webpack:///./src/env_map/pz.jpg?");

/***/ }),

/***/ "./src/gltf_loader.js":
/*!****************************!*\
  !*** ./src/gltf_loader.js ***!
  \****************************/
/*! exports provided: download, load, env_map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"download\", function() { return download; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return load; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"env_map\", function() { return env_map; });\n/* harmony import */ var _includes_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./includes/index.js */ \"./src/includes/index.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config.js */ \"./src/config.js\");\n/* harmony import */ var _includes_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./includes/common.js */ \"./src/includes/common.js\");\n/* harmony import */ var _env_map_nx_jpg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./env_map/nx.jpg */ \"./src/env_map/nx.jpg\");\n/* harmony import */ var _env_map_ny_jpg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env_map/ny.jpg */ \"./src/env_map/ny.jpg\");\n/* harmony import */ var _env_map_px_jpg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./env_map/px.jpg */ \"./src/env_map/px.jpg\");\n/* harmony import */ var _env_map_py_jpg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./env_map/py.jpg */ \"./src/env_map/py.jpg\");\n/* harmony import */ var _env_map_pz_jpg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./env_map/pz.jpg */ \"./src/env_map/pz.jpg\");\n/* harmony import */ var _env_map_nz_jpg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./env_map/nz.jpg */ \"./src/env_map/nz.jpg\");\n\r\n\r\n\r\n \r\nvar HDRImage  = __webpack_require__(/*! ./includes/hdrpng.js */ \"./src/includes/hdrpng.js\");\r\n \r\nvar url = \"\";\r\nvar path = \"\";\r\n\r\n \r\n\r\n\r\n  \r\n\r\n\r\n\r\nconsole.log(_env_map_nx_jpg__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\r\n\r\nvar vertex_shader_src_default = `\r\nlayout( location = 0 ) in vec3 position;\r\n\r\nuniform mat4 perspective;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nvoid main(){\r\n    gl_Position = perspective*view*model*vec4(position, 1.0);\r\n}\r\n`;\r\nvar fragment_shader_src_default = `\r\n    precision mediump float;\r\n    out vec4 color;\r\n    void main(){\r\n        color = vec4(1.0, 0.0, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nvar vertex_shader_src = `\r\nlayout( location = 0 ) in vec3 position;\r\nlayout( location = 1 ) in vec3 normal;\r\nlayout( location = 2 ) in vec2 texcoords;\r\n\r\nuniform mat4 perspective;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nout vec3 v_position;\r\nout vec3 v_normal;\r\nout vec2 v_texcoords;\r\n\r\nvoid main(){\r\n    gl_Position = perspective*view*model*vec4(position, 1.0);\r\n    v_position = (view*model*vec4(position, 1.0)).xyz;\r\n    v_normal = mat3(transpose(inverse(view*model))) * normal;\r\n    v_texcoords = texcoords;\r\n}\r\n`;\r\n\r\n\r\nvar fragment_shader_src = `\r\n#define NUM_LIGHTS 1\r\nprecision mediump float;\r\n\r\nin vec3 v_position;\r\nin vec3 v_normal;\r\nin vec2 v_texcoords;\r\n\r\nuniform sampler2D emissiveTexture;\r\nvec3 emissive;\r\n\r\nuniform sampler2D normalTexture;\r\n\r\nvec3 normal;\r\n\r\nuniform sampler2D occlusionTexture;\r\nfloat occlusion;\r\n\r\nuniform sampler2D baseColorTexture;\r\nvec4 base_color;\r\n\r\nuniform sampler2D metallicRoughnessTexture;\r\nfloat roughness;\r\nfloat metallic;\r\n\r\nuniform samplerCube env_map;\r\nuniform samplerCube diffuse_map;\r\nuniform samplerCube prefilter_map;\r\nuniform sampler2D brdflut_map;\r\n\r\n//light variables\r\nvec3 light_positions[1];\r\nvec3 light_colors[1];\r\n\r\nconst float PI = 3.14159265359;\r\n\r\n//set lights functions\r\nvoid set_lights(){\r\n  light_positions[0] = vec3(5);\r\n  light_colors[0] = vec3(10);\r\n}\r\n\r\n//length function \r\n/*float length(vec3 operand){\r\n  return sqrt((operand.x*operand.x)+(operand.y*operand.y)+(operand.z*operand.z));\r\n}*/\r\nout vec4 color;\r\n\r\n//pbr functions\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\r\n{\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}  \r\n\r\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\r\n{\r\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}  \r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\r\n{\r\n    float a      = roughness*roughness;\r\n    float a2     = a*a;\r\n    float NdotH  = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\t\r\n    float num   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\t\r\n    return num / denom;\r\n}\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness)\r\n{\r\n    float r = (roughness + 1.0);\r\n    float k = (r*r) / 8.0;\r\n\r\n    float num   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\t\r\n    return num / denom;\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\r\n{\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\r\n\t\r\n    return ggx1 * ggx2;\r\n}\r\n\r\nvec3 getNormal(){\r\n  vec3 pos_dx = dFdx(v_position);\r\n  vec3 pos_dy = dFdy(v_position);\r\n  vec3 tex_dx = dFdx(vec3(v_texcoords, 0.0));\r\n  vec3 tex_dy = dFdy(vec3(v_texcoords, 0.0));\r\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\r\n\r\n  vec3 ng = v_normal;\r\n\r\n  t = normalize(t - ng * dot(ng, t));\r\n  vec3 b = normalize(cross(ng, t));\r\n  mat3 tbn = mat3(t, b, ng);\r\n\r\n  #ifdef NORMALTEXTURE\r\n  vec3 n = texture(normalTexture, v_texcoords).rgb;\r\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(1, 1, 1.0)));\r\n  #else\r\nvec3 n = tbn[2].xyz;\r\n#endif\r\n\r\n  return n;\r\n}\r\n \r\nvoid main() {\r\n  //set lights\r\n  set_lights();\r\n\r\n  //set material info\r\n  #ifdef BASECOLORTEXTURE\r\n  base_color = texture(baseColorTexture, v_texcoords);\r\n  #endif\r\n\r\n  normal = getNormal();\r\n\r\n  #ifdef METALLICROUGHNESSTEXTURE\r\n  metallic = texture(metallicRoughnessTexture, v_texcoords).b;\r\n  roughness = texture(metallicRoughnessTexture, v_texcoords).g;\r\n  #endif\r\n\r\n  #ifdef OCCLUSIONTEXTURE\r\n  occlusion = texture(occlusionTexture, v_texcoords).r;\r\n  #endif\r\n\r\n  #ifdef EMISSIVETEXTURE\r\n  emissive = texture(emissiveTexture, v_texcoords).rgb;\r\n  #endif\r\n\r\n  //set geometry info\r\n  vec3 n = normalize(normal);\r\n  vec3 v = normalize(-v_position);\r\n  vec3 R = -normalize(reflect(v, n));   \r\n\r\n\r\n  //calculate surface reflectivity for fresnel schlick\r\n  vec3 f0 = vec3(0.04);\r\n  f0 = mix(f0, base_color.rgb, metallic);\r\n\r\n  //init radiance\r\n  vec3 Lo = vec3(0.0);\r\n  for(int i = 0; i < NUM_LIGHTS; ++i){\r\n\r\n    //calculate light vector\r\n    vec3 l = normalize(light_positions[i] - v_position);\r\n\r\n    //calculate halfway vector\r\n    vec3 h = normalize(l+v);\r\n\r\n    float distance    = length(light_positions[i] - v_position);\r\n    float attenuation = 1.0 / (distance * distance);\r\n    vec3 radiance     = light_colors[i] * attenuation;        \r\n    \r\n    // cook-torrance brdf\r\n    float NDF = DistributionGGX(n, h, roughness);        \r\n    float G   = GeometrySmith(n, v, l, roughness);      \r\n    vec3 F    = fresnelSchlickRoughness(max(dot(n, v), 0.0), f0, roughness);;       \r\n    \r\n      \r\n    \r\n    //calculate specular component\r\n    vec3 numerator    = NDF * G * F;\r\n    float denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, l), 0.0) + 0.001;\r\n    vec3 specular     = numerator / denominator;  \r\n    \r\n    //calulate diffuse\r\n    vec3 kS = F;\r\n    vec3 kD = vec3(1.0) - kS;\r\n    kD *= 1.0 - metallic;\t\r\n\r\n    // integrate to outgoing radiance Lo\r\n    float NdotL = max(dot(n, l), 0.0);                \r\n    Lo += (kD * base_color.rgb / PI + specular) * radiance * NdotL;\r\n  }\r\n\r\n  vec3 F = fresnelSchlickRoughness(max(dot(n, v), 0.0), f0, roughness);\r\n\r\n  //diffuse ibl\r\n  vec3 kS = F;\r\n  vec3 kD = vec3(1.0) - kS;\r\n  kD *= 1.0 - metallic;\t  \r\n  vec3 irradiance = texture(diffuse_map, n).rgb;\r\n  vec3 diffuse    = irradiance * base_color.rgb;\r\n\r\n  //calculate speculare ibl\r\n  const float MAX_REFLECTION_LOD = 40.0;\r\n  vec3 prefilteredColor = texture(prefilter_map, R,  roughness).rgb;   \r\n  vec2 envBRDF  = texture(brdflut_map, vec2(max(dot(n, v), 0.0), roughness)).rg;\r\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\r\n  vec3 ambient    = (kD * diffuse + (specular)) ; \r\n  \r\n  vec3 c = ambient + Lo;\r\n\r\n  #ifdef OCCLUSIONTEXTURE\r\n  c *= occlusion;\r\n  #endif\r\n\r\n  #ifdef EMISSIVETEXTURE\r\n  c+=emissive;\r\n  #endif\r\n\r\n  //c = c / (c + vec3(1.0));\r\n  c = pow(c, vec3(1.0/1.8));\r\n\r\n  //set color \r\n  color = vec4(c, 1);\r\n\r\n}\r\n`;\r\n\r\nMath.clamp=function(min,val,max){ return Math.min(Math.max(min, val), max)};\r\n\r\nclass perspective_camera {\r\n    constructor(fovy, aspect, near, far){\r\n        //set perspective parameters\r\n        this.fovy = fovy;\r\n        this.aspect = aspect;\r\n        this.near = near;\r\n        this.far = far;\r\n\r\n        //set perspective matrix\r\n        this.perspective_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(this.perspective_matrix, this.fovy, this.aspect, this.near, this.far);\r\n\r\n        //set eye\r\n        this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 1);\r\n        //set target\r\n        this.target =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 0);\r\n        //set up vector\r\n        this.up =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 1, 0);\r\n        //set view matrix\r\n        this.view_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\r\n    }\r\n    set_perspective_uniform(gl, location){\r\n        gl.uniformMatrix4fv(location, false, this.perspective_matrix);\r\n    }\r\n    set_view_uniform(gl, location){\r\n        gl.uniformMatrix4fv(location, false, this.view_matrix);\r\n    }\r\n    set_orbit_controls(gl, max, min){\r\n        //initialize control variables\r\n        this.mousedown = false;\r\n        this.temp_mouse_x = 0;\r\n        this.temp_mouse_y = 0;\r\n        this.distance = 14*Math.sqrt((max[0]*max[0])+(max[1]*max[1])+(max[2]*max[2]));\r\n        console.log(this.distance);\r\n\r\n        //set camera far to twice the distance\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(this.perspective_matrix, this.fovy, this.aspect, this.near, this.distance*10);\r\n        this.angle1 = 0;\r\n        this.angle2 = 0;\r\n        this.gain = 10;\r\n        this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(this.distance, 0, 0);\r\n        this.target = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues((max[0]+min[0])/2,(max[1]+min[1])/2,(max[2]+min[2])/2);\r\n        //this.eye = vec3.fromValues(1, 0, 0);\r\n        //this.target = vec3.fromValues(0, 0, 0);\r\n\r\n        //compute view matrix\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\r\n        \r\n\r\n        //set listeners\r\n        gl.canvas.addEventListener('mousedown', (event)=>{\r\n            //set mouse down to true\r\n            this.mousedown = true;\r\n            //record position of mouse\r\n            this.temp_mouse_x = event.clientX;\r\n            this.temp_mouse_y = event.clientY;\r\n            this.temp_angle_1 = this.angle1;\r\n            this.temp_angle_2 = this.angle2;\r\n        });\r\n\r\n        gl.canvas.addEventListener('mouseup',(event)=>{\r\n            this.mousedown = false;\r\n        });\r\n\r\n        gl.canvas.addEventListener('mousemove', (event)=>{\r\n            if(this.mousedown){\r\n                //set mouse coordinates\r\n                var mouse_x = event.clientX,\r\n                mouse_y = event.clientY;\r\n                //set angles\r\n                var dx = this.gain * (mouse_x - this.temp_mouse_x)/window.innerWidth,\r\n                dy = this.gain * (mouse_y - this.temp_mouse_y)/window.innerHeight;\r\n                this.angle1 = this.temp_angle_1 + dx;\r\n                this.angle2 = Math.clamp( -Math.PI/2,this.temp_angle_2 + dy, Math.PI/2);\r\n                //compute eye\r\n                var t = this.distance * Math.cos(this.angle2),\r\n                y = this.distance * Math.sin(this.angle2) + this.target[1],\r\n                x = t * Math.cos(this.angle1) + this.target[0],\r\n                z = t * Math.sin(this.angle1) + this.target[2];\r\n                this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(x, y, z);\r\n                //compute view matrix\r\n                _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\r\n            }\r\n        });\r\n        gl.canvas.addEventListener('wheel', (event) =>{\r\n            event.preventDefault();\r\n            //caltulate mouse scroll\r\n            var delta = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].dist(this.eye, this.target)*.1;\r\n            if (event.deltaY < 0) {\r\n                this.distance -= delta;\r\n              }\r\n              if (event.deltaY > 0) {\r\n                this.distance += delta;\r\n              }\r\n              //compute eye\r\n              var t = this.distance * Math.cos(this.angle2),\r\n              y = this.distance * Math.sin(this.angle2) + this.target[1],\r\n              x = t * Math.cos(this.angle1) + this.target[0],\r\n              z = t * Math.sin(this.angle1) + this.target[2];\r\n              this.eye =_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(x, y, z);\r\n              //compute view matrix\r\n              _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt(this.view_matrix, this.eye, this.target, this.up );\r\n        });\r\n\r\n        gl.canvas.addEventListener('contextmenu', (event)=>{\r\n            event.preventDefault();\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction load(gl, filepath){\r\n    url = \"\";\r\n    path = \"\";\r\n    return download(filepath, \"text\")\r\n    .then(function(request){\r\n        url = request.responseURL;\r\n        path = url.slice(0, url.lastIndexOf(\"/\")+1);\r\n        return JSON.parse(request.responseText);\r\n    })\r\n    .then(function(gltf){\r\n        return process_scene(gl, gltf);\r\n    });\r\n}\r\n\r\nfunction download(filepath, response_type)\r\n{\r\n    //check if \r\n    if(filepath.search(\"data:\") == -1){\r\n        filepath = path+filepath;\r\n    }\r\n\r\n    var xhr = new XMLHttpRequest();  \r\n    return new Promise(function(resolve,reject){\r\n        xhr.onreadystatechange = ()=>{\r\n            if(xhr.readyState !== 4) return false;\r\n            if(xhr.readyState==4 && xhr.status==200){\r\n                resolve(xhr);\r\n            }else{\r\n                reject({\r\n                    status:xhr.status,\r\n                    statusText:xhr.statusText,\r\n                });\r\n            }\r\n        }\r\n        xhr.open('GET',filepath);\r\n        if(response_type) xhr.responseType = response_type;\r\n        xhr.send();\r\n    });\r\n}\r\n\r\nfunction download_image(filepath)\r\n{\r\n    //check if \r\n    if(filepath.search(\"data:\") == -1){\r\n        filepath = path+filepath;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        //set image\r\n        let image = new Image();\r\n\r\n        //resolve image on load\r\n        image.onload = function(){\r\n            resolve(image);\r\n        }\r\n\r\n        //reject image on error\r\n        image.onerror =  function() {\r\n          reject(new Error(`Failed to load image's URL: ${filepath}`));\r\n        };\r\n\r\n        //load image\r\n        image.src = filepath;\r\n    });\r\n}\r\n\r\n\r\nfunction timestamp() {\r\n    return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();\r\n}\r\n\r\nfunction process_scene(gl, gltf, scene_number)\r\n{\r\n    //set camera controls parameters\r\n    gltf._max = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 0);\r\n    gltf._min = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0, 0, 0);\r\n\r\n    //set all loads array\r\n    gltf._loads = [];\r\n\r\n    //set renders array\r\n    gltf._renders = [];\r\n\r\n    //set animations array\r\n    gltf._animations = [];\r\n    \r\n    //set scene number\r\n    if(scene_number==undefined) \r\n        scene_number=0;\r\n\r\n    //set nodes\r\n    var nodes = gltf.scenes[scene_number].nodes;\r\n\r\n    //check to see if there are any nodes in the scene\r\n    if(nodes.length==0) \r\n        return false;\r\n\r\n    //create default fallback material\r\n    set_default_material(gl, gltf);\r\n\r\n    //process nodes \r\n    for(var i=0; i < nodes.length; i++)\r\n        process_node(gl,gltf,nodes[i]);\r\n\r\n    //process animations\r\n    if(gltf.animations)\r\n        for(var i=0; i < gltf.animations.length; i++)\r\n            process_animation(gl, gltf, gltf.animations[i]);\r\n\r\n\r\n    //load environment\r\n    env_map(gl, gltf);\r\n\r\n    //set camera\r\n    gltf._camera = new perspective_camera(0.2, gl.canvas.width/gl.canvas.height, 0.1, 100);\r\n\r\n    //set animation function\r\n    gltf._animate =  gltf.animations && gltf._animations ? function(time){\r\n        //by default use the first animation\r\n        gltf._animations[0](time);\r\n    } : ()=>{};\r\n    var now, dt, last = timestamp()/1000;\r\n\r\n    //set render function\r\n    gltf._render = function(){\r\n        //animate\r\n        now = timestamp()/1000; \r\n        dt = (last - now);\r\n        //console.log(dt);\r\n        gltf._animate( dt );\r\n\r\n        //render\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gltf._renders.forEach((func)=>{\r\n            func();\r\n        });\r\n\r\n        //set last time\r\n        last = now;\r\n\r\n        //loop\r\n        requestAnimationFrame(gltf._render);\r\n    }\r\n\r\n    //return promise once everything is loaded\r\n    return Promise.all(gltf._loads).then(()=>{\r\n\r\n        //set orbital controls \r\n        gltf._camera.set_orbit_controls(gl, gltf._max, gltf._min);\r\n\r\n        //return/ resolve gltf object\r\n        return gltf;\r\n    });\r\n    \r\n}\r\n\r\n\r\n//load accessor data\r\nfunction process_anim_accessor(gl, gltf, accessor_num, sampler, is_input, animation){\r\n    //set accessor\r\n    var accessor = gltf.accessors[accessor_num];\r\n\r\n    //process accessor, bufferView, and buffer ( load buffer data )\r\n    //set buffer view\r\n    var bufferView = gltf.bufferViews[accessor.bufferView];\r\n    \r\n    //set buffer\r\n    var buffer = gltf.buffers[bufferView.buffer];\r\n\r\n    //load buffer data if not set\r\n    if(!buffer._onload){\r\n        //set onload to a promise\r\n        buffer._onload = download(buffer.uri, 'arraybuffer');\r\n        //add to all loads\r\n        gltf._loads.push(buffer._onload);\r\n    }\r\n    \r\n    //set data\r\n    buffer._onload.then((data)=>\r\n    {\r\n        //set array buffer positions\r\n        var byte_offset = bufferView.byteOffset;\r\n        var length = bufferView.byteLength;\r\n        if(accessor.byteOffset) \r\n        {\r\n            byte_offset += accessor.byteOffset;\r\n            length -= accessor.byteOffset;\r\n        }\r\n\r\n\r\n        //load data to array\r\n        console.log(length);\r\n        var value = new Float32Array(data.response, byte_offset,accessor.count*_config_js__WEBPACK_IMPORTED_MODULE_1__[\"type\"][accessor.type]);\r\n        console.log(value);\r\n        if(is_input){\r\n            sampler._inputs = value;\r\n            //find greatest and smallest input value\r\n            sampler._max_input = -100000;\r\n            sampler._min_input = 100000;\r\n            sampler._inputs.forEach((input)=>{\r\n                if(input > sampler._max_input){\r\n                    sampler._max_input = input;\r\n                }\r\n                if(input <sampler._min_input){\r\n                    sampler._min_input = input;\r\n                }\r\n            });\r\n            //set global animation min and max times\r\n            if(sampler._min_input < animation._min_time){\r\n                animation._min_time = sampler._min_input;\r\n            }\r\n            if(sampler._max_input > animation._max_time){\r\n                animation._max_time = sampler._max_input;\r\n            }\r\n\r\n        }\r\n        else\r\n            sampler._outputs = value;\r\n    });\r\n}\r\n\r\n//update node matrix model and its children\r\nfunction update_node_model(gltf, node, parent) \r\n{\r\n    set_node_matrix(node, parent);\r\n    if(node.children)\r\n        for(var i = 0; i < node.children.length; i++)\r\n            update_node_model(gltf,gltf.nodes[node.children[i]], node);\r\n}\r\n\r\nfunction process_anim_sampler(gl, gltf, sampler, animation)\r\n{\r\n    console.log(\"processing sampler\");\r\n    //set input data\r\n    process_anim_accessor(gl, gltf, sampler.input, sampler, true, animation);\r\n\r\n    //set output data\r\n    process_anim_accessor(gl, gltf, sampler.output, sampler, false, animation);\r\n}\r\n\r\n//append an animation function to root\r\nfunction process_animation(gl, gltf, animation) \r\n{\r\n    //define our animation name if not defined\r\n    animation.name = animation.name ? animation.name : \"unnamed_anim\";\r\n\r\n    //set our min and max times\r\n    animation._min_time = 100000;\r\n    animation._max_time = -100000;\r\n    //process samplers\r\n    if(animation.samplers)\r\n        for(var i = 0; i < animation.samplers.length; i++)\r\n            process_anim_sampler(gl, gltf, animation.samplers[i],animation);\r\n\r\n    //\r\n    var time = 0;\r\n    //create animation function\r\n    animation._animate = function( t ) {\r\n\r\n        time = time + Math.abs(t);\r\n        if( time > animation._max_time)\r\n            time = animation._min_time;\r\n\r\n        animation.channels.forEach( (channel) =>{\r\n\r\n            var node = gltf.nodes[channel.target.node];\r\n            var path = node[channel.target.path];\r\n            var sampler = animation.samplers[channel.sampler];\r\n            \r\n            \r\n            \r\n            if(time < sampler._min_input || time > sampler._max_input)\r\n                return;\r\n\r\n            var closest_distance_less = 100000;\r\n            var closest_distance_great = 100000;\r\n            var t1=0 ,t2=0;\r\n            var between = [undefined, undefined];\r\n            if(sampler._inputs)\r\n            sampler._inputs.forEach( (input, index) =>{\r\n                var current_distance =  time - input;\r\n                    \r\n                if( current_distance > 0){\r\n                    if(Math.abs(current_distance)< closest_distance_less){\r\n                        t1 = input;\r\n                        between[0] = index;\r\n                        closest_distance_less = Math.abs(current_distance);\r\n                    }\r\n                    //then less than\r\n                    \r\n                }else{\r\n                    //greater than\r\n                    if(Math.abs(current_distance)< closest_distance_great){\r\n                        t2 = input;\r\n                        between[1] = index;\r\n                        closest_distance_great = Math.abs(current_distance);\r\n                    }\r\n                    \r\n                }\r\n            });\r\n\r\n            //set interpolated value\r\n            //if(between[0] == undefined || between[1] == undefined)\r\n              //  return;\r\n            //console.log(between);\r\n            //console.log(  channel.target.path + \":\" + t1 + \" \" + time + \" \" + t2 );\r\n            var dt = t2-t1;\r\n            var dt2 = time - t1;\r\n            var dproportion = dt2/dt;\r\n\r\n            var val = [];\r\n            var val1 = [];\r\n            var val2 = [];\r\n            var dvar;\r\n            for(var i=0; i < _config_js__WEBPACK_IMPORTED_MODULE_1__[\"anim_lengths\"][channel.target.path]; i++){\r\n                val1.push(sampler._outputs[(between[0]*_config_js__WEBPACK_IMPORTED_MODULE_1__[\"anim_lengths\"][channel.target.path])+i]);\r\n                val2.push(sampler._outputs[(between[1]*_config_js__WEBPACK_IMPORTED_MODULE_1__[\"anim_lengths\"][channel.target.path])+i]);\r\n                dvar = val2[i]-val1[i];\r\n                val.push(val1[i]+dproportion*dvar);\r\n            }\r\n            node[channel.target.path] = val;\r\n            //console.log(node._model);\r\n            //update model\r\n            console.log(  channel.target.path + \":\" + val);\r\n            update_node_model(gltf, node);\r\n\r\n        });\r\n\r\n    }\r\n    gltf._animations.push(animation._animate);\r\n\r\n}\r\n\r\n//set final node matrix\r\n//global transform matrix\r\nfunction set_node_matrix(node, parent)\r\n{\r\n    //set model matrix data\r\n    var m_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\r\n    _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].identity(m_matrix);\r\n\r\n    //if have matrix\r\n    if(node.matrix){\r\n        m_matrix = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].clone(node.matrix);\r\n    }\r\n    else{\r\n        //set translation of matrix\r\n        if(!node.translation) {\r\n            node.translation = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0,0,0);\r\n        };\r\n\r\n        //set rotation of matrix\r\n        if(!node.rotation){\r\n            node.rotation = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].create();\r\n            _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].identity(node.rotation);\r\n        }\r\n\r\n        //set scale of matrix\r\n        if(!node.scale){\r\n            node.scale = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].create();\r\n            node.scale = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(1,1,1);\r\n        }\r\n\r\n        //set matrix from rotation translation and scale\r\n        var temp_quat = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].create();\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].normalize(temp_quat, _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"quat\"].fromValues(...node.rotation));\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].fromRotationTranslation(m_matrix, temp_quat, node.translation)\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].scale(m_matrix, m_matrix, node.scale);\r\n    }\r\n\r\n    //set node model\r\n    node._model = ( parent != undefined ) ? _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].multiply(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), parent._model, m_matrix) : m_matrix;\r\n}\r\n\r\n\r\n//process node, set matrix\r\nfunction process_node(gl, gltf, node_num, parent_num)\r\n{\r\n    //set node\r\n    var node = gltf.nodes[node_num];\r\n\r\n    //set parent\r\n    var parent = ( parent_num != undefined ) ?  gltf.nodes[parent_num] : undefined;\r\n    \r\n    //set model matrix\r\n    set_node_matrix(node, parent);\r\n\r\n    //process skin if have\r\n    //PROCESS SKIN FIRST TO ADD SKINNING DATA TO NODE'S MESH MATERIAL\r\n    if(node.skin >= 0)\r\n        process_skin(gl, gltf, node.skin, node);\r\n\r\n    //process mesh if have\r\n    if(node.mesh >= 0)\r\n        process_mesh(gl, gltf, node.mesh, node);\r\n\r\n    \r\n    //process children nodes\r\n    if(node.children)\r\n        for(var i = 0; i < node.children.length; i++)\r\n            process_node(gl, gltf, node.children[i], node_num);\r\n\r\n}\r\n\r\n//append _inverseBindMatrices, an array of \r\nfunction process_skin_accessor(gl, gltf, accessor_num, skin)\r\n{\r\n    //set accessor\r\n    var accessor = gltf.accessors[accessor_num];\r\n\r\n    //process accessor, bufferView, and buffer ( load buffer data )\r\n    //set buffer view\r\n    var bufferView = gltf.bufferViews[accessor.bufferView];\r\n    \r\n    //set buffer\r\n    var buffer = gltf.buffers[bufferView.buffer];\r\n\r\n    //load buffer data if not set\r\n    if(!buffer._onload){\r\n        //set onload to a promise\r\n        buffer._onload = download(buffer.uri, 'arraybuffer');\r\n        //add to all loads\r\n        gltf._loads.push(buffer._onload);\r\n    }\r\n    //init inverseBindMatrices\r\n    skin._inverseBindMatrices = [];\r\n\r\n    //init globalJointTransforms\r\n    skin._globalJointTransforms = [];\r\n\r\n    //init JointMatrices\r\n    skin._jointMatrices = [];\r\n\r\n    //set data\r\n    buffer._onload.then((data)=>{\r\n        //set array buffer positions\r\n        var byte_offset = bufferView.byteOffset;\r\n        var length = bufferView.byteLength;\r\n        if(accessor.byteOffset) \r\n        {\r\n            byte_offset += accessor.byteOffset;\r\n            length -= accessor.byteOffset;\r\n        }\r\n\r\n        //load data to array\r\n        var value = new Float32Array(data.response, byte_offset,accessor.count*_config_js__WEBPACK_IMPORTED_MODULE_1__[\"type\"][accessor.type]);\r\n        \r\n        //set inverse bind matrices\r\n        //and add them to their corresponding joints\r\n        for (let index = 0; index < value.length; index += 16) {\r\n            //get current joint\r\n            var joint_num = skin.joints[index];\r\n            var joint = gltf.nodes[joint_num];\r\n\r\n            //set inverse bind matrix\r\n            joint._inverseBindMatrix = array.slice(index, index + 16);\r\n\r\n            //set globalJoint Transform matrix\r\n            joint._globalJointTransform = joint._model;\r\n\r\n            //set and init jointMatrix\r\n            joint._jointMatrix = new Float32Array(16);\r\n\r\n            //push matrices to skin\r\n            skin._inverseBindMatrices.push(joint._inverseBindMatrix);\r\n            skin._globalJointTransforms.push(joint._globalJointTransform);\r\n            skin._jointMatrices.push(joint._jointMatrix);\r\n\r\n            //add our update jointBindPose function\r\n            joint._updateJointBindPose = function(){\r\n                _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].multiply(joint._jointMatrix, joint._globalJointTransform, joint._inverseBindMatrix);\r\n            }\r\n\r\n            //update jointbindpose ASSUME THAT GLOBALJOINTTRANSFORM HAS BEEN UPDATED\r\n            joint._updateJointBindPose();\r\n        }\r\n    });\r\n}\r\n\r\n//process skin, create skin update function\r\n//for computing joint matrix if translation/rotation/scale/model has changed\r\nfunction process_skin(gl, gltf, skin_num, node)\r\n{\r\n    var skin = gltf.skins[skin_num];\r\n\r\n\r\n    //process inverseBindMatrices and append an array of 4x4 matrices\r\n    //also adds inverseBindMatrices to corresponding nodes\r\n    //appends compute jointBindPose to each node as well\r\n    if(skin.inverseBindMatrices >= 0)\r\n        process_skin_accessor(gl, gltf, skin.inverseBindMatrices, skin)\r\n\r\n    //add jointMatrices to our material for shader compilation\r\n\r\n}\r\n\r\n//process mesh, set primitive vao's\r\nfunction process_mesh(gl, gltf, mesh_num, node)\r\n{\r\n    //initialize variables\r\n    var mesh = gltf.meshes[mesh_num];\r\n\r\n    //process primitives in mesh\r\n    if(mesh.primitives)\r\n    for(var i = 0; i < mesh.primitives.length; i++){\r\n\r\n        //prepare primitive rendering function constants\r\n        var accessor, material;\r\n\r\n        //set primitives\r\n        var primitive = mesh.primitives[i];\r\n\r\n        //create vao\r\n        primitive._vao = gl.createVertexArray();\r\n        gl.bindVertexArray(primitive._vao);\r\n        \r\n        //process attributes in primitive\r\n        if(primitive.attributes)\r\n            for(const key in primitive.attributes) \r\n                process_accessor(gl, gltf, primitive.attributes[key], key, primitive._vao, node); \r\n\r\n\r\n        //process indices\r\n        if(primitive.indices >= 0){\r\n            process_accessor(gl, gltf, primitive.indices,undefined, primitive._vao);\r\n            accessor = gltf.accessors[primitive.indices];\r\n        }\r\n        else\r\n            //no index buffer\r\n            console.log(\"This mesh does not have an index buffer\");\r\n\r\n        gl.bindVertexArray(null);\r\n\r\n        //process material\r\n        if(primitive.material >= 0){\r\n            process_material(gl, gltf, primitive.material);\r\n            material = gltf.materials[primitive.material]\r\n        }\r\n        else\r\n            //set primitive.material to default\r\n            material = gltf._default_material;\r\n        \r\n                \r\n        //set primitive rendering function \r\n        primitive._render = function(){\r\n            \r\n            //\r\n            //gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n            //bind vao\r\n            gl.bindVertexArray(primitive._vao);\r\n\r\n            //bind element array buffer\r\n            //gl.bindBuffer(bufferView.target, accessor._buffer);\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, accessor._buffer);\r\n\r\n            //use shader\r\n            gl.useProgram(material._shader_program);\r\n\r\n            //set uniforms\r\n            var perspective_loc = gl.getUniformLocation(material._shader_program, \"perspective\");\r\n            var view_loc = gl.getUniformLocation(material._shader_program, \"view\");\r\n            gl.uniformMatrix4fv(perspective_loc, gl.FALSE, gltf._camera.perspective_matrix);\r\n            gl.uniformMatrix4fv(view_loc, gl.FALSE, gltf._camera.view_matrix);\r\n\r\n            var model_loc = gl.getUniformLocation(material._shader_program, 'model');\r\n\r\n            //set model uniform\r\n            gl.uniformMatrix4fv(model_loc, gl.FALSE, node._model);\r\n            \r\n            //set jointTransform uniforms\r\n            //primitive._jointMatrices.forEach( (jointMatrix, index)=>{\r\n              //  gl.uniformMatrix4fv(gl.getUniformLocation(material._shader_program, 'jointTransform['+index+']'), false, jointMatrix);\r\n            //});\r\n            //load material\r\n            var index = 0;\r\n\r\n            //Do not load textures or environment map if the material is the default one\r\n            if(!material._is_defualt){\r\n                material._textures.forEach((element)=>{\r\n                    var uniform_loc = material._uniform_locs[element.name];\r\n                    //add texture\r\n                    var texture = gltf.textures[element.index];\r\n                    gl.activeTexture(gl.TEXTURE0 + index);\r\n                    gl.bindTexture(gl.TEXTURE_2D, texture._buffer);\r\n                    gl.uniform1i(uniform_loc, index);\r\n                    index++;\r\n                });\r\n    \r\n                var diffuse_loc = gl.getUniformLocation(material._shader_program, \"diffuse_map\");\r\n                var prefilter_loc = gl.getUniformLocation(material._shader_program, \"prefilter_map\");\r\n                var brdflut_loc = gl.getUniformLocation(material._shader_program, \"brdflut_map\");\r\n    \r\n                //set environment uniforms\r\n                gltf._environment.set_diffuse_uniform(gl, index, diffuse_loc);\r\n                gltf._environment.set_prefilter_uniform(gl, ++index, prefilter_loc);\r\n                gltf._environment.set_brdflut_uniform(gl, ++index, brdflut_loc);\r\n            }\r\n            \r\n            \r\n\r\n            //draw\r\n            //gl.drawElements(primitive.mode, accessor.count, accessor.componentType, 0);\r\n            gl.drawElements(gl.TRIANGLES, accessor.count, accessor.componentType, 0);\r\n\r\n        }\r\n\r\n        gltf._renders.push(primitive._render);\r\n\r\n    }\r\n    \r\n}\r\n\r\n//processes accessors and buffer data\r\nfunction process_accessor(gl, gltf, accessor_num, key, vao, node){ \r\n    //set accessor\r\n    var accessor = gltf.accessors[accessor_num];\r\n\r\n    //create buffer\r\n    accessor._buffer = gl.createBuffer();\r\n\r\n\r\n    //process accessor, bufferView, and buffer ( load buffer data )\r\n    //set buffer view\r\n    var bufferView = gltf.bufferViews[accessor.bufferView];\r\n    \r\n    //set buffer\r\n    var buffer = gltf.buffers[bufferView.buffer];\r\n\r\n    //load buffer data if not set\r\n    if(!buffer._onload){\r\n        //set onload to a promise\r\n        buffer._onload = download(buffer.uri, 'arraybuffer');\r\n\r\n        //add to all loads\r\n        gltf._loads.push(buffer._onload);\r\n    }\r\n\r\n    //set buffer data\r\n    buffer._onload.then((data)=>\r\n    {\r\n        //set array buffer positions\r\n        var byte_offset = bufferView.byteOffset;\r\n        var length = bufferView.byteLength;\r\n        if(accessor.byteOffset) \r\n        {\r\n            byte_offset += accessor.byteOffset;\r\n            length -= accessor.byteOffset;\r\n        }\r\n        \r\n        //bind vao\r\n        gl.bindVertexArray(vao);\r\n\r\n        if(key != undefined)\r\n        { \r\n            //load data to array\r\n            var array = new Float32Array(data.response, byte_offset,length/Float32Array.BYTES_PER_ELEMENT);\r\n            \r\n            //set buffer data\r\n            /*gl.bindBuffer(bufferView.target, accessor._buffer);\r\n            gl.bufferData(bufferView.target, array, gl.STATIC_DRAW);*/\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, accessor._buffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\r\n\r\n            //set vertex attrib pointer\r\n            gl.enableVertexAttribArray(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"][key]);\r\n            gl.vertexAttribPointer(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"][key], _config_js__WEBPACK_IMPORTED_MODULE_1__[\"type\"][accessor.type], accessor.componentType, false, 0, 0);\r\n\r\n            //gl.bindBuffer(bufferView.target, null);\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n            //if accessor is position, set min and maximum value\r\n            if(key == \"POSITION\" && node._model){\r\n                var min = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].transformMat4(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].create(),_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].fromValues(accessor.min[0], accessor.min[1], accessor.min[2], 1.0),node._model);\r\n                var max =  _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].transformMat4(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].create(),_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].fromValues(accessor.max[0], accessor.max[1], accessor.max[2], 1.0),node._model);\r\n                console.log(node._model);\r\n                gltf._min[0] = gltf._min[0] > min[0] ? min[0] : gltf._min[0];\r\n                gltf._min[1] = gltf._min[1] > min[1] ? min[1] : gltf._min[1];\r\n                gltf._min[2] = gltf._min[2] > min[2] ? min[2] : gltf._min[2];\r\n                gltf._max[0] = gltf._max[0] < max[0] ? max[0] : gltf._max[0];\r\n                gltf._max[1] = gltf._max[1] < max[1] ? max[1] : gltf._max[1];\r\n                gltf._max[2] = gltf._max[2] < max[2] ? max[2] : gltf._max[2];\r\n            }\r\n            \r\n\r\n        }else\r\n        {\r\n            //load data to array\r\n            var array = new Uint16Array(data.response, byte_offset, length/Uint16Array.BYTES_PER_ELEMENT);\r\n            \r\n            //create and set buffer data\r\n            accessor._buffer = gl.createBuffer();\r\n            /*gl.bindBuffer(bufferView.target, accessor._buffer);\r\n            gl.bufferData(bufferView.target, array, gl.STATIC_DRAW);*/\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, accessor._buffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);\r\n\r\n            //gl.bindBuffer(bufferView.target, null);\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n        }\r\n\r\n        //unbind vao\r\n        //gl.bindVertexArray(null);\r\n    });\r\n\r\n}\r\n\r\n//build and return gltf shader program\r\nfunction shader_program(gl, params, vs_src, fs_src){\r\n    //set params text\r\n    var param_text = '#version 300 es \\n';\r\n    if(params != undefined)\r\n    for(var i = 0; i < params.length; i++){\r\n        var key = params[i].toUpperCase();\r\n        param_text += '#define '+key+'\\n';\r\n    }\r\n\r\n    //create and compile vertex shader\r\n    var vs = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(vs, param_text + vs_src);\r\n    gl.compileShader(vs);\r\n    //IF DEBUG\r\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\r\n        //console.log(gl.getShaderInfoLog(vs));\r\n        gl.deleteShader(vs);\r\n        return false;\r\n    }\r\n\r\n    //create and compile fragment shader\r\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fs, param_text + fs_src);\r\n    //console.log(param_text + fragment_shader_src);\r\n    gl.compileShader(fs);\r\n    //IF DEBUG\r\n    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\r\n        console.log(gl.getShaderInfoLog(fs));\r\n        gl.deleteShader(fs);\r\n        return false;\r\n    }\r\n\r\n    //link program\r\n    var prog = gl.createProgram();\r\n    gl.attachShader(prog, vs);\r\n    gl.attachShader(prog, fs);\r\n    gl.linkProgram(prog);\r\n    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){\r\n        console.log(gl.getProgramInfoLog(prog));\r\n        gl.deleteProgram(prog);\r\n        return false;\r\n    }\r\n\r\n    return prog;\r\n    \r\n}\r\n//create default material\r\nfunction set_default_material(gl, gltf){\r\n    //compile program\r\n    //set default material\r\n    var material = gltf._default_material = {}\r\n\r\n    //set to default\r\n    material._is_defualt = true;\r\n\r\n    //set program\r\n    material._shader_program = shader_program(gl, [], vertex_shader_src_default, fragment_shader_src_default)\r\n\r\n}\r\n//process textures and compile shader program\r\nfunction process_material(gl, gltf, material_num) {\r\n    //set material\r\n    var material = gltf.materials[material_num];\r\n\r\n    //set shader params\r\n    material._shader_params = [];\r\n\r\n    //set textures\r\n    material._textures = [];\r\n    \r\n    //traverse material object\r\n    for(const key in material) {\r\n        \r\n        if(key != \"_shader_params\" && key != \"name\" && key != \"_textures\" && key != \"_uniform_locs\")\r\n        //check if a texture\r\n        if(key.includes('Texture')){\r\n            material._shader_params.push(key)\r\n            material._textures.push({\"index\":material[key].index, \"name\": key});\r\n            process_texture(gl, gltf, material[key].index);\r\n        }\r\n        //check if a factor\r\n        else if(key.includes('Factor')){\r\n            material._shader_params.push(key)\r\n        } \r\n        //then must be another material\r\n        else{\r\n            var _material = material[key];\r\n            for(const _key in _material) \r\n            {\r\n                console.log(_key);\r\n                //check if a texture\r\n                if(_key.includes('Texture')){\r\n                    //add shader param\r\n                    material._shader_params.push(_key);\r\n                    material._textures.push({\"index\":_material[_key].index, \"name\": _key});\r\n                    process_texture(gl, gltf, _material[_key].index);\r\n                }\r\n                //check if a factor\r\n                else if(_key.includes('Factor')){\r\n                    //add shader param\r\n                    material._shader_params.push(_key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //create and set shader program\r\n    material._shader_program = shader_program(gl, material._shader_params, vertex_shader_src, fragment_shader_src);\r\n\r\n    //set uniform locations\r\n\r\n    material._uniform_locs = {};\r\n    material._shader_params.forEach((key)=>{\r\n        material._uniform_locs[key] = gl.getUniformLocation(material._shader_program, key);\r\n    });\r\n}\r\n\r\nfunction process_texture(gl, gltf, texture_num){\r\n    //set texture\r\n    var texture = gltf.textures[texture_num];\r\n\r\n    //create texture\r\n    texture._buffer = gl.createTexture();\r\n\r\n    //set image \r\n    var _image = gltf.images[texture.source];\r\n\r\n    //set sampler\r\n    var sampler = texture.sampler||gltf.samplers ? gltf.samplers[texture.sampler] : undefined;\r\n\r\n    //load image data from source\r\n    if(!_image._onload){\r\n        //set onload to a promise\r\n        _image._onload = download_image(_image.uri).then((image)=>{\r\n            //bind buffer\r\n            gl.bindTexture(gl.TEXTURE_2D, texture._buffer);\r\n    \r\n            //set sampler data\r\n            if(sampler){\r\n            if(sampler.wrapS){\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, sampler.wrapS);\r\n            }\r\n            if(sampler.wrapT){\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, sampler.wrapT);\r\n            }\r\n            if(sampler.minFilter){\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, sampler.minFilter);\r\n            }\r\n            if(sampler.magFilter){\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, sampler.magFilter);\r\n            }\r\n            }else{\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            }\r\n    \r\n            //set data\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            \r\n            gl.bindTexture(gl.TEXTURE_2D, null);\r\n\r\n            return _image.uri;\r\n        });;\r\n\r\n        //add to all load\r\n        gltf._loads.push(_image._onload);\r\n    }\r\n\r\n    //set texture buffer data\r\n\r\n}\r\n\r\n\r\n/*\r\n//loads buffer data and sets vertex attrib pointer\r\nfunction set_buffer(gl, array_data, gl_buffer_id, layout_name,attrib_type, data_type){\r\n    //set buffer data\r\n    gl.bindBuffer(gl.ARRAY_BUFFER,gl_buffer_id);\r\n    gl.bufferData(gl.ARRAY_BUFFER, array_data, gl.STATIC_DRAW);\r\n\r\n    //set vertex attrib pointer\r\n    gl.enableVertexAttribArray(layout[layout_name]);\r\n    gl.vertexAttribPointer(layout[layout_name], attrib_sizes[attrib_type], data_type, false, 0, 0);\r\n}\r\n\r\n//loads element array buffer\r\nfunction set_indices_buffer(gl, array_data, gl_buffer_id){\r\n    //set buffer data\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl_buffer_id);\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array_data, gl.STATIC_DRAW);\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n// ENVIRONMENT MAP LOAD\r\n\r\n// ENVIRONMENT MAP LOAD\r\n\r\n// ENVIRONMENT MAP LOAD\r\nfunction isPowerOf2(value) {\r\n    return (value & (value - 1)) == 0;\r\n}\r\nfunction load_image(url, on_load){\r\n    var image = new Image();\r\n    image.onload = on_load;\r\n    image.src = url;\r\n    return image;\r\n}\r\n//loads environmental map and returns a renderable\r\nfunction env_map(gl, gltf){\r\n    //enable seamless cube maps\r\n    //SET CUBE MAP VERTEX DATA\r\n    const vertex_data = new Float32Array([\r\n        -1.0,  1.0, -1.0,\r\n            -1.0, -1.0, -1.0,\r\n            1.0, -1.0, -1.0,\r\n            1.0, -1.0, -1.0,\r\n            1.0,  1.0, -1.0,\r\n            -1.0,  1.0, -1.0,\r\n\r\n            -1.0, -1.0,  1.0,\r\n            -1.0, -1.0, -1.0,\r\n            -1.0,  1.0, -1.0,\r\n            -1.0,  1.0, -1.0,\r\n            -1.0,  1.0,  1.0,\r\n            -1.0, -1.0,  1.0,\r\n\r\n            1.0, -1.0, -1.0,\r\n            1.0, -1.0,  1.0,\r\n            1.0,  1.0,  1.0,\r\n            1.0,  1.0,  1.0,\r\n            1.0,  1.0, -1.0,\r\n            1.0, -1.0, -1.0,\r\n\r\n            -1.0, -1.0,  1.0,\r\n            -1.0,  1.0,  1.0,\r\n            1.0,  1.0,  1.0,\r\n            1.0,  1.0,  1.0,\r\n            1.0, -1.0,  1.0,\r\n            -1.0, -1.0,  1.0,\r\n\r\n            -1.0,  1.0, -1.0,\r\n            1.0,  1.0, -1.0,\r\n            1.0,  1.0,  1.0,\r\n            1.0,  1.0,  1.0,\r\n            -1.0,  1.0,  1.0,\r\n            -1.0,  1.0, -1.0,\r\n\r\n            -1.0, -1.0, -1.0,\r\n            -1.0, -1.0,  1.0,\r\n            1.0, -1.0, -1.0,\r\n            1.0, -1.0, -1.0,\r\n            -1.0, -1.0,  1.0,\r\n            1.0, -1.0,  1.0]);\r\n    const vao = gl.createVertexArray();\r\n    const buffer = gl.createBuffer();\r\n    gl.bindVertexArray(vao);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']);\r\n    gl.vertexAttribPointer(_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION'], 3, gl.FLOAT, gl.FALSE, 0, 0);\r\n    gl.bindVertexArray(null);\r\n\r\n    //shaders\r\n    const VERTEX_ATTRIB_POSITION = 0;\r\n    var vs_src = `#version 300 es\r\n    layout( location = `+VERTEX_ATTRIB_POSITION+` ) in vec3 position;\r\n\r\n    uniform mat4 perspective;\r\n    uniform mat4 view;\r\n\r\n    out vec3 v_normal;\r\n\r\n    \r\n    void main(){\r\n        vec4 pos = perspective*view*vec4(position*vec3(100), 1.0);\r\n        gl_Position = pos.xyzw;\r\n        v_normal = position;\r\n    }\r\n    `;\r\n    var fs_src = `#version 300 es\r\n    precision mediump float;\r\n \r\n    in vec3 v_normal;\r\n    out vec4 color;\r\n     \r\n    uniform samplerCube env_map;\r\n    uniform samplerCube diffuse_map;\r\n    uniform samplerCube prefilter_map;\r\n    uniform sampler2D brdflut_map;\r\n     \r\n    void main() {\r\n       color = texture(env_map, v_normal);\r\n    }\r\n    `;\r\n    var vs = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(vs,vs_src);\r\n    gl.compileShader(vs);\r\n    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\r\n        console.log(gl.getShaderInfoLog(vs));\r\n        gl.deleteShader(vs);\r\n    }\r\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fs,fs_src);\r\n    gl.compileShader(fs);\r\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\r\n        console.log(gl.getShaderInfoLog(fs));\r\n        gl.deleteShader(fs);\r\n    }\r\n    var program = gl.createProgram();\r\n    gl.attachShader(program, vs);\r\n    gl.attachShader(program, fs);\r\n    gl.linkProgram(program);\r\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\r\n        console.log(gl.getProgramInfoLog(program));\r\n        gl.deleteProgram(program);\r\n    }\r\n\r\n    //SET CUBE MAP IMAGE DATA\r\n    var diffuse;\r\n    var texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);\r\n    /*const faces = [\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, src: 'assets/env_map/environment_right_0.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, src: 'assets/env_map/environment_left_0.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, src: 'assets/env_map/environment_top_0.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, src: 'assets/env_map/environment_bottom_0.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, src: 'assets/env_map/environment_front_0.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, src: 'assets/env_map/environment_back_0.jpg' },\r\n    ];*/\r\n\r\n    /*const faces = [\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, src: 'assets/env_map/px.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, src: 'assets/env_map/nx.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, src: 'assets/env_map/py.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, src: 'assets/env_map/ny.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, src: 'assets/env_map/pz.jpg' },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, src: 'assets/env_map/nz.jpg' },\r\n    ];*/\r\n\r\n    const faces = [\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, src: _env_map_px_jpg__WEBPACK_IMPORTED_MODULE_5__[\"default\"] },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, src: _env_map_nx_jpg__WEBPACK_IMPORTED_MODULE_3__[\"default\"] },\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, src: _env_map_py_jpg__WEBPACK_IMPORTED_MODULE_6__[\"default\"] },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, src: _env_map_ny_jpg__WEBPACK_IMPORTED_MODULE_4__[\"default\"] },\r\n        { target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, src: _env_map_pz_jpg__WEBPACK_IMPORTED_MODULE_7__[\"default\"] },\r\n        { target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, src: _env_map_nz_jpg__WEBPACK_IMPORTED_MODULE_8__[\"default\"] },\r\n    ];\r\n    \r\n    var images = [];\r\n    var env_map_obj = {\r\n        onload: null,\r\n        vao: vao,\r\n        vert_buffer: buffer,\r\n        texture: texture,\r\n        diffuse: diffuse,\r\n        program: program,\r\n        texture_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['env_map']),\r\n        diffuse_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['diffuse_map']), // only if want to view diffuse in cube map\r\n        prefilter_loc: gl.getUniformLocation(program, 'prefilter_map'),\r\n        brdflut_loc: gl.getUniformLocation(program, 'brdflut_map'),\r\n        perspective_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['perspective']),\r\n        view_loc: gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['view']),\r\n        render: function(gl, camera){\r\n            gl.bindVertexArray(this.vao);\r\n            gl.useProgram(this.program);\r\n\r\n            //bind environment map\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP,this.texture);\r\n            gl.uniform1i(this.texture_loc, 0);\r\n\r\n            //bind diffuse map ONLY IF WANT TO VIEW DIFFUSE IINSTEAD OF ENV MAP\r\n            /*gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.diffuse);\r\n            gl.uniform1i(this.diffuse_loc, 1);\r\n\r\n            //bind prefilter map ONLY IF WANT TO VIEW PREFILTER INSTEAD\r\n            gl.activeTexture(gl.TEXTURE2);\r\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.prefilter);\r\n            gl.uniform1i(this.prefilter_loc, 2);\r\n\r\n            //bind brdflut map\r\n            gl.activeTexture(gl.TEXTURE3);\r\n            gl.bindTexture(gl.TEXTURE_2D, this.brdflut);\r\n            gl.uniform1i(this.brdflut_loc, 3);*/\r\n\r\n            //set camera data\r\n            camera.set_perspective_uniform(gl, this.perspective_loc);\r\n            camera.set_view_uniform(gl, this.view_loc);\r\n\r\n            //draw cube map\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n            gl.bindVertexArray(null);\r\n        },\r\n        set_texture_uniform: function(gl, active_texture_index, texture_uniform_location){\r\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\r\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);\r\n            gl.uniform1i(texture_uniform_location, active_texture_index);\r\n        },\r\n        set_diffuse_uniform: function(gl, active_texture_index, texture_uniform_location){\r\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\r\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.diffuse);\r\n            gl.uniform1i(texture_uniform_location, active_texture_index);\r\n        },\r\n        set_prefilter_uniform: function(gl, active_texture_index, texture_uniform_location){\r\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\r\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.prefilter);\r\n            gl.uniform1i(texture_uniform_location, active_texture_index);\r\n        },\r\n        set_brdflut_uniform: function(gl, active_texture_index, texture_uniform_location){\r\n            gl.activeTexture(gl.TEXTURE0+active_texture_index);\r\n            gl.bindTexture(gl.TEXTURE_2D, this.brdflut);\r\n            gl.uniform1i(texture_uniform_location, active_texture_index);\r\n        },\r\n    } \r\n    var onload_promise = new Promise((resolve)=>{\r\n        faces.forEach((face)=>{\r\n            const {target , src} = face;\r\n            //var image = new Image();\r\n            var image = new Image();\r\n            image.onload = function(){ \r\n                //document.body.append(image);\r\n                images.push({'image':image, 'target':target});\r\n                //if all images are loaded load environmental map\r\n                if(images.length >= faces.length){\r\n                    //set texture data\r\n                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);\r\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);\r\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);\r\n                    for(var i=0; i<images.length; i++){\r\n                        gl.texImage2D(\r\n                            images[i].target,\r\n                            0,\r\n                            gl.RGBA,\r\n                            gl.RGBA,\r\n                            gl.UNSIGNED_BYTE,\r\n                            images[i].image\r\n                        );       \r\n                    }\r\n                    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n                    //generate indirect ibl\r\n                    env_map_obj.diffuse = irradiance_gen(gl, texture, vao);\r\n                    env_map_obj.prefilter = prefilter_gen(gl, texture, vao);\r\n                    env_map_obj.brdflut = brdflut_gen(gl, env_map);\r\n                    resolve(images);\r\n                }\r\n            }\r\n            image.src = src;\r\n        });\r\n    });   \r\n\r\n\r\n    env_map_obj.onload = onload_promise;\r\n    gltf._loads.push(env_map_obj.onload);\r\n    gltf._environment = env_map_obj;\r\n}\r\n\r\n//generate irradiance map from environment cube map WebglTexture\r\nfunction irradiance_gen(gl, env_map_texture, cube_vao) {\r\n    //set shaders\r\n    var vs_src = `#version 300 es\r\n    layout( location = `+_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']+` ) in vec3 position;\r\n\r\n    uniform mat4 perspective;\r\n    uniform mat4 view;\r\n\r\n    out vec3 v_normal;\r\n\r\n    \r\n    void main(){\r\n        vec4 pos = perspective*view*vec4(position, 1.0);\r\n        gl_Position = pos.xyzw;\r\n        v_normal = position;\r\n    }`;\r\n    var fs_src = `#version 300 es\r\n    precision mediump float;\r\n \r\n    in vec3 v_normal;\r\n    out vec4 color;\r\n    \r\n    const float PI = 3.14159265359;\r\n     \r\n    uniform samplerCube env_map;\r\n     \r\n    void main() {\r\n        vec3 normal = normalize(v_normal);\r\n\r\n        vec3 irradiance = vec3(0.0);\r\n\r\n        vec3 up    = vec3(0.0, 1.0, 0.0);\r\n        vec3 right = cross(up, normal);\r\n        up         = cross(normal, right);\r\n\r\n        float sampleDelta = 0.025;\r\n        float nrSamples = 0.0; \r\n        for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)\r\n        {\r\n            for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)\r\n            {\r\n                // spherical to cartesian (in tangent space)\r\n                vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\r\n                // tangent space to world\r\n                vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; \r\n\r\n                irradiance += texture(env_map, sampleVec).rgb * cos(theta) * sin(theta);\r\n                nrSamples++;\r\n            }\r\n        }\r\n        irradiance = PI * irradiance * (1.0 / float(nrSamples));\r\n        \r\n        color = vec4(irradiance, 1.0);\r\n    }\r\n    `;\r\n\r\n    //create convolution shader program\r\n    var vs = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(vs, vs_src);\r\n    gl.compileShader(vs);\r\n    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\r\n        console.log(gl.getShaderInfoLog(vs));\r\n        gl.deleteShader(vs);\r\n    }\r\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fs, fs_src);\r\n    gl.compileShader(fs);\r\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\r\n        console.log(gl.getShaderInfoLog(fs));\r\n        gl.deleteShader(fs);\r\n    }\r\n    var program = gl.createProgram();\r\n    gl.attachShader(program, vs);\r\n    gl.attachShader(program, fs);\r\n    gl.linkProgram(program);\r\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\r\n        console.log(gl.getProgramInfoLog(program));\r\n        gl.deleteProgram(program);\r\n    }\r\n\r\n    //set program locations\r\n    var texture_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['env_map']);\r\n    var perspective_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['perspective']);\r\n    var view_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['view']);\r\n\r\n    //initialize irradiance cube map data\r\n    var irradiance_cube_map_texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, irradiance_cube_map_texture);\r\n    for(var i = 0; i < 6; i++){\r\n        gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,0, gl.RGBA, 1, 1, 0, gl.RGBA,\r\n              gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255,0, 255, 0, 255,0, 0, 255, 255])\r\n            );    \r\n    }\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n\r\n    //init render and framebuffer\r\n    var fbo  = gl.createFramebuffer();\r\n    var rbo = gl.createRenderbuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    \r\n    //set perspective and view data\r\n    var projection = _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(),Object(_includes_common_js__WEBPACK_IMPORTED_MODULE_2__[\"toRadian\"])(90), 1.0, 0.1, 10.0);\r\n    var view = [\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(-1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0,  1.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0, -1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0, -1.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0,  1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0, -1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0))\r\n         ];\r\n\r\n    //generate irradiance map texture\r\n    gl.bindVertexArray(cube_vao); //bind cube vertex data\r\n    gl.useProgram(program);\r\n\r\n    //bind environment cube map\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP,env_map_texture);\r\n    gl.uniform1i(texture_loc, 0);\r\n\r\n    //set perspective uniform\r\n    gl.uniformMatrix4fv(perspective_loc, gl.FALSE, projection); \r\n    \r\n    gl.viewport(0, 0, 32, 32);\r\n    for(var i = 0; i < 6; i++){\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n        //render cubemap to texture\r\n        gl.uniformMatrix4fv(view_loc, gl.FALSE, view[i]);//set view uniform\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, \r\n                                gl.COLOR_ATTACHMENT0, \r\n                                gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\r\n                                irradiance_cube_map_texture, \r\n                                0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n    }\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    gl.deleteFramebuffer(fbo);\r\n    return irradiance_cube_map_texture;\r\n}\r\n\r\nfunction prefilter_gen(gl, env_map, cube_vao){\r\n    //initialize prefilter map\r\n    var prefilter_map = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP, prefilter_map);\r\n    for(var i = 0; i < 6; i++){\r\n        gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,0, gl.RGBA, 128, 128, 0, gl.RGBA,\r\n            gl.UNSIGNED_BYTE, null\r\n        );      \r\n    }\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n\r\n    //initialize prefilter shader program\r\n    var vs_src = `#version 300 es\r\n    layout( location = `+_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']+` ) in vec3 position;\r\n\r\n    uniform mat4 perspective;\r\n    uniform mat4 view;\r\n\r\n    out vec3 v_normal;\r\n    \r\n    void main(){\r\n        vec4 pos = perspective*view*vec4(position, 1.0);\r\n        gl_Position = pos.xyzw;\r\n        v_normal = position;\r\n    }`;\r\n    var fs_src = `#version 300 es\r\n    precision mediump float;\r\n    \r\n    const float PI = 3.14159265359;\r\n\r\n    in vec3 v_normal;\r\n    out vec4 color;\r\n\r\n    float VanDerCorpus(uint n, uint base)\r\n    {\r\n        float invBase = 1.0 / float(base);\r\n        float denom   = 1.0;\r\n        float result  = 0.0;\r\n\r\n        for(uint i = 0u; i < 32u; ++i)\r\n        {\r\n            if(n > 0u)\r\n            {\r\n                denom   = mod(float(n), 2.0);\r\n                result += denom * invBase;\r\n                invBase = invBase / 2.0;\r\n                n       = uint(float(n) / 2.0);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    vec2 Hammersley(uint i, uint N)\r\n    {\r\n        return vec2(float(i)/float(N), VanDerCorpus(i, 2u));\r\n    }\r\n\r\n    vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\r\n    {\r\n        float a = roughness*roughness;\r\n        \r\n        float phi = 2.0 * PI * Xi.x;\r\n        float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n        \r\n        // from spherical coordinates to cartesian coordinates\r\n        vec3 H;\r\n        H.x = cos(phi) * sinTheta;\r\n        H.y = sin(phi) * sinTheta;\r\n        H.z = cosTheta;\r\n        \r\n        // from tangent-space vector to world-space sample vector\r\n        vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n        vec3 tangent   = normalize(cross(up, N));\r\n        vec3 bitangent = cross(N, tangent);\r\n        \r\n        vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n        return normalize(sampleVec);\r\n    }  \r\n\r\n     \r\n    uniform samplerCube env_map;\r\n    uniform float roughness;  \r\n\r\n    void main() {        \r\n        vec3 N = normalize(v_normal);    \r\n        vec3 R = N;\r\n        vec3 V = R;\r\n\r\n        const uint SAMPLE_COUNT = 1024u;\r\n        float totalWeight = 0.0;   \r\n        vec3 prefilteredColor = vec3(0.0);     \r\n        for(uint i = 0u; i < SAMPLE_COUNT; ++i)\r\n        {\r\n            vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n            vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n            vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n            float NdotL = max(dot(N, L), 0.0);\r\n            if(NdotL > 0.0)\r\n            {\r\n                prefilteredColor += texture(env_map, L).rgb * NdotL;\r\n                totalWeight      += NdotL;\r\n            }\r\n        }\r\n        prefilteredColor = prefilteredColor / totalWeight;\r\n\r\n        color = vec4(prefilteredColor, 1.0);\r\n    }\r\n    `;\r\n    var vs = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(vs, vs_src);\r\n    gl.compileShader(vs);\r\n    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\r\n        console.log(gl.getShaderInfoLog(vs));\r\n        gl.deleteShader(vs);\r\n    }\r\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fs, fs_src);\r\n    gl.compileShader(fs);\r\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\r\n        console.log(gl.getShaderInfoLog(fs));\r\n        gl.deleteShader(fs);\r\n    }\r\n    var program = gl.createProgram();\r\n    gl.attachShader(program, vs);\r\n    gl.attachShader(program, fs);\r\n    gl.linkProgram(program);\r\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\r\n        console.log(gl.getProgramInfoLog(program));\r\n        gl.deleteProgram(program);\r\n    }\r\n\r\n    //set program locations\r\n    var env_map_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['env_map']);\r\n    var roughness_loc = gl.getUniformLocation(program, 'roughness');\r\n    var perspective_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['perspective']);\r\n    var view_loc = gl.getUniformLocation(program, _config_js__WEBPACK_IMPORTED_MODULE_1__[\"uniform_names\"]['view']);\r\n\r\n    //set camera view data\r\n    var views = [\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(-1.0,  0.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0,  1.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0, -1.0,  0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0,  0.0, -1.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0,  1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0)),\r\n        _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].lookAt( _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, 0.0, 0.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues( 0.0,  0.0, -1.0), _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"vec3\"].fromValues(0.0, -1.0,  0.0))\r\n    ];\r\n\r\n    //init frame buffer\r\n    var fbo = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n\r\n    //run prefilter\r\n    gl.bindVertexArray(cube_vao);\r\n    gl.useProgram(program);\r\n\r\n    //set envirnomental map texture\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_CUBE_MAP,env_map);\r\n    gl.uniform1i(env_map_loc, 0);\r\n\r\n    //set perspective\r\n    gl.uniformMatrix4fv(perspective_loc,gl.FALSE, _includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].perspective(_includes_index_js__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create(),Object(_includes_common_js__WEBPACK_IMPORTED_MODULE_2__[\"toRadian\"])(90), 1.0, 0.1, 10.0));\r\n\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n    var mip_levels = 10;\r\n    for(var mip = 0; mip<mip_levels; ++mip){\r\n        //set viewport dimensions\r\n        var width = 128*Math.pow(0.5, mip);\r\n        var height = 128 * Math.pow(0.5, mip);\r\n        gl.viewport(0, 0, width, height);\r\n\r\n        //set roughness uniform\r\n        var roughness = mip/(mip_levels - 1);\r\n        gl.uniform1f(roughness_loc, roughness);\r\n\r\n        for(var i = 0; i<6; ++i){\r\n            //set view\r\n            gl.uniformMatrix4fv(view_loc, gl.FALSE, views[i]);\r\n\r\n            //render to texture\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,prefilter_map,mip);\r\n            gl.clear(gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT);\r\n            gl.drawArrays(gl.TRIANGLES, 0, 36);\r\n        }\r\n    }\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    gl.deleteFramebuffer(fbo);\r\n\r\n    return prefilter_map;\r\n}\r\n\r\nfunction brdflut_gen(gl, env_map){\r\n\r\n    const vao = gl.createVertexArray();\r\n    /*const buffer = gl.createBuffer();\r\n    gl.bindVertexArray(vao);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\r\n    gl.enableVertexAttribArray(layout['POSITION']);\r\n    gl.vertexAttribPointer(layout['POSITION'], 3, gl.FLOAT, gl.FALSE, 0, 0);\r\n*/\r\n    \r\n    //initialize program\r\n    var vs_src = `#version 300 es\r\n    layout( location = `+_config_js__WEBPACK_IMPORTED_MODULE_1__[\"layout\"]['POSITION']+` ) in vec3 position;\r\n\r\n    out vec2 v_position;\r\n    \r\n    void main(){\r\n        float x = float(((uint(gl_VertexID) + 2u) / 3u)%2u); \r\n        float y = float(((uint(gl_VertexID) + 1u) / 3u)%2u); \r\n\r\n        gl_Position = vec4(-1.0f + x*2.0f, -1.0f+y*2.0f, 0.0f, 1.0f);\r\n        v_position = vec2(x, y);\r\n    }`;\r\n    var fs_src = `#version 300 es\r\n    precision mediump float;\r\n\r\n    in vec2 v_position;\r\n    out vec4 color;\r\n\r\n    const float PI = 3.14159265359;\r\n\r\n\r\n    float VanDerCorpus(uint n, uint base)\r\n    {\r\n        float invBase = 1.0 / float(base);\r\n        float denom   = 1.0;\r\n        float result  = 0.0;\r\n\r\n        for(uint i = 0u; i < 32u; ++i)\r\n        {\r\n            if(n > 0u)\r\n            {\r\n                denom   = mod(float(n), 2.0);\r\n                result += denom * invBase;\r\n                invBase = invBase / 2.0;\r\n                n       = uint(float(n) / 2.0);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    vec2 Hammersley(uint i, uint N)\r\n    {\r\n        return vec2(float(i)/float(N), VanDerCorpus(i, 2u));\r\n    }\r\n\r\n    vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\r\n    {\r\n        float a = roughness*roughness;\r\n        \r\n        float phi = 2.0 * PI * Xi.x;\r\n        float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\r\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\r\n        \r\n        // from spherical coordinates to cartesian coordinates\r\n        vec3 H;\r\n        H.x = cos(phi) * sinTheta;\r\n        H.y = sin(phi) * sinTheta;\r\n        H.z = cosTheta;\r\n        \r\n        // from tangent-space vector to world-space sample vector\r\n        vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n        vec3 tangent   = normalize(cross(up, N));\r\n        vec3 bitangent = cross(N, tangent);\r\n        \r\n        vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n        return normalize(sampleVec);\r\n    }  \r\n\r\n    float GeometrySchlickGGX(float NdotV, float roughness)\r\n{\r\n    float a = roughness;\r\n    float k = (a * a) / 2.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n// ----------------------------------------------------------------------------\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\r\n{\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n} \r\n    vec2 IntegrateBRDF(float NdotV, float roughness)\r\n{\r\n    vec3 V;\r\n    V.x = sqrt(1.0 - NdotV*NdotV);\r\n    V.y = 0.0;\r\n    V.z = NdotV;\r\n\r\n    float A = 0.0;\r\n    float B = 0.0;\r\n\r\n    vec3 N = vec3(0.0, 0.0, 1.0);\r\n\r\n    const uint SAMPLE_COUNT = 1024u;\r\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\r\n    {\r\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\r\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\r\n        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n        float NdotL = max(L.z, 0.0);\r\n        float NdotH = max(H.z, 0.0);\r\n        float VdotH = max(dot(V, H), 0.0);\r\n\r\n        if(NdotL > 0.0)\r\n        {\r\n            float G = GeometrySmith(N, V, L, roughness);\r\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\r\n            float Fc = pow(1.0 - VdotH, 5.0);\r\n\r\n            A += (1.0 - Fc) * G_Vis;\r\n            B += Fc * G_Vis;\r\n        }\r\n    }\r\n    A /= float(SAMPLE_COUNT);\r\n    B /= float(SAMPLE_COUNT);\r\n    return vec2(A, B);\r\n}\r\n// ----------------------------------------------------------------------------\r\nvoid main() \r\n{\r\n    vec2 integratedBRDF = IntegrateBRDF(v_position.x, v_position.y);\r\n    color = vec4(integratedBRDF, 0.0, 1.0);\r\n}`;\r\n    var vs = gl.createShader(gl.VERTEX_SHADER);\r\n    gl.shaderSource(vs, vs_src);\r\n    gl.compileShader(vs);\r\n    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){\r\n        console.log(gl.getShaderInfoLog(vs));\r\n        gl.deleteShader(vs);\r\n    }\r\n    var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n    gl.shaderSource(fs, fs_src);\r\n    gl.compileShader(fs);\r\n    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){\r\n        console.log(gl.getShaderInfoLog(fs));\r\n        gl.deleteShader(fs);\r\n    }\r\n    var program = gl.createProgram();\r\n    gl.attachShader(program, vs);\r\n    gl.attachShader(program, fs);\r\n    gl.linkProgram(program);\r\n    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){\r\n        console.log(gl.getProgramInfoLog(program));\r\n        gl.deleteProgram(program);\r\n    }\r\n\r\n    var fbo = gl.createFramebuffer();\r\n    var rbo = gl.createRenderbuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n    /*gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);\r\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT24, 512, 512);\r\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rbo);*/\r\n    \r\n    //initialize brdflut texture\r\n    var brdflut = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, brdflut);\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 512, 512, 0, gl.RGB, gl.UNSIGNED_BYTE, null);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.bindTexture(gl.TEXTURE_2D, null);\r\n\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, brdflut, 0);\r\n\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n\r\n    //render brdf lut to texture\r\n    gl.viewport(0, 0, 512, 512);\r\n\r\n    gl.bindVertexArray(vao);\r\n    gl.useProgram(program);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n\r\n\r\n    gl.bindVertexArray(null);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n    return brdflut;\r\n\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/gltf_loader.js?");

/***/ }),

/***/ "./src/includes/common.js":
/*!********************************!*\
  !*** ./src/includes/common.js ***!
  \********************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EPSILON\", function() { return EPSILON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ARRAY_TYPE\", function() { return ARRAY_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RANDOM\", function() { return RANDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setMatrixArrayType\", function() { return setMatrixArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRadian\", function() { return toRadian; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nconst EPSILON = 0.000001;\nlet ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\nconst RANDOM = Math.random;\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\n\nconst degree = Math.PI / 180;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nfunction toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\nif (!Math.hypot) Math.hypot = function() {\n  var y = 0, i = arguments.length;\n  while (i--) y += arguments[i] * arguments[i];\n  return Math.sqrt(y);\n};\n\n\n//# sourceURL=webpack:///./src/includes/common.js?");

/***/ }),

/***/ "./src/includes/hdrpng.js":
/*!********************************!*\
  !*** ./src/includes/hdrpng.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * hdrpng.js - support for Radiance .HDR and RGBE / RGB9_E5 images in PNG.\n * @author Enki\n * @desc load/save Radiance .HDR, RGBE in PNG and RGB9_E5 in PNG for HTML5, webGL, webGL2.\n */\n(function (name, context, definition) {\n  if ( true && module.exports) module.exports = definition();\n  else if (true) __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")(name, definition);\n  else {}\n}('HDRImage', this, function () {\n  /**\n   * HDRImage - wrapper that exposes default Image like interface for HDR imgaes. (till extending HTMLCanvasElement actually works ..)\n   * @returns {HDRImage} a html HDR image element\n   */\n  function HDRImage() {\n    var res = document.createElement('canvas'), HDRsrc='t',HDRexposure=1.0,HDRgamma=2.2,HDRdata=null,context,HDRD;\n    res.__defineGetter__('exposure',function(){return HDRexposure});\n    res.__defineSetter__('exposure',function(val){ HDRexposure=val; if (HDRdata) { rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data); context.putImageData(HDRD,0,0); }});\n    res.__defineGetter__('gamma',function(){return HDRgamma});\n    res.__defineSetter__('gamma',function(val){ HDRgamma=val; if (HDRdata) { rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data); context.putImageData(HDRD,0,0); }});\n    res.__defineGetter__('dataFloat',function(){ return rgbeToFloat(HDRdata); });\n    res.__defineGetter__('dataRGBE',function(){ return HDRdata; });\n    res.toHDRBlob = function(cb,m,q) {\n      // Array to image.. slightly more involved.  \n        function createShader(gl, source, type) {\n            var shader = gl.createShader(type);\n            gl.shaderSource(shader, source);\n            gl.compileShader(shader);\n            return shader;\n        }\n        function createProgram(gl, vertexShaderSource, fragmentShaderSource) {\n            var program = gl.createProgram(),vs,fs;\n            gl.attachShader(program, vs=createShader(gl, vertexShaderSource, gl.VERTEX_SHADER));\n            gl.attachShader(program, fs=createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER));\n            gl.linkProgram(program); gl.deleteShader(vs); gl.deleteShader(fs);\n            return program;\n        };\n        var ar = (m && m.match(/rgb9_e5/i)) ? new Uint8Array( floatToRgb9_e5(rgbeToFloat(HDRdata)).buffer ) : new Uint8Array(HDRdata.buffer);\n        var vs2='precision highp float;\\nattribute vec3 position;\\nvarying vec2 tex;\\nvoid main() { tex = position.xy/2.0+0.5; gl_Position = vec4(position, 1.0); }';\n        var fs2='precision highp float;\\nprecision highp sampler2D;\\nuniform sampler2D tx;\\nvarying vec2 tex;\\nvoid main() { gl_FragColor = texture2D(tx,tex); }';\n        var x = this.width, y = this.height;\n        if (x*y*4 < ar.byteLength) return console.error('not big enough.');\n        var c = document.createElement('canvas');\n        c.width=x; c.height=y;\n        var gl = c.getContext('webgl',{antialias:false,alpha:true,premultipliedAlpha:false,preserveDrawingBuffer:true});\n\n        var texture = gl.createTexture();\n        gl.activeTexture(gl.TEXTURE0);  gl.bindTexture(gl.TEXTURE_2D, texture);  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, x, y, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(ar.buffer));\n\n        var program = createProgram(gl, vs2, fs2), uniformTexLocation = gl.getUniformLocation(program, 'tx');\n\n        var positions = new Float32Array([-1, -1, 0, 1, -1, 0, 1,  1, 0, 1,  1, 0, -1,  1, 0, -1, -1, 0 ]), vertexPosBuffer=gl.createBuffer();\n        gl.enableVertexAttribArray(0);\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);\n\n        gl.useProgram(program);\n        gl.uniform1i(uniformTexLocation, 0);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        \n        gl.deleteTexture(texture);\n        gl.deleteProgram(program);\n\n        if (cb) return c.toBlob(cb); \n    }\n    res.__defineGetter__('src',function(){return HDRsrc});\n    res.__defineSetter__('src',function(val){\n      HDRsrc=val;\n      context&&context.clearRect(0,0,this.width,this.height);\n      if (val.match(/\\.hdr$/i)) loadHDR(val,function(img,width,height){\n        HDRdata = img;\n        this.width  = this.style.width  = width;\n        this.height = this.style.height = height;\n        context = this.getContext('2d');\n        HDRD = context.getImageData(0,0,width,height);\n        rgbeToLDR(img,HDRexposure,HDRgamma,HDRD.data);\n        context.putImageData(HDRD,0,0);\n        this.onload&&this.onload(); \n      }.bind(res));\n      else if (val.match(/\\.rgb9_e5\\.png$/i)) {\n        var i = new Image();\n        i.src = val;\n        i.onload = function() {\n          var c = document.createElement('canvas'), x=this.width=this.style.width=c.width=i.width, y=this.height=this.style.height=c.height=i.height, gl=c.getContext('webgl');\n\n          var texture = gl.createTexture();\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);\n           \n          fb = gl.createFramebuffer();\n          gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n          gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n          var res = new Uint8Array(x*y*4);\n          gl.readPixels(0,0,x,y,gl.RGBA,gl.UNSIGNED_BYTE,res);\n\n          gl.deleteTexture(texture);\n          gl.deleteFramebuffer(fb);\n          \n          this.dataRAW = new Uint32Array(res.buffer);\n          HDRdata = floatToRgbe(rgb9_e5ToFloat(this.dataRAW));\n          context = this.getContext('2d');\n          HDRD = context.getImageData(0,0,x,y);\n          rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data);\n          context.putImageData(HDRD,0,0);\n          this.onload&&this.onload(); \n        }.bind(res);\n      } else if (val.match(/\\.hdr\\.png$|\\.rgbe\\.png/i)) {\n        var i = new Image();\n        i.src = val;\n        i.onload = function() {\n          var c = document.createElement('canvas'), x=this.width=this.style.width=c.width=i.width, y=this.height=this.style.height=c.height=i.height, gl=c.getContext('webgl');\n\n          var texture = gl.createTexture();\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, i);\n           \n          fb = gl.createFramebuffer();\n          gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n          gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n          var res = new Uint8Array(x*y*4);\n          gl.readPixels(0,0,x,y,gl.RGBA,gl.UNSIGNED_BYTE,res);\n\n          gl.deleteTexture(texture);\n          gl.deleteFramebuffer(fb);\n          \n          HDRdata = res;\n          context = this.getContext('2d');\n          HDRD = context.getImageData(0,0,x,y);\n          rgbeToLDR(HDRdata,HDRexposure,HDRgamma,HDRD.data);\n          context.putImageData(HDRD,0,0);\n          this.onload&&this.onload(); \n        }.bind(res);\n      }\n    });\n    return res;\n  }  \n  \n  function m(a,b) { for (var i in b) a[i]=b[i]; return a; };\n    \n  /** Load and parse a Radiance .HDR file. It completes with a 32bit RGBE buffer.\n    * @param {URL} url location of .HDR file to load.\n    * @param {function} completion completion callback.\n    * @returns {XMLHttpRequest} the XMLHttpRequest used to download the file.\n    */\n  function loadHDR( url, completion ) {\n    var req = m(new XMLHttpRequest(),{responseType:\"arraybuffer\"});\n    req.onerror = completion.bind(req,false);\n    req.onload  = function() {\n      if (this.status>=400) return this.onerror();\n      var header='',pos=0,d8=new Uint8Array(this.response),format;\n    // read header.  \n      while (!header.match(/\\n\\n[^\\n]+\\n/g)) header += String.fromCharCode(d8[pos++]);\n    // check format. \n      format = header.match(/FORMAT=(.*)$/m)[1];\n      if (format!='32-bit_rle_rgbe') return console.warn('unknown format : '+format),this.onerror();\n    // parse resolution\n      var rez=header.split(/\\n/).reverse()[1].split(' '), width=rez[3]*1, height=rez[1]*1;\n    // Create image.\n      var img=new Uint8Array(width*height*4),ipos=0;\n    // Read all scanlines\n      for (var j=0; j<height; j++) {\n        var rgbe=d8.slice(pos,pos+=4),scanline=[];\n        if ((rgbe[0]!=2)||(rgbe[1]!=2)||(rgbe[2]&0x80)) return console.warn('HDR parse error ..'),this.onerror();\n        if ((rgbe[2]<<8)+rgbe[3]!=width) return console.warn('HDR line mismatch ..'),this.onerror();\n        for (var i=0;i<4;i++) {\n            var ptr=i*width,ptr_end=(i+1)*width,buf,count;\n            while (ptr<ptr_end){\n                buf = d8.slice(pos,pos+=2);\n                if (buf[0] > 128) { count = buf[0]-128; while(count-- > 0) scanline[ptr++] = buf[1]; } \n                             else { count = buf[0]-1; scanline[ptr++]=buf[1]; while(count-->0) scanline[ptr++]=d8[pos++]; }\n            }\n        }\n        for (var i=0;i<width;i++) { img[ipos++]=scanline[i]; img[ipos++]=scanline[i+width]; img[ipos++]=scanline[i+2*width]; img[ipos++]=scanline[i+3*width]; }\n      }\n      completion&&completion(img,width,height);\n    }\n    req.open(\"GET\",url,true);\n    req.send(null);\n    return req;\n  }\n\n  /** Convert a float buffer to a RGB9_E5 buffer. (ref https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_shared_exponent.txt)\n    * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).\n    * @param {Uint32Array} [res] Optional output buffer with 32 bit RGB9_E5 per pixel.\n    * @returns {Uint32Array} A 32bit uint32 array in RGB9_E5\n    */\n  function floatToRgb9_e5(buffer,res) {\n    var r,g,b,v,maxColor,ExpShared,denom,s,l=(buffer.byteLength/12)|0, res=res||new Uint32Array(l);\n    for (var i=0;i<l;i++) {\n      r=Math.min(32768.0,buffer[i*3]); g=Math.min(32768.0,buffer[i*3+1]); b=Math.min(32768.0,buffer[i*3+2]);\n      maxColor = Math.max(Math.max(r,g),b);\n      ExpShared = Math.max(-16,Math.floor(Math.log2(maxColor))) + 16;\n      denom = Math.pow(2,ExpShared-24);\n      if (Math.floor(maxColor/denom+0.5) == 511) { denom *= 2; ExpShared += 1; }\n      res[i] = (Math.floor(r/denom+0.5)<<23)+(Math.floor(g/denom+0.5)<<14)+(Math.floor(b/denom+0.5)<<5)+ (ExpShared|0);\n    }\n    return res;\n  }\n\n  /** Convert an RGB9_E5 buffer to a Float buffer.\n    * @param {Uint32Array} Buffer in RGB9_E5 format. (Uint32 buffer).\n    * @param {Float32Array} [res] Optional float output buffer.\n    * @returns {Float32Array} A Float32Array.\n    */\n  function rgb9_e5ToFloat(buffer,res) {\n    var v,s,l=buffer.byteLength>>2, res=res||new Float32Array(l*3);\n    for (var i=0;i<l;i++) {\n      v = buffer[i]; s = Math.pow(2,(v&31)-24);\n      res[i*3]   =  (v>>>23)*s;\n      res[i*3+1] = ((v>>>14)&511)*s;\n      res[i*3+2] = ((v>>>5)&511)*s;\n    }\n    return res;\n  }\n\n  /** Convert a float buffer to a RGBE buffer.\n    * @param {Float32Array} Buffer Floating point input buffer (96 bits/pixel).\n    * @param {Uint8Array} [res] Optional output buffer with 32 bit RGBE per pixel.\n    * @returns {Uint8Array} A 32bit uint8 array in RGBE\n    */\n  function floatToRgbe(buffer,res) {\n    var r,g,b,v,s,l=(buffer.byteLength/12)|0, res=res||new Uint8Array(l*4);\n    for (var i=0;i<l;i++) {\n      r = buffer[i*3]; g = buffer[i*3+1]; b = buffer[i*3+2];\n      v = Math.max(Math.max(r,g),b); e = Math.ceil(Math.log2(v)); s = Math.pow(2,e-8);\n      res[i*4]   = (r/s)|0;\n      res[i*4+1] = (g/s)|0;\n      res[i*4+2] = (b/s)|0;\n      res[i*4+3] = (e+128);\n    }\n    return res;\n  }\n  \n  /** Convert an RGBE buffer to a Float buffer.\n    * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)\n    * @param {Float32Array} [res] Optional result buffer containing 3 floats per pixel.\n    * @returns {Float32Array} A floating point buffer with 96 bits per pixel (32 per channel, 3 channels).\n    */\n  function rgbeToFloat(buffer,res) {\n    var s,l=buffer.byteLength>>2, res=res||new Float32Array(l*3);\n    for (var i=0;i<l;i++) {\n      s = Math.pow(2,buffer[i*4+3]-(128+8));\n      res[i*3]=buffer[i*4]*s;\n      res[i*3+1]=buffer[i*4+1]*s;\n      res[i*3+2]=buffer[i*4+2]*s;\n    }\n    return res;\n  }\n  \n  /** Convert an RGBE buffer to LDR with given exposure and display gamma.\n    * @param {Uint8Array} buffer The input buffer in RGBE format. (as returned from loadHDR)\n    * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)\n    * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)\n    * @param {Array} [res] res Optional result buffer.\n    */\n  function rgbeToLDR(buffer,exposure,gamma,res) {\n    exposure = Math.pow(2,exposure===undefined?1:exposure)/2;\n    if (gamma===undefined) gamma = 2.2;\n    var one_over_gamma=1/gamma,s,l=buffer.byteLength>>2, res=res||new Uint8ClampedArray(l*4);\n    for (var i=0;i<l;i++) {\n      s = exposure * Math.pow(2,buffer[i*4+3]-(128+8));\n      res[i*4]  =255*Math.pow(buffer[i*4]*s,one_over_gamma);\n      res[i*4+1]=255*Math.pow(buffer[i*4+1]*s,one_over_gamma);\n      res[i*4+2]=255*Math.pow(buffer[i*4+2]*s,one_over_gamma);\n      res[i*4+3]=255;\n    }\n    return res;\n  }\n\n  /** Convert an float buffer to LDR with given exposure and display gamma.\n    * @param {Float32Array} buffer The input buffer in floating point format. \n    * @param {float} [exposure=1] Optional exposure value. (1=default, 2=1 step up, 3=2 steps up, -2 = 3 steps down)\n    * @param {float} [gamma=2.2]  Optional display gamma to respect. (1.0 = linear, 2.2 = default monitor)\n    * @param {Array} [res] res Optional result buffer.\n    */\n  function floatToLDR(buffer,exposure,gamma,res) {\n    exposure = Math.pow(2,exposure===undefined?1:exposure)/2;\n    if (gamma===undefined) gamma = 2.2;\n    var one_over_gamma=1/gamma,s,l=(buffer.byteLength/12)|0, res=res||new Uint8ClampedArray(l*4);\n    for (var i=0;i<l;i++) {\n      res[i*4]  =255*Math.pow(buffer[i*3]*exposure,one_over_gamma);\n      res[i*4+1]=255*Math.pow(buffer[i*3+1]*exposure,one_over_gamma);\n      res[i*4+2]=255*Math.pow(buffer[i*3+2]*exposure,one_over_gamma);\n      res[i*4+3]=255;\n    }\n    return res;\n  }\n  \n  \n  // Float/RGBE conversions.\n  HDRImage.floatToRgbe = floatToRgbe;\n  HDRImage.rgbeToFloat = rgbeToFloat;\n\n  // Float/RGB9_E5 conversions.\n  HDRImage.floatToRgb9_e5 = floatToRgb9_e5;\n  HDRImage.rgb9_e5ToFloat = rgb9_e5ToFloat; \n\n  // x to LDR conversion.\n  HDRImage.rgbeToLDR   = rgbeToLDR;\n  HDRImage.floatToLDR  = floatToLDR;\n  \n  \n  return HDRImage;\n}));\n\n\n//# sourceURL=webpack:///./src/includes/hdrpng.js?");

/***/ }),

/***/ "./src/includes/index.js":
/*!*******************************!*\
  !*** ./src/includes/index.js ***!
  \*******************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"glMatrix\", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ \"./src/includes/mat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2\", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ \"./src/includes/mat2d.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2d\", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ \"./src/includes/mat3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat3\", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ \"./src/includes/mat4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat4\", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ \"./src/includes/quat.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat\", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });\n/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ \"./src/includes/quat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat2\", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });\n/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ \"./src/includes/vec2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec2\", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ \"./src/includes/vec3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec3\", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ \"./src/includes/vec4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec4\", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/includes/index.js?");

/***/ }),

/***/ "./src/includes/mat2.js":
/*!******************************!*\
  !*** ./src/includes/mat2.js ***!
  \******************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LDU\", function() { return LDU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 2x2 Matrix\n * @module mat2\n */\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {mat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\nfunction fromValues(m00, m01, m10, m11) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\nfunction set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    let a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction invert(out, a) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n\n  // Calculate the determinant\n  let det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] =  a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] =  a0 * det;\n\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nfunction adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  let a0 = a[0];\n  out[0] =  a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] =  a0;\n\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {mat2} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction multiply(out, a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nfunction rotate(out, a, rad) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  out[0] = a0 *  c + a2 * s;\n  out[1] = a1 *  c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nfunction scale(out, a, v) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let v0 = v[0], v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nfunction fromRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {mat2} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {mat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[2],a[3]))\n}\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {mat2} L the lower triangular matrix\n * @param {mat2} D the diagonal matrix\n * @param {mat2} U the upper triangular matrix\n * @param {mat2} a the input matrix to factorize\n */\n\nfunction LDU(L, D, U, a) {\n  L[2] = a[2]/a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  return out;\n}\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat2.js?");

/***/ }),

/***/ "./src/includes/mat2d.js":
/*!*******************************!*\
  !*** ./src/includes/mat2d.js ***!
  \*******************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 2x3 Matrix\n * @module mat2d\n *\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, b, c,\n *  d, tx, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, b, 0,\n *  c, d, 0,\n *  tx, ty, 1]\n * </pre>\n * The last column is ignored so the array is shorter and operations are faster.\n */\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {mat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\nfunction fromValues(a, b, c, d, tx, ty) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\nfunction set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nfunction invert(out, a) {\n  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];\n  let atx = a[4], aty = a[5];\n\n  let det = aa * ad - ab * ac;\n  if(!det){\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {mat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction multiply(out, a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nfunction rotate(out, a, rad) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  out[0] = a0 *  c + a2 * s;\n  out[1] = a1 *  c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nfunction scale(out, a, v) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let v0 = v[0], v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nfunction translate(out, a, v) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let v0 = v[0], v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nfunction fromRotation(out, rad) {\n  let s = Math.sin(rad), c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2d} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat2d} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {mat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +\n          a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {mat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[2],a[3],a[4],a[5],1))\n}\n\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  out[4] = a[4] + (b[4] * scale);\n  out[5] = a[5] + (b[5] * scale);\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n          Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n          Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));\n}\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat2d.js?");

/***/ }),

/***/ "./src/includes/mat3.js":
/*!******************************!*\
  !*** ./src/includes/mat3.js ***!
  \******************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat2d\", function() { return fromMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalFromMat4\", function() { return normalFromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projection\", function() { return projection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1], a02 = a[2], a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction invert(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  let b01 = a22 * a11 - a12 * a21;\n  let b11 = -a22 * a10 + a12 * a20;\n  let b21 = a21 * a10 - a11 * a20;\n\n  // Calculate the determinant\n  let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nfunction adjoint(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  out[0] = (a11 * a22 - a12 * a21);\n  out[1] = (a02 * a21 - a01 * a22);\n  out[2] = (a01 * a12 - a02 * a11);\n  out[3] = (a12 * a20 - a10 * a22);\n  out[4] = (a00 * a22 - a02 * a20);\n  out[5] = (a02 * a10 - a00 * a12);\n  out[6] = (a10 * a21 - a11 * a20);\n  out[7] = (a01 * a20 - a00 * a21);\n  out[8] = (a00 * a11 - a01 * a10);\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction multiply(out, a, b) {\n  let a00 = a[0], a01 = a[1], a02 = a[2];\n  let a10 = a[3], a11 = a[4], a12 = a[5];\n  let a20 = a[6], a21 = a[7], a22 = a[8];\n\n  let b00 = b[0], b01 = b[1], b02 = b[2];\n  let b10 = b[3], b11 = b[4], b12 = b[5];\n  let b20 = b[6], b21 = b[7], b22 = b[8];\n\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nfunction translate(out, a, v) {\n  let a00 = a[0], a01 = a[1], a02 = a[2],\n    a10 = a[3], a11 = a[4], a12 = a[5],\n    a20 = a[6], a21 = a[7], a22 = a[8],\n    x = v[0], y = v[1];\n\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nfunction rotate(out, a, rad) {\n  let a00 = a[0], a01 = a[1], a02 = a[2],\n    a10 = a[3], a11 = a[4], a12 = a[5],\n    a20 = a[6], a21 = a[7], a22 = a[8],\n\n    s = Math.sin(rad),\n    c = Math.cos(rad);\n\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n};\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nfunction scale(out, a, v) {\n  let x = v[0], y = v[1];\n\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat3} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nfunction fromRotation(out, rad) {\n  let s = Math.sin(rad), c = Math.cos(rad);\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat3} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n\n/**\n* Calculates a 3x3 matrix from the given quaternion\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {quat} q Quaternion to create matrix from\n*\n* @returns {mat3} out\n*/\nfunction fromQuat(out, q) {\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n\n  return out;\n}\n\n/**\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {mat4} a Mat4 to derive the normal matrix from\n*\n* @returns {mat3} out\n*/\nfunction normalFromMat4(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n  return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nfunction projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +\n          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +\n          a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]))\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n\n\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  out[4] = a[4] + (b[4] * scale);\n  out[5] = a[5] + (b[5] * scale);\n  out[6] = a[6] + (b[6] * scale);\n  out[7] = a[7] + (b[7] * scale);\n  out[8] = a[8] + (b[8] * scale);\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&\n         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&\n         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n          Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n          Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n          Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n          Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n          Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));\n}\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat3.js?");

/***/ }),

/***/ "./src/includes/mat4.js":
/*!******************************!*\
  !*** ./src/includes/mat4.js ***!
  \******************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromXRotation\", function() { return fromXRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromYRotation\", function() { return fromYRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromZRotation\", function() { return fromZRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat2\", function() { return fromQuat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScaling\", function() { return getScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRotation\", function() { return getRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScale\", function() { return fromRotationTranslationScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScaleOrigin\", function() { return fromRotationTranslationScaleOrigin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frustum\", function() { return frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspective\", function() { return perspective; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspectiveFromFieldOfView\", function() { return perspectiveFromFieldOfView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ortho\", function() { return ortho; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lookAt\", function() { return lookAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"targetTo\", function() { return targetTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    let a01 = a[1], a02 = a[2], a03 = a[3];\n    let a12 = a[6], a13 = a[7];\n    let a23 = a[11];\n\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction invert(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction adjoint(out, a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\n  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\n  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\n  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\n  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\n  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nfunction determinant(a) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  let b00 = a00 * a11 - a01 * a10;\n  let b01 = a00 * a12 - a02 * a10;\n  let b02 = a00 * a13 - a03 * a10;\n  let b03 = a01 * a12 - a02 * a11;\n  let b04 = a01 * a13 - a03 * a11;\n  let b05 = a02 * a13 - a03 * a12;\n  let b06 = a20 * a31 - a21 * a30;\n  let b07 = a20 * a32 - a22 * a30;\n  let b08 = a20 * a33 - a23 * a30;\n  let b09 = a21 * a32 - a22 * a31;\n  let b10 = a21 * a33 - a23 * a31;\n  let b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction multiply(out, a, b) {\n  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];\n  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n  // Cache only the current line of the second matrix\n  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];\n  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];\n  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];\n  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n  return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nfunction translate(out, a, v) {\n  let x = v[0], y = v[1], z = v[2];\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;\n    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;\n    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;\n\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nfunction scale(out, a, v) {\n  let x = v[0], y = v[1], z = v[2];\n\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nfunction rotate(out, a, rad, axis) {\n  let x = axis[0], y = axis[1], z = axis[2];\n  let len = Math.hypot(x,y,z);\n  let s, c, t;\n  let a00, a01, a02, a03;\n  let a10, a11, a12, a13;\n  let a20, a21, a22, a23;\n  let b00, b01, b02;\n  let b10, b11, b12;\n  let b20, b21, b22;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) { return null; }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n  // Construct the elements of the rotation matrix\n  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateX(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a10 = a[4];\n  let a11 = a[5];\n  let a12 = a[6];\n  let a13 = a[7];\n  let a20 = a[8];\n  let a21 = a[9];\n  let a22 = a[10];\n  let a23 = a[11];\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged rows\n    out[0]  = a[0];\n    out[1]  = a[1];\n    out[2]  = a[2];\n    out[3]  = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateY(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a00 = a[0];\n  let a01 = a[1];\n  let a02 = a[2];\n  let a03 = a[3];\n  let a20 = a[8];\n  let a21 = a[9];\n  let a22 = a[10];\n  let a23 = a[11];\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged rows\n    out[4]  = a[4];\n    out[5]  = a[5];\n    out[6]  = a[6];\n    out[7]  = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction rotateZ(out, a, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n  let a00 = a[0];\n  let a01 = a[1];\n  let a02 = a[2];\n  let a03 = a[3];\n  let a10 = a[4];\n  let a11 = a[5];\n  let a12 = a[6];\n  let a13 = a[7];\n\n  if (a !== out) { // If the source and destination differ, copy the unchanged last row\n    out[8]  = a[8];\n    out[9]  = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  // Perform axis-specific matrix multiplication\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Scaling vector\n * @returns {mat4} out\n */\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nfunction fromRotation(out, rad, axis) {\n  let x = axis[0], y = axis[1], z = axis[2];\n  let len = Math.hypot(x, y, z);\n  let s, c, t;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) { return null; }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n\n  // Perform rotation-specific matrix multiplication\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromXRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0]  = 1;\n  out[1]  = 0;\n  out[2]  = 0;\n  out[3]  = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromYRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0]  = c;\n  out[1]  = 0;\n  out[2]  = -s;\n  out[3]  = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nfunction fromZRotation(out, rad) {\n  let s = Math.sin(rad);\n  let c = Math.cos(rad);\n\n  // Perform axis-specific matrix multiplication\n  out[0]  = c;\n  out[1]  = s;\n  out[2]  = 0;\n  out[3]  = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {quat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\nfunction fromQuat2(out, a) {\n  let translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  let bx = -a[0], by = -a[1], bz = -a[2], bw = a[3],\n  ax = a[4], ay = a[5], az = a[6], aw = a[7];\n\n  let magnitude = bx * bx + by * by + bz * bz + bw * bw;\n  //Only scale if it makes sense\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n\n  return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nfunction getScaling(out, mat) {\n  let m11 = mat[0];\n  let m12 = mat[1];\n  let m13 = mat[2];\n  let m21 = mat[4];\n  let m22 = mat[5];\n  let m23 = mat[6];\n  let m31 = mat[8];\n  let m32 = mat[9];\n  let m33 = mat[10];\n\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n\n  return out;\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nfunction getRotation(out, mat) {\n  let scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  getScaling(scaling, mat);\n\n  let is1 = 1 / scaling[0];\n  let is2 = 1 / scaling[1];\n  let is3 = 1 / scaling[2];\n\n  let sm11 = mat[0] * is1;\n  let sm12 = mat[1] * is2;\n  let sm13 = mat[2] * is3;\n  let sm21 = mat[4] * is1;\n  let sm22 = mat[5] * is2;\n  let sm23 = mat[6] * is3;\n  let sm31 = mat[8] * is1;\n  let sm32 = mat[9] * is2;\n  let sm33 = mat[10] * is3;\n\n  let trace = sm11 + sm22 + sm33;\n  let S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if ((sm11 > sm22) && (sm11 > sm33)) {\n    S = Math.sqrt(1.0 + sm11 - sm22- sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @param {vec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let xy = x * y2;\n  let xz = x * z2;\n  let yy = y * y2;\n  let yz = y * z2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  let sx = s[0];\n  let sy = s[1];\n  let sz = s[2];\n\n  let ox = o[0];\n  let oy = o[1];\n  let oz = o[2];\n\n  let out0 = (1 - (yy + zz)) * sx;\n  let out1 = (xy + wz) * sx;\n  let out2 = (xz - wy) * sx;\n  let out4 = (xy - wz) * sy;\n  let out5 = (1 - (xx + zz)) * sy;\n  let out6 = (yz + wx) * sy;\n  let out8 = (xz + wy) * sz;\n  let out9 = (yz - wx) * sz;\n  let out10 = (1 - (xx + yy)) * sz;\n\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nfunction fromQuat(out, q) {\n  let x = q[0], y = q[1], z = q[2], w = q[3];\n  let x2 = x + x;\n  let y2 = y + y;\n  let z2 = z + z;\n\n  let xx = x * x2;\n  let yx = y * x2;\n  let yy = y * y2;\n  let zx = z * x2;\n  let zy = z * y2;\n  let zz = z * z2;\n  let wx = w * x2;\n  let wy = w * y2;\n  let wz = w * z2;\n\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction frustum(out, left, right, bottom, top, near, far) {\n  let rl = 1 / (right - left);\n  let tb = 1 / (top - bottom);\n  let nf = 1 / (near - far);\n  out[0] = (near * 2) * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = (near * 2) * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = (far * near * 2) * nf;\n  out[15] = 0;\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\nfunction perspective(out, fovy, aspect, near, far) {\n  let f = 1.0 / Math.tan(fovy / 2), nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = (2 * far * near) * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n  return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);\n  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);\n  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);\n  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);\n  let xScale = 2.0 / (leftTan + rightTan);\n  let yScale = 2.0 / (upTan + downTan);\n\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = ((upTan - downTan) * yScale * 0.5);\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = (far * near) / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction ortho(out, left, right, bottom, top, near, far) {\n  let lr = 1 / (left - right);\n  let bt = 1 / (bottom - top);\n  let nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nfunction lookAt(out, eye, center, up) {\n  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  let eyex = eye[0];\n  let eyey = eye[1];\n  let eyez = eye[2];\n  let upx = up[0];\n  let upy = up[1];\n  let upz = up[2];\n  let centerx = center[0];\n  let centery = center[1];\n  let centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] &&\n      Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] &&\n      Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n\n  len = Math.hypot(y0, y1, y2);\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n\n  return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nfunction targetTo(out, eye, target, up) {\n  let eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n\n  let z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n\n  let len = z0*z0 + z1*z1 + z2*z2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  let x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n\n  len = x0*x0 + x1*x1 + x2*x2;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n};\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {mat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nfunction str(a) {\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +\n          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +\n          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n}\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {mat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nfunction frob(a) {\n  return(Math.hypot(a[0],a[1],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]))\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  out[4] = a[4] + (b[4] * scale);\n  out[5] = a[5] + (b[5] * scale);\n  out[6] = a[6] + (b[6] * scale);\n  out[7] = a[7] + (b[7] * scale);\n  out[8] = a[8] + (b[8] * scale);\n  out[9] = a[9] + (b[9] * scale);\n  out[10] = a[10] + (b[10] * scale);\n  out[11] = a[11] + (b[11] * scale);\n  out[12] = a[12] + (b[12] * scale);\n  out[13] = a[13] + (b[13] * scale);\n  out[14] = a[14] + (b[14] * scale);\n  out[15] = a[15] + (b[15] * scale);\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&\n         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&\n         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&\n         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];\n  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];\n  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];\n  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];\n\n  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];\n  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];\n  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];\n  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n          Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n          Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n          Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n          Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n          Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&\n          Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&\n          Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&\n          Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&\n          Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&\n          Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&\n          Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&\n          Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));\n}\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nconst sub = subtract;\n\n\n//# sourceURL=webpack:///./src/includes/mat4.js?");

/***/ }),

/***/ "./src/includes/quat.js":
/*!******************************!*\
  !*** ./src/includes/quat.js ***!
  \******************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxisAngle\", function() { return setAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAxisAngle\", function() { return getAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateW\", function() { return calculateW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slerp\", function() { return slerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat3\", function() { return fromMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromEuler\", function() { return fromEuler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotationTo\", function() { return rotationTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqlerp\", function() { return sqlerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxes\", function() { return setAxes; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ \"./src/includes/mat3.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ \"./src/includes/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ \"./src/includes/vec4.js\");\n\n\n\n\n\n/**\n * Quaternion\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  let s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {quat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nfunction getAxisAngle(out_axis, q) {\n  let rad = Math.acos(q[3]) * 2.0;\n  let s = Math.sin(rad / 2.0);\n  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nfunction multiply(out, a, b) {\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bx = Math.sin(rad), bw = Math.cos(rad);\n\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let by = Math.sin(rad), bw = Math.cos(rad);\n\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bz = Math.sin(rad), bw = Math.cos(rad);\n\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate W component of\n * @returns {quat} out\n */\nfunction calculateW(out, a) {\n  let x = a[0], y = a[1], z = a[2];\n\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n  let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n  let omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if ( cosom < 0.0 ) {\n    cosom = -cosom;\n    bx = - bx;\n    by = - by;\n    bz = - bz;\n    bw = - bw;\n  }\n  // calculate coefficients\n  if ( (1.0 - cosom) > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] ) {\n    // standard case (slerp)\n    omega  = Math.acos(cosom);\n    sinom  = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n\n  return out;\n}\n\n/**\n * Generates a random quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nfunction random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  let u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n  let u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n  let u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\n\n  let sqrt1MinusU1 = Math.sqrt(1 - u1);\n  let sqrtU1 = Math.sqrt(u1);\n\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nfunction invert(out, a) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;\n  let invDot = dot ? 1.0/dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0*invDot;\n  out[1] = -a1*invDot;\n  out[2] = -a2*invDot;\n  out[3] = a3*invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  let fTrace = m[0] + m[4] + m[8];\n  let fRoot;\n\n  if ( fTrace > 0.0 ) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0);  // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5/fRoot;  // 1/(4w)\n    out[0] = (m[5]-m[7])*fRoot;\n    out[1] = (m[6]-m[2])*fRoot;\n    out[2] = (m[1]-m[3])*fRoot;\n  } else {\n    // |w| <= 1/2\n    let i = 0;\n    if ( m[4] > m[0] )\n      i = 1;\n    if ( m[8] > m[i*3+i] )\n      i = 2;\n    let j = (i+1)%3;\n    let k = (i+2)%3;\n\n    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;\n    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;\n    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;\n  }\n\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {x} Angle to rotate around X axis in degrees.\n * @param {y} Angle to rotate around Y axis in degrees.\n * @param {z} Angle to rotate around Z axis in degrees.\n * @returns {quat} out\n * @function\n */\nfunction fromEuler(out, x, y, z) {\n    let halfToRad = 0.5 * Math.PI / 180.0;\n    x *= halfToRad;\n    y *= halfToRad;\n    z *= halfToRad;\n\n    let sx = Math.sin(x);\n    let cx = Math.cos(x);\n    let sy = Math.sin(y);\n    let cy = Math.cos(y);\n    let sz = Math.sin(z);\n    let cz = Math.cos(z);\n\n    out[0] = sx * cy * cz - cx * sy * sz;\n    out[1] = cx * sy * cz + sx * cy * sz;\n    out[2] = cx * cy * sz - sx * sy * cz;\n    out[3] = cx * cy * cz + sx * sy * sz;\n\n    return out;\n}\n\n/**\n * Returns a string representation of a quatenion\n *\n * @param {quat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nconst clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"clone\"];\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nconst fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"fromValues\"];\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nconst copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"copy\"];\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nconst set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"set\"];\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nconst add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"add\"];\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nconst scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"];\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nconst dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"dot\"];\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nconst lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"lerp\"];\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\nconst length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"length\"];\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nconst len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {quat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nconst squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"squaredLength\"];\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nconst normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"normalize\"];\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat} a The first quaternion.\n * @param {quat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nconst exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"exactEquals\"];\n\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {quat} a The first vector.\n * @param {quat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nconst equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"equals\"];\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nconst rotationTo = (function() {\n  let tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"create\"]();\n  let xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](1,0,0);\n  let yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](0,1,0);\n\n  return function(out, a, b) {\n    let dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"dot\"](a, b);\n    if (dot < -0.999999) {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, xUnitVec3, a);\n      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"len\"](tmpvec3) < 0.000001)\n        _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, yUnitVec3, a);\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"normalize\"](tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n})();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nconst sqlerp = (function () {\n  let temp1 = create();\n  let temp2 = create();\n\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n\n    return out;\n  };\n}());\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {vec3} view  the vector representing the viewing direction\n * @param {vec3} right the vector representing the local \"right\" direction\n * @param {vec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nconst setAxes = (function() {\n  let matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\n\n  return function(out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n\n    return normalize(out, fromMat3(out, matr));\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/quat.js?");

/***/ }),

/***/ "./src/includes/quat2.js":
/*!*******************************!*\
  !*** ./src/includes/quat2.js ***!
  \*******************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationValues\", function() { return fromRotationTranslationValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getReal\", function() { return getReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDual\", function() { return getDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setReal\", function() { return setReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDual\", function() { return setDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatAppend\", function() { return rotateByQuatAppend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatPrepend\", function() { return rotateByQuatPrepend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateAroundAxis\", function() { return rotateAroundAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ \"./src/includes/quat.js\");\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ \"./src/includes/mat4.js\");\n\n\n\n\n/**\n * Dual Quaternion<br>\n * Format: [real, dual]<br>\n * Quaternion format: XYZW<br>\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\n * @module quat2\n */\n\n\n/**\n * Creates a new identity dual quat\n *\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\n */\nfunction create() {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    dq[0] = 0;\n    dq[1] = 0;\n    dq[2] = 0;\n    dq[4] = 0;\n    dq[5] = 0;\n    dq[6] = 0;\n    dq[7] = 0;\n  }\n  dq[3] = 1;\n  return dq;\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat2} a dual quaternion to clone\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction clone(a) {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n\n/**\n * Creates a new dual quat initialized with the given values\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n\n/**\n * Creates a new dual quat from the given values (quat and translation)\n *\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component (translation)\n * @param {Number} y2 Y component (translation)\n * @param {Number} z2 Z component (translation)\n * @returns {quat2} new dual quaternion\n * @function\n */\nfunction fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  let dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  let ax = x2 * 0.5,\n    ay = y2 * 0.5,\n    az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n\n/**\n * Creates a dual quat from a quaternion and a translation\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {quat} q a normalized quaternion\n * @param {vec3} t tranlation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromRotationTranslation(out, q, t) {\n  let ax = t[0] * 0.5,\n    ay = t[1] * 0.5,\n    az = t[2] * 0.5,\n    bx = q[0],\n    by = q[1],\n    bz = q[2],\n    bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Creates a dual quat from a translation\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {vec3} t translation vector\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Creates a dual quat from a quaternion\n *\n * @param {quat2} dual quaternion receiving operation result\n * @param {quat} q the quaternion\n * @returns {quat2} dual quaternion receiving operation result\n * @function\n */\nfunction fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Creates a new dual quat from a matrix (4x4)\n *\n * @param {quat2} out the dual quaternion\n * @param {mat4} a the matrix\n * @returns {quat2} dual quat receiving operation result\n * @function\n */\nfunction fromMat4(out, a) {\n  //TODO Optimize this\n  let outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getRotation\"](outer, a);\n  let t = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getTranslation\"](t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n\n/**\n * Copy the values from one dual quat to another\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the source dual quaternion\n * @returns {quat2} out\n * @function\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n\n/**\n * Set a dual quat to the identity dual quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @returns {quat2} out\n */\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n\n/**\n * Set the components of a dual quat to the given values\n *\n * @param {quat2} out the receiving quaternion\n * @param {Number} x1 X component\n * @param {Number} y1 Y component\n * @param {Number} z1 Z component\n * @param {Number} w1 W component\n * @param {Number} x2 X component\n * @param {Number} y2 Y component\n * @param {Number} z2 Z component\n * @param {Number} w2 W component\n * @returns {quat2} out\n * @function\n */\nfunction set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n\n/**\n * Gets the real part of a dual quat\n * @param  {quat} out real part\n * @param  {quat2} a Dual Quaternion\n * @return {quat} real part\n */\nconst getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\n\n/**\n * Gets the dual part of a dual quat\n * @param  {quat} out dual part\n * @param  {quat2} a Dual Quaternion\n * @return {quat} dual part\n */\nfunction getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n\n/**\n * Set the real component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat} q a quaternion representing the real part\n * @returns {quat2} out\n * @function\n */\nconst setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\n\n/**\n * Set the dual component of a dual quat to the given quaternion\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat} q a quaternion representing the dual part\n * @returns {quat2} out\n * @function\n */\nfunction setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n\n/**\n * Gets the translation of a normalized dual quat\n * @param  {vec3} out translation\n * @param  {quat2} a Dual Quaternion to be decomposed\n * @return {vec3} translation\n */\nfunction getTranslation(out, a) {\n  let ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n\n/**\n * Translates a dual quat by the given vector\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to translate\n * @param {vec3} v vector to translate by\n * @returns {quat2} out\n */\nfunction translate(out, a, v) {\n  let ax1 = a[0],\n    ay1 = a[1],\n    az1 = a[2],\n    aw1 = a[3],\n    bx1 = v[0] * 0.5,\n    by1 = v[1] * 0.5,\n    bz1 = v[2] * 0.5,\n    ax2 = a[4],\n    ay2 = a[5],\n    az2 = a[6],\n    aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the X axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateX(out, a, rad) {\n  let bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    ax1 = ax * bw + aw * bx + ay * bz - az * by,\n    ay1 = ay * bw + aw * by + az * bx - ax * bz,\n    az1 = az * bw + aw * bz + ax * by - ay * bx,\n    aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateX\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the Y axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateY(out, a, rad) {\n  let bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    ax1 = ax * bw + aw * bx + ay * bz - az * by,\n    ay1 = ay * bw + aw * by + az * bx - ax * bz,\n    az1 = az * bw + aw * bz + ax * by - ay * bx,\n    aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateY\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around the Z axis\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {number} rad how far should the rotation be\n * @returns {quat2} out\n */\nfunction rotateZ(out, a, rad) {\n  let bx = -a[0],\n    by = -a[1],\n    bz = -a[2],\n    bw = a[3],\n    ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7],\n    ax1 = ax * bw + aw * bx + ay * bz - az * by,\n    ay1 = ay * bw + aw * by + az * bx - ax * bz,\n    az1 = az * bw + aw * bz + ax * by - ay * bx,\n    aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateZ\"](out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat by a given quaternion (a * q)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {quat} q quaternion to rotate by\n * @returns {quat2} out\n */\nfunction rotateByQuatAppend(out, a, q) {\n  let qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3],\n    ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n\n/**\n * Rotates a dual quat by a given quaternion (q * a)\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat} q quaternion to rotate by\n * @param {quat2} a the dual quaternion to rotate\n * @returns {quat2} out\n */\nfunction rotateByQuatPrepend(out, q, a) {\n  let qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3],\n    bx = a[0],\n    by = a[1],\n    bz = a[2],\n    bw = a[3];\n\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n\n/**\n * Rotates a dual quat around a given axis. Does the normalisation automatically\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the dual quaternion to rotate\n * @param {vec3} axis the axis to rotate around\n * @param {Number} rad how far the rotation should be\n * @returns {quat2} out\n */\nfunction rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\n    return copy(out, a);\n  }\n  let axisLength = Math.hypot(axis[0],axis[1],axis[2]);\n\n  rad = rad * 0.5;\n  let s = Math.sin(rad);\n  let bx = s * axis[0] / axisLength;\n  let by = s * axis[1] / axisLength;\n  let bz = s * axis[2] / axisLength;\n  let bw = Math.cos(rad);\n\n  let ax1 = a[0],\n    ay1 = a[1],\n    az1 = a[2],\n    aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n\n  let ax = a[4],\n    ay = a[5],\n    az = a[6],\n    aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n\n  return out;\n}\n\n/**\n * Adds two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {quat2} out\n * @function\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n\n/**\n * Multiplies two dual quat's\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {quat2} out\n */\nfunction multiply(out, a, b) {\n  let ax0 = a[0],\n    ay0 = a[1],\n    az0 = a[2],\n    aw0 = a[3],\n    bx1 = b[4],\n    by1 = b[5],\n    bz1 = b[6],\n    bw1 = b[7],\n    ax1 = a[4],\n    ay1 = a[5],\n    az1 = a[6],\n    aw1 = a[7],\n    bx0 = b[0],\n    by0 = b[1],\n    bz0 = b[2],\n    bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n\n/**\n * Alias for {@link quat2.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Scales a dual quat by a scalar number\n *\n * @param {quat2} out the receiving dual quat\n * @param {quat2} a the dual quat to scale\n * @param {Number} b amount to scale the dual quat by\n * @returns {quat2} out\n * @function\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n\n/**\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\n *\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nconst dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"dot\"];\n\n/**\n * Performs a linear interpolation between two dual quats's\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\n *\n * @param {quat2} out the receiving dual quat\n * @param {quat2} a the first operand\n * @param {quat2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat2} out\n */\nfunction lerp(out, a, b, t) {\n  let mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n\n  return out;\n}\n\n/**\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a dual quat to calculate inverse of\n * @returns {quat2} out\n */\nfunction invert(out, a) {\n  let sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a dual quat\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\n *\n * @param {quat2} out the receiving quaternion\n * @param {quat2} a quat to calculate conjugate of\n * @returns {quat2} out\n */\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n\n/**\n * Calculates the length of a dual quat\n *\n * @param {quat2} a dual quat to calculate length of\n * @returns {Number} length of a\n * @function\n */\nconst length = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"length\"];\n\n/**\n * Alias for {@link quat2.length}\n * @function\n */\nconst len = length;\n\n/**\n * Calculates the squared length of a dual quat\n *\n * @param {quat2} a dual quat to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nconst squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"squaredLength\"];\n\n/**\n * Alias for {@link quat2.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Normalize a dual quat\n *\n * @param {quat2} out the receiving dual quaternion\n * @param {quat2} a dual quaternion to normalize\n * @returns {quat2} out\n * @function\n */\nfunction normalize(out, a) {\n  let magnitude = squaredLength(a);\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n\n    let a0 = a[0] / magnitude;\n    let a1 = a[1] / magnitude;\n    let a2 = a[2] / magnitude;\n    let a3 = a[3] / magnitude;\n\n    let b0 = a[4];\n    let b1 = a[5];\n    let b2 = a[6];\n    let b3 = a[7];\n\n    let a_dot_b = (a0 * b0) + (a1 * b1) + (a2 * b2) + (a3 * b3);\n\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n\n    out[4] = (b0 - (a0 * a_dot_b)) / magnitude;\n    out[5] = (b1 - (a1 * a_dot_b)) / magnitude;\n    out[6] = (b2 - (a2 * a_dot_b)) / magnitude;\n    out[7] = (b3 - (a3 * a_dot_b)) / magnitude;\n  }\n  return out;\n}\n\n/**\n * Returns a string representation of a dual quatenion\n *\n * @param {quat2} a dual quaternion to represent as a string\n * @returns {String} string representation of the dual quat\n */\nfunction str(a) {\n  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';\n}\n\n/**\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat2} a the first dual quaternion.\n * @param {quat2} b the second dual quaternion.\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&\n    a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n\n/**\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\n *\n * @param {quat2} a the first dual quat.\n * @param {quat2} b the second dual quat.\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3],\n    a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7];\n  let b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n    Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n    Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n    Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n    Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n    Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n    Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n    Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)));\n}\n\n\n//# sourceURL=webpack:///./src/includes/quat2.js?");

/***/ }),

/***/ "./src/includes/vec2.js":
/*!******************************!*\
  !*** ./src/includes/vec2.js ***!
  \******************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2\", function() { return transformMat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2d\", function() { return transformMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nfunction fromValues(x, y) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to ceil\n * @returns {vec2} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to floor\n * @returns {vec2} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to round\n * @returns {vec2} out\n */\nfunction round (out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x*x + y*y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.hypot(x, y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength (a) {\n  var x = a[0],\n    y = a[1];\n  return x*x + y*y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nfunction normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x*x + y*y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }    \n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nfunction transformMat4(out, a, m) {\n  let x = a[0];\n  let y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {vec2} a The vec2 point to rotate\n * @param {vec2} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec2} out\n */\nfunction rotate(out, a, b, c) {\n  //Translate point to the origin\n  let p0 = a[0] - b[0],\n  p1 = a[1] - b[1],\n  sinC = Math.sin(c),\n  cosC = Math.cos(c);\n  \n  //perform rotation and translate to correct position\n  out[0] = p0*cosC - p1*sinC + b[0];\n  out[1] = p0*sinC + p1*cosC + b[1];\n\n  return out;\n}\n\n/**\n * Get the angle between two 2D vectors\n * @param {vec2} a The first operand\n * @param {vec2} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n  let x1 = a[0],\n    y1 = a[1],\n    x2 = b[0],\n    y2 = b[1];\n  \n  let len1 = x1*x1 + y1*y1;\n  if (len1 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len1 = 1 / Math.sqrt(len1);\n  }\n  \n  let len2 = x2*x2 + y2*y2;\n  if (len2 > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len2 = 1 / Math.sqrt(len2);\n  }\n  \n  let cosine = (x1 * x2 + y1 * y2) * len1 * len2;\n  \n  \n  if(cosine > 1.0) {\n    return 0;\n  }\n  else if(cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1];\n  let b0 = b[0], b1 = b[1];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));\n}\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nconst len = length;\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nconst sub = subtract;\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nconst div = divide;\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nconst dist = distance;\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nconst sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nconst forEach = (function() {\n  let vec = create();\n\n  return function(a, stride, offset, count, fn, arg) {\n    let i, l;\n    if(!stride) {\n      stride = 2;\n    }\n\n    if(!offset) {\n      offset = 0;\n    }\n\n    if(count) {\n      l = Math.min((count * stride) + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for(i = offset; i < l; i += stride) {\n      vec[0] = a[i]; vec[1] = a[i+1];\n      fn(vec, vec, arg);\n      a[i] = vec[0]; a[i+1] = vec[1];\n    }\n\n    return a;\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/vec2.js?");

/***/ }),

/***/ "./src/includes/vec3.js":
/*!******************************!*\
  !*** ./src/includes/vec3.js ***!
  \******************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hermite\", function() { return hermite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bezier\", function() { return bezier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return Math.hypot(x, y, z);\n}\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  return x*x + y*y + z*z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  return x*x + y*y + z*z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let len = x*x + y*y + z*z;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n  let ax = a[0], ay = a[1], az = a[2];\n  let bx = b[0], by = b[1], bz = b[2];\n\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction hermite(out, a, b, c, d, t) {\n  let factorTimes2 = t * t;\n  let factor1 = factorTimes2 * (2 * t - 3) + 1;\n  let factor2 = factorTimes2 * (t - 2) + t;\n  let factor3 = factorTimes2 * (t - 1);\n  let factor4 = factorTimes2 * (3 - 2 * t);\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nfunction bezier(out, a, b, c, d, t) {\n  let inverseFactor = 1 - t;\n  let inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  let factorTimes2 = t * t;\n  let factor1 = inverseFactorTimesTwo * inverseFactor;\n  let factor2 = 3 * t * inverseFactorTimesTwo;\n  let factor3 = 3 * factorTimes2 * inverseFactor;\n  let factor4 = factorTimes2 * t;\n\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n\n  let r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\n  let z = (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0) - 1.0;\n  let zScale = Math.sqrt(1.0-z*z) * scale;\n\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n  let x = a[0], y = a[1], z = a[2];\n  let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n  let x = a[0], y = a[1], z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n    let qx = q[0], qy = q[1], qz = q[2], qw = q[3];\n    let x = a[0], y = a[1], z = a[2];\n    // var qvec = [qx, qy, qz];\n    // var uv = vec3.cross([], qvec, a);\n    let uvx = qy * z - qz * y,\n        uvy = qz * x - qx * z,\n        uvz = qx * y - qy * x;\n    // var uuv = vec3.cross([], qvec, uv);\n    let uuvx = qy * uvz - qz * uvy,\n        uuvy = qz * uvx - qx * uvz,\n        uuvz = qx * uvy - qy * uvx;\n    // vec3.scale(uv, uv, 2 * w);\n    let w2 = qw * 2;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n    // vec3.scale(uuv, uuv, 2);\n    uuvx *= 2;\n    uuvy *= 2;\n    uuvz *= 2;\n    // return vec3.add(out, a, vec3.add(out, uv, uuv));\n    out[0] = x + uvx + uuvx;\n    out[1] = y + uvy + uuvy;\n    out[2] = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n  let p = [], r=[];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0];\n  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);\n  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n  let p = [], r=[];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);\n  r[1] = p[1];\n  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n  let p = [], r=[];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);\n  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);\n  r[2] = p[2];\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n\n  return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n  let tempA = fromValues(a[0], a[1], a[2]);\n  let tempB = fromValues(b[0], b[1], b[2]);\n\n  normalize(tempA, tempA);\n  normalize(tempB, tempB);\n\n  let cosine = dot(tempA, tempB);\n\n  if(cosine > 1.0) {\n    return 0;\n  }\n  else if(cosine < -1.0) {\n    return Math.PI;\n  } else {\n    return Math.acos(cosine);\n  }\n}\n\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2];\n  let b0 = b[0], b1 = b[1], b2 = b[2];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));\n}\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nconst sub = subtract;\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nconst div = divide;\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nconst dist = distance;\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nconst sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nconst len = length;\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nconst forEach = (function() {\n  let vec = create();\n\n  return function(a, stride, offset, count, fn, arg) {\n    let i, l;\n    if(!stride) {\n      stride = 3;\n    }\n\n    if(!offset) {\n      offset = 0;\n    }\n\n    if(count) {\n      l = Math.min((count * stride) + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for(i = offset; i < l; i += stride) {\n      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];\n      fn(vec, vec, arg);\n      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];\n    }\n\n    return a;\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/vec3.js?");

/***/ }),

/***/ "./src/includes/vec4.js":
/*!******************************!*\
  !*** ./src/includes/vec4.js ***!
  \******************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zero\", function() { return zero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./src/includes/common.js\");\n\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nfunction create() {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  if(_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {vec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nfunction clone(a) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nfunction fromValues(x, y, z, w) {\n  let out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to ceil\n * @returns {vec4} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to floor\n * @returns {vec4} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to round\n * @returns {vec4} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + (b[0] * scale);\n  out[1] = a[1] + (b[1] * scale);\n  out[2] = a[2] + (b[2] * scale);\n  out[3] = a[3] + (b[3] * scale);\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  let w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n  let x = b[0] - a[0];\n  let y = b[1] - a[1];\n  let z = b[2] - a[2];\n  let w = b[3] - a[3];\n  return x*x + y*y + z*z + w*w;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {vec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  return x*x + y*y + z*z + w*w;\n}\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to negate\n * @returns {vec4} out\n */\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to invert\n * @returns {vec4} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nfunction normalize(out, a) {\n  let x = a[0];\n  let y = a[1];\n  let z = a[2];\n  let w = a[3];\n  let len = x*x + y*y + z*z + w*w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {vec4} result the receiving vector\n * @param {vec4} U the first vector\n * @param {vec4} V the second vector\n * @param {vec4} W the third vector\n * @returns {vec4} result\n */\nfunction cross (out, u, v, w) {\n    let A = (v[0] * w[1]) - (v[1] * w[0]),\n        B = (v[0] * w[2]) - (v[2] * w[0]),\n        C = (v[0] * w[3]) - (v[3] * w[0]),\n        D = (v[1] * w[2]) - (v[2] * w[1]),\n        E = (v[1] * w[3]) - (v[3] * w[1]),\n        F = (v[2] * w[3]) - (v[3] * w[2]);\n    let G = u[0];\n    let H = u[1];\n    let I = u[2];\n    let J = u[3];\n\n    out[0] = (H * F) - (I * E) + (J * D);\n    out[1] = -(G * F) + (I * C) - (J * B);\n    out[2] = (G * E) - (H * C) + (J * A);\n    out[3] = -(G * D) + (H * B) - (I * A);\n\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\nfunction lerp(out, a, b, t) {\n  let ax = a[0];\n  let ay = a[1];\n  let az = a[2];\n  let aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\nfunction random(out, scale) {\n  scale = scale || 1.0;\n\n  // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n  var v1, v2, v3, v4;\n  var s1, s2;\n  do {\n    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n  do {\n    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec4} out\n */\nfunction transformMat4(out, a, m) {\n  let x = a[0], y = a[1], z = a[2], w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec4} out\n */\nfunction transformQuat(out, a, q) {\n  let x = a[0], y = a[1], z = a[2];\n  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];\n\n  // calculate quat * vec\n  let ix = qw * x + qy * z - qz * y;\n  let iy = qw * y + qz * x - qx * z;\n  let iz = qw * z + qx * y - qy * x;\n  let iw = -qx * x - qy * y - qz * z;\n\n  // calculate result * inverse quat\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nfunction str(a) {\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n  return (Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n          Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n}\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nconst sub = subtract;\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nconst mul = multiply;\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nconst div = divide;\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nconst dist = distance;\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nconst sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nconst len = length;\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nconst sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nconst forEach = (function() {\n  let vec = create();\n\n  return function(a, stride, offset, count, fn, arg) {\n    let i, l;\n    if(!stride) {\n      stride = 4;\n    }\n\n    if(!offset) {\n      offset = 0;\n    }\n\n    if(count) {\n      l = Math.min((count * stride) + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for(i = offset; i < l; i += stride) {\n      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];\n      fn(vec, vec, arg);\n      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];\n    }\n\n    return a;\n  };\n})();\n\n\n//# sourceURL=webpack:///./src/includes/vec4.js?");

/***/ })

/******/ });